/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkwebcli_demo"] = self["webpackChunkwebcli_demo"] || []).push([["vendors-node_modules_mermaid_dist_chunks_mermaid_core_architectureDiagram-UYN6MBPD_mjs"],{

/***/ "./node_modules/cytoscape-fcose/cytoscape-fcose.js":
/*!*********************************************************!*\
  !*** ./node_modules/cytoscape-fcose/cytoscape-fcose.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(/*! cose-base */ \"./node_modules/cytoscape-fcose/node_modules/cose-base/cose-base.js\"));\n\telse {}\n})(this, function(__WEBPACK_EXTERNAL_MODULE__140__) {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 658:\n/***/ ((module) => {\n\n\n\n// Simple, internal Object.assign() polyfill for options objects etc.\n\nmodule.exports = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {\n  for (var _len = arguments.length, srcs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    srcs[_key - 1] = arguments[_key];\n  }\n\n  srcs.forEach(function (src) {\n    Object.keys(src).forEach(function (k) {\n      return tgt[k] = src[k];\n    });\n  });\n\n  return tgt;\n};\n\n/***/ }),\n\n/***/ 548:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_1129__) => {\n\n\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\n/*\n * Auxiliary functions\n */\n\nvar LinkedList = __nested_webpack_require_1129__(140).layoutBase.LinkedList;\n\nvar auxiliary = {};\n\n// get the top most nodes\nauxiliary.getTopMostNodes = function (nodes) {\n  var nodesMap = {};\n  for (var i = 0; i < nodes.length; i++) {\n    nodesMap[nodes[i].id()] = true;\n  }\n  var roots = nodes.filter(function (ele, i) {\n    if (typeof ele === \"number\") {\n      ele = i;\n    }\n    var parent = ele.parent()[0];\n    while (parent != null) {\n      if (nodesMap[parent.id()]) {\n        return false;\n      }\n      parent = parent.parent()[0];\n    }\n    return true;\n  });\n\n  return roots;\n};\n\n// find disconnected components and create dummy nodes that connect them\nauxiliary.connectComponents = function (cy, eles, topMostNodes, dummyNodes) {\n  var queue = new LinkedList();\n  var visited = new Set();\n  var visitedTopMostNodes = [];\n  var currentNeighbor = void 0;\n  var minDegreeNode = void 0;\n  var minDegree = void 0;\n\n  var isConnected = false;\n  var count = 1;\n  var nodesConnectedToDummy = [];\n  var components = [];\n\n  var _loop = function _loop() {\n    var cmpt = cy.collection();\n    components.push(cmpt);\n\n    var currentNode = topMostNodes[0];\n    var childrenOfCurrentNode = cy.collection();\n    childrenOfCurrentNode.merge(currentNode).merge(currentNode.descendants().intersection(eles));\n    visitedTopMostNodes.push(currentNode);\n\n    childrenOfCurrentNode.forEach(function (node) {\n      queue.push(node);\n      visited.add(node);\n      cmpt.merge(node);\n    });\n\n    var _loop2 = function _loop2() {\n      currentNode = queue.shift();\n\n      // Traverse all neighbors of this node\n      var neighborNodes = cy.collection();\n      currentNode.neighborhood().nodes().forEach(function (node) {\n        if (eles.intersection(currentNode.edgesWith(node)).length > 0) {\n          neighborNodes.merge(node);\n        }\n      });\n\n      for (var i = 0; i < neighborNodes.length; i++) {\n        var neighborNode = neighborNodes[i];\n        currentNeighbor = topMostNodes.intersection(neighborNode.union(neighborNode.ancestors()));\n        if (currentNeighbor != null && !visited.has(currentNeighbor[0])) {\n          var childrenOfNeighbor = currentNeighbor.union(currentNeighbor.descendants());\n\n          childrenOfNeighbor.forEach(function (node) {\n            queue.push(node);\n            visited.add(node);\n            cmpt.merge(node);\n            if (topMostNodes.has(node)) {\n              visitedTopMostNodes.push(node);\n            }\n          });\n        }\n      }\n    };\n\n    while (queue.length != 0) {\n      _loop2();\n    }\n\n    cmpt.forEach(function (node) {\n      eles.intersection(node.connectedEdges()).forEach(function (e) {\n        // connectedEdges() usually cached\n        if (cmpt.has(e.source()) && cmpt.has(e.target())) {\n          // has() is cheap\n          cmpt.merge(e);\n        }\n      });\n    });\n\n    if (visitedTopMostNodes.length == topMostNodes.length) {\n      isConnected = true;\n    }\n\n    if (!isConnected || isConnected && count > 1) {\n      minDegreeNode = visitedTopMostNodes[0];\n      minDegree = minDegreeNode.connectedEdges().length;\n      visitedTopMostNodes.forEach(function (node) {\n        if (node.connectedEdges().length < minDegree) {\n          minDegree = node.connectedEdges().length;\n          minDegreeNode = node;\n        }\n      });\n      nodesConnectedToDummy.push(minDegreeNode.id());\n      // TO DO: Check efficiency of this part\n      var temp = cy.collection();\n      temp.merge(visitedTopMostNodes[0]);\n      visitedTopMostNodes.forEach(function (node) {\n        temp.merge(node);\n      });\n      visitedTopMostNodes = [];\n      topMostNodes = topMostNodes.difference(temp);\n      count++;\n    }\n  };\n\n  do {\n    _loop();\n  } while (!isConnected);\n\n  if (dummyNodes) {\n    if (nodesConnectedToDummy.length > 0) {\n      dummyNodes.set('dummy' + (dummyNodes.size + 1), nodesConnectedToDummy);\n    }\n  }\n  return components;\n};\n\n// relocates componentResult to originalCenter if there is no fixedNodeConstraint\nauxiliary.relocateComponent = function (originalCenter, componentResult, options) {\n  if (!options.fixedNodeConstraint) {\n    var minXCoord = Number.POSITIVE_INFINITY;\n    var maxXCoord = Number.NEGATIVE_INFINITY;\n    var minYCoord = Number.POSITIVE_INFINITY;\n    var maxYCoord = Number.NEGATIVE_INFINITY;\n    if (options.quality == \"draft\") {\n      // calculate current bounding box\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = componentResult.nodeIndexes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _ref = _step.value;\n\n          var _ref2 = _slicedToArray(_ref, 2);\n\n          var key = _ref2[0];\n          var value = _ref2[1];\n\n          var cyNode = options.cy.getElementById(key);\n          if (cyNode) {\n            var nodeBB = cyNode.boundingBox();\n            var leftX = componentResult.xCoords[value] - nodeBB.w / 2;\n            var rightX = componentResult.xCoords[value] + nodeBB.w / 2;\n            var topY = componentResult.yCoords[value] - nodeBB.h / 2;\n            var bottomY = componentResult.yCoords[value] + nodeBB.h / 2;\n\n            if (leftX < minXCoord) minXCoord = leftX;\n            if (rightX > maxXCoord) maxXCoord = rightX;\n            if (topY < minYCoord) minYCoord = topY;\n            if (bottomY > maxYCoord) maxYCoord = bottomY;\n          }\n        }\n        // find difference between current and original center\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var diffOnX = originalCenter.x - (maxXCoord + minXCoord) / 2;\n      var diffOnY = originalCenter.y - (maxYCoord + minYCoord) / 2;\n      // move component to original center\n      componentResult.xCoords = componentResult.xCoords.map(function (x) {\n        return x + diffOnX;\n      });\n      componentResult.yCoords = componentResult.yCoords.map(function (y) {\n        return y + diffOnY;\n      });\n    } else {\n      // calculate current bounding box\n      Object.keys(componentResult).forEach(function (item) {\n        var node = componentResult[item];\n        var leftX = node.getRect().x;\n        var rightX = node.getRect().x + node.getRect().width;\n        var topY = node.getRect().y;\n        var bottomY = node.getRect().y + node.getRect().height;\n\n        if (leftX < minXCoord) minXCoord = leftX;\n        if (rightX > maxXCoord) maxXCoord = rightX;\n        if (topY < minYCoord) minYCoord = topY;\n        if (bottomY > maxYCoord) maxYCoord = bottomY;\n      });\n      // find difference between current and original center\n      var _diffOnX = originalCenter.x - (maxXCoord + minXCoord) / 2;\n      var _diffOnY = originalCenter.y - (maxYCoord + minYCoord) / 2;\n      // move component to original center\n      Object.keys(componentResult).forEach(function (item) {\n        var node = componentResult[item];\n        node.setCenter(node.getCenterX() + _diffOnX, node.getCenterY() + _diffOnY);\n      });\n    }\n  }\n};\n\nauxiliary.calcBoundingBox = function (parentNode, xCoords, yCoords, nodeIndexes) {\n  // calculate bounds\n  var left = Number.MAX_SAFE_INTEGER;\n  var right = Number.MIN_SAFE_INTEGER;\n  var top = Number.MAX_SAFE_INTEGER;\n  var bottom = Number.MIN_SAFE_INTEGER;\n  var nodeLeft = void 0;\n  var nodeRight = void 0;\n  var nodeTop = void 0;\n  var nodeBottom = void 0;\n\n  var nodes = parentNode.descendants().not(\":parent\");\n  var s = nodes.length;\n  for (var i = 0; i < s; i++) {\n    var node = nodes[i];\n\n    nodeLeft = xCoords[nodeIndexes.get(node.id())] - node.width() / 2;\n    nodeRight = xCoords[nodeIndexes.get(node.id())] + node.width() / 2;\n    nodeTop = yCoords[nodeIndexes.get(node.id())] - node.height() / 2;\n    nodeBottom = yCoords[nodeIndexes.get(node.id())] + node.height() / 2;\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight) {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom) {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingBox = {};\n  boundingBox.topLeftX = left;\n  boundingBox.topLeftY = top;\n  boundingBox.width = right - left;\n  boundingBox.height = bottom - top;\n  return boundingBox;\n};\n\n// This function finds and returns parent nodes whose all children are hidden\nauxiliary.calcParentsWithoutChildren = function (cy, eles) {\n  var parentsWithoutChildren = cy.collection();\n  eles.nodes(':parent').forEach(function (parent) {\n    var check = false;\n    parent.children().forEach(function (child) {\n      if (child.css('display') != 'none') {\n        check = true;\n      }\n    });\n    if (!check) {\n      parentsWithoutChildren.merge(parent);\n    }\n  });\n\n  return parentsWithoutChildren;\n};\n\nmodule.exports = auxiliary;\n\n/***/ }),\n\n/***/ 816:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_10973__) => {\n\n\n\n/**\n  The implementation of the postprocessing part that applies CoSE layout over the spectral layout\n*/\n\nvar aux = __nested_webpack_require_10973__(548);\nvar CoSELayout = __nested_webpack_require_10973__(140).CoSELayout;\nvar CoSENode = __nested_webpack_require_10973__(140).CoSENode;\nvar PointD = __nested_webpack_require_10973__(140).layoutBase.PointD;\nvar DimensionD = __nested_webpack_require_10973__(140).layoutBase.DimensionD;\nvar LayoutConstants = __nested_webpack_require_10973__(140).layoutBase.LayoutConstants;\nvar FDLayoutConstants = __nested_webpack_require_10973__(140).layoutBase.FDLayoutConstants;\nvar CoSEConstants = __nested_webpack_require_10973__(140).CoSEConstants;\n\n// main function that cose layout is processed\nvar coseLayout = function coseLayout(options, spectralResult) {\n\n  var cy = options.cy;\n  var eles = options.eles;\n  var nodes = eles.nodes();\n  var edges = eles.edges();\n\n  var nodeIndexes = void 0;\n  var xCoords = void 0;\n  var yCoords = void 0;\n  var idToLNode = {};\n\n  if (options.randomize) {\n    nodeIndexes = spectralResult[\"nodeIndexes\"];\n    xCoords = spectralResult[\"xCoords\"];\n    yCoords = spectralResult[\"yCoords\"];\n  }\n\n  var isFn = function isFn(fn) {\n    return typeof fn === 'function';\n  };\n\n  var optFn = function optFn(opt, ele) {\n    if (isFn(opt)) {\n      return opt(ele);\n    } else {\n      return opt;\n    }\n  };\n\n  /**** Postprocessing functions ****/\n\n  var parentsWithoutChildren = aux.calcParentsWithoutChildren(cy, eles);\n\n  // transfer cytoscape nodes to cose nodes\n  var processChildrenList = function processChildrenList(parent, children, layout, options) {\n    var size = children.length;\n    for (var i = 0; i < size; i++) {\n      var theChild = children[i];\n      var children_of_children = null;\n      if (theChild.intersection(parentsWithoutChildren).length == 0) {\n        children_of_children = theChild.children();\n      }\n      var theNode = void 0;\n\n      var dimensions = theChild.layoutDimensions({\n        nodeDimensionsIncludeLabels: options.nodeDimensionsIncludeLabels\n      });\n\n      if (theChild.outerWidth() != null && theChild.outerHeight() != null) {\n        if (options.randomize) {\n          if (!theChild.isParent()) {\n            theNode = parent.add(new CoSENode(layout.graphManager, new PointD(xCoords[nodeIndexes.get(theChild.id())] - dimensions.w / 2, yCoords[nodeIndexes.get(theChild.id())] - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n          } else {\n            var parentInfo = aux.calcBoundingBox(theChild, xCoords, yCoords, nodeIndexes);\n            if (theChild.intersection(parentsWithoutChildren).length == 0) {\n              theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD(parentInfo.width, parentInfo.height)));\n            } else {\n              // for the parentsWithoutChildren\n              theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n            }\n          }\n        } else {\n          theNode = parent.add(new CoSENode(layout.graphManager, new PointD(theChild.position('x') - dimensions.w / 2, theChild.position('y') - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));\n        }\n      } else {\n        theNode = parent.add(new CoSENode(this.graphManager));\n      }\n      // Attach id to the layout node and repulsion value\n      theNode.id = theChild.data(\"id\");\n      theNode.nodeRepulsion = optFn(options.nodeRepulsion, theChild);\n      // Attach the paddings of cy node to layout node\n      theNode.paddingLeft = parseInt(theChild.css('padding'));\n      theNode.paddingTop = parseInt(theChild.css('padding'));\n      theNode.paddingRight = parseInt(theChild.css('padding'));\n      theNode.paddingBottom = parseInt(theChild.css('padding'));\n\n      //Attach the label properties to both compound and simple nodes if labels will be included in node dimensions\n      //These properties will be used while updating bounds of compounds during iterations or tiling\n      //and will be used for simple nodes while transferring final positions to cytoscape\n      if (options.nodeDimensionsIncludeLabels) {\n        theNode.labelWidth = theChild.boundingBox({ includeLabels: true, includeNodes: false, includeOverlays: false }).w;\n        theNode.labelHeight = theChild.boundingBox({ includeLabels: true, includeNodes: false, includeOverlays: false }).h;\n        theNode.labelPosVertical = theChild.css(\"text-valign\");\n        theNode.labelPosHorizontal = theChild.css(\"text-halign\");\n      }\n\n      // Map the layout node\n      idToLNode[theChild.data(\"id\")] = theNode;\n\n      if (isNaN(theNode.rect.x)) {\n        theNode.rect.x = 0;\n      }\n\n      if (isNaN(theNode.rect.y)) {\n        theNode.rect.y = 0;\n      }\n\n      if (children_of_children != null && children_of_children.length > 0) {\n        var theNewGraph = void 0;\n        theNewGraph = layout.getGraphManager().add(layout.newGraph(), theNode);\n        processChildrenList(theNewGraph, children_of_children, layout, options);\n      }\n    }\n  };\n\n  // transfer cytoscape edges to cose edges\n  var processEdges = function processEdges(layout, gm, edges) {\n    var idealLengthTotal = 0;\n    var edgeCount = 0;\n    for (var i = 0; i < edges.length; i++) {\n      var edge = edges[i];\n      var sourceNode = idToLNode[edge.data(\"source\")];\n      var targetNode = idToLNode[edge.data(\"target\")];\n      if (sourceNode && targetNode && sourceNode !== targetNode && sourceNode.getEdgesBetween(targetNode).length == 0) {\n        var e1 = gm.add(layout.newEdge(), sourceNode, targetNode);\n        e1.id = edge.id();\n        e1.idealLength = optFn(options.idealEdgeLength, edge);\n        e1.edgeElasticity = optFn(options.edgeElasticity, edge);\n        idealLengthTotal += e1.idealLength;\n        edgeCount++;\n      }\n    }\n    // we need to update the ideal edge length constant with the avg. ideal length value after processing edges\n    // in case there is no edge, use other options\n    if (options.idealEdgeLength != null) {\n      if (edgeCount > 0) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = idealLengthTotal / edgeCount;else if (!isFn(options.idealEdgeLength)) // in case there is no edge, but option gives a value to use\n        CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = options.idealEdgeLength;else // in case there is no edge and we cannot get a value from option (because it's a function)\n        CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\n      // we need to update these constant values based on the ideal edge length constant\n      CoSEConstants.MIN_REPULSION_DIST = FDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\n      CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n    }\n  };\n\n  // transfer cytoscape constraints to cose layout\n  var processConstraints = function processConstraints(layout, options) {\n    // get nodes to be fixed\n    if (options.fixedNodeConstraint) {\n      layout.constraints[\"fixedNodeConstraint\"] = options.fixedNodeConstraint;\n    }\n    // get nodes to be aligned\n    if (options.alignmentConstraint) {\n      layout.constraints[\"alignmentConstraint\"] = options.alignmentConstraint;\n    }\n    // get nodes to be relatively placed\n    if (options.relativePlacementConstraint) {\n      layout.constraints[\"relativePlacementConstraint\"] = options.relativePlacementConstraint;\n    }\n  };\n\n  /**** Apply postprocessing ****/\n  if (options.nestingFactor != null) CoSEConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = options.nestingFactor;\n  if (options.gravity != null) CoSEConstants.DEFAULT_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = options.gravity;\n  if (options.numIter != null) CoSEConstants.MAX_ITERATIONS = FDLayoutConstants.MAX_ITERATIONS = options.numIter;\n  if (options.gravityRange != null) CoSEConstants.DEFAULT_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = options.gravityRange;\n  if (options.gravityCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = options.gravityCompound;\n  if (options.gravityRangeCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = options.gravityRangeCompound;\n  if (options.initialEnergyOnIncremental != null) CoSEConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = options.initialEnergyOnIncremental;\n\n  if (options.tilingCompareBy != null) CoSEConstants.TILING_COMPARE_BY = options.tilingCompareBy;\n\n  if (options.quality == 'proof') LayoutConstants.QUALITY = 2;else LayoutConstants.QUALITY = 0;\n\n  CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS = FDLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = options.nodeDimensionsIncludeLabels;\n  CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = !options.randomize;\n  CoSEConstants.ANIMATE = FDLayoutConstants.ANIMATE = LayoutConstants.ANIMATE = options.animate;\n  CoSEConstants.TILE = options.tile;\n  CoSEConstants.TILING_PADDING_VERTICAL = typeof options.tilingPaddingVertical === 'function' ? options.tilingPaddingVertical.call() : options.tilingPaddingVertical;\n  CoSEConstants.TILING_PADDING_HORIZONTAL = typeof options.tilingPaddingHorizontal === 'function' ? options.tilingPaddingHorizontal.call() : options.tilingPaddingHorizontal;\n\n  CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = true;\n  CoSEConstants.PURE_INCREMENTAL = !options.randomize;\n  LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = options.uniformNodeDimensions;\n\n  // This part is for debug/demo purpose\n  if (options.step == \"transformed\") {\n    CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;\n    CoSEConstants.ENFORCE_CONSTRAINTS = false;\n    CoSEConstants.APPLY_LAYOUT = false;\n  }\n  if (options.step == \"enforced\") {\n    CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n    CoSEConstants.ENFORCE_CONSTRAINTS = true;\n    CoSEConstants.APPLY_LAYOUT = false;\n  }\n  if (options.step == \"cose\") {\n    CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n    CoSEConstants.ENFORCE_CONSTRAINTS = false;\n    CoSEConstants.APPLY_LAYOUT = true;\n  }\n  if (options.step == \"all\") {\n    if (options.randomize) CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;else CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;\n    CoSEConstants.ENFORCE_CONSTRAINTS = true;\n    CoSEConstants.APPLY_LAYOUT = true;\n  }\n\n  if (options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint) {\n    CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false;\n  } else {\n    CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true;\n  }\n\n  var coseLayout = new CoSELayout();\n  var gm = coseLayout.newGraphManager();\n\n  processChildrenList(gm.addRoot(), aux.getTopMostNodes(nodes), coseLayout, options);\n  processEdges(coseLayout, gm, edges);\n  processConstraints(coseLayout, options);\n\n  coseLayout.runLayout();\n\n  return idToLNode;\n};\n\nmodule.exports = { coseLayout: coseLayout };\n\n/***/ }),\n\n/***/ 212:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_22455__) => {\n\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n  The implementation of the fcose layout algorithm\n*/\n\nvar assign = __nested_webpack_require_22455__(658);\nvar aux = __nested_webpack_require_22455__(548);\n\nvar _require = __nested_webpack_require_22455__(657),\n    spectralLayout = _require.spectralLayout;\n\nvar _require2 = __nested_webpack_require_22455__(816),\n    coseLayout = _require2.coseLayout;\n\nvar defaults = Object.freeze({\n\n  // 'draft', 'default' or 'proof' \n  // - 'draft' only applies spectral layout \n  // - 'default' improves the quality with subsequent CoSE layout (fast cooling rate)\n  // - 'proof' improves the quality with subsequent CoSE layout (slow cooling rate) \n  quality: \"default\",\n  // Use random node positions at beginning of layout\n  // if this is set to false, then quality option must be \"proof\"\n  randomize: true,\n  // Whether or not to animate the layout\n  animate: true,\n  // Duration of animation in ms, if enabled\n  animationDuration: 1000,\n  // Easing of animation, if enabled\n  animationEasing: undefined,\n  // Fit the viewport to the repositioned nodes\n  fit: true,\n  // Padding around layout\n  padding: 30,\n  // Whether to include labels in node dimensions. Valid in \"proof\" quality\n  nodeDimensionsIncludeLabels: false,\n  // Whether or not simple nodes (non-compound nodes) are of uniform dimensions\n  uniformNodeDimensions: false,\n  // Whether to pack disconnected components - valid only if randomize: true\n  packComponents: true,\n  // Layout step - all, transformed, enforced, cose - for debug purpose only\n  step: \"all\",\n\n  /* spectral layout options */\n\n  // False for random, true for greedy\n  samplingType: true,\n  // Sample size to construct distance matrix\n  sampleSize: 25,\n  // Separation amount between nodes\n  nodeSeparation: 75,\n  // Power iteration tolerance\n  piTol: 0.0000001,\n\n  /* CoSE layout options */\n\n  // Node repulsion (non overlapping) multiplier\n  nodeRepulsion: function nodeRepulsion(node) {\n    return 4500;\n  },\n  // Ideal edge (non nested) length\n  idealEdgeLength: function idealEdgeLength(edge) {\n    return 50;\n  },\n  // Divisor to compute edge forces\n  edgeElasticity: function edgeElasticity(edge) {\n    return 0.45;\n  },\n  // Nesting factor (multiplier) to compute ideal edge length for nested edges\n  nestingFactor: 0.1,\n  // Gravity force (constant)\n  gravity: 0.25,\n  // Maximum number of iterations to perform\n  numIter: 2500,\n  // For enabling tiling\n  tile: true,\n  // The function that specifies the criteria for comparing nodes while sorting them during tiling operation.\n  // Takes the node id as a parameter and the default tiling operation is perfomed when this option is not set.\n  tilingCompareBy: undefined,\n  // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)\n  tilingPaddingVertical: 10,\n  // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)\n  tilingPaddingHorizontal: 10,\n  // Gravity range (constant) for compounds\n  gravityRangeCompound: 1.5,\n  // Gravity force (constant) for compounds\n  gravityCompound: 1.0,\n  // Gravity range (constant)\n  gravityRange: 3.8,\n  // Initial cooling factor for incremental layout  \n  initialEnergyOnIncremental: 0.3,\n\n  /* constraint options */\n\n  // Fix required nodes to predefined positions\n  // [{nodeId: 'n1', position: {x: 100, y: 200}, {...}]\n  fixedNodeConstraint: undefined,\n  // Align required nodes in vertical/horizontal direction\n  // {vertical: [['n1', 'n2')], ['n3', 'n4']], horizontal: ['n2', 'n4']}\n  alignmentConstraint: undefined,\n  // Place two nodes relatively in vertical/horizontal direction \n  // [{top: 'n1', bottom: 'n2', gap: 100}, {left: 'n3', right: 'n4', gap: 75}]\n  relativePlacementConstraint: undefined,\n\n  /* layout event callbacks */\n  ready: function ready() {}, // on layoutready\n  stop: function stop() {} // on layoutstop\n});\n\nvar Layout = function () {\n  function Layout(options) {\n    _classCallCheck(this, Layout);\n\n    this.options = assign({}, defaults, options);\n  }\n\n  _createClass(Layout, [{\n    key: 'run',\n    value: function run() {\n      var layout = this;\n      var options = this.options;\n      var cy = options.cy;\n      var eles = options.eles;\n\n      var spectralResult = [];\n      var xCoords = void 0;\n      var yCoords = void 0;\n      var coseResult = [];\n      var components = void 0;\n      var componentCenters = [];\n\n      // basic validity check for constraint inputs \n      if (options.fixedNodeConstraint && (!Array.isArray(options.fixedNodeConstraint) || options.fixedNodeConstraint.length == 0)) {\n        options.fixedNodeConstraint = undefined;\n      }\n\n      if (options.alignmentConstraint) {\n        if (options.alignmentConstraint.vertical && (!Array.isArray(options.alignmentConstraint.vertical) || options.alignmentConstraint.vertical.length == 0)) {\n          options.alignmentConstraint.vertical = undefined;\n        }\n        if (options.alignmentConstraint.horizontal && (!Array.isArray(options.alignmentConstraint.horizontal) || options.alignmentConstraint.horizontal.length == 0)) {\n          options.alignmentConstraint.horizontal = undefined;\n        }\n      }\n\n      if (options.relativePlacementConstraint && (!Array.isArray(options.relativePlacementConstraint) || options.relativePlacementConstraint.length == 0)) {\n        options.relativePlacementConstraint = undefined;\n      }\n\n      // if any constraint exists, set some options\n      var constraintExist = options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint;\n      if (constraintExist) {\n        // constraints work with these options\n        options.tile = false;\n        options.packComponents = false;\n      }\n\n      // decide component packing is enabled or not\n      var layUtil = void 0;\n      var packingEnabled = false;\n      if (cy.layoutUtilities && options.packComponents) {\n        layUtil = cy.layoutUtilities(\"get\");\n        if (!layUtil) layUtil = cy.layoutUtilities();\n        packingEnabled = true;\n      }\n\n      if (eles.nodes().length > 0) {\n        // if packing is not enabled, perform layout on the whole graph\n        if (!packingEnabled) {\n          // store component center\n          var boundingBox = options.eles.boundingBox();\n          componentCenters.push({ x: boundingBox.x1 + boundingBox.w / 2, y: boundingBox.y1 + boundingBox.h / 2 });\n          // apply spectral layout\n          if (options.randomize) {\n            var result = spectralLayout(options);\n            spectralResult.push(result);\n          }\n          // apply cose layout as postprocessing\n          if (options.quality == \"default\" || options.quality == \"proof\") {\n            coseResult.push(coseLayout(options, spectralResult[0]));\n            aux.relocateComponent(componentCenters[0], coseResult[0], options); // relocate center to original position\n          } else {\n            aux.relocateComponent(componentCenters[0], spectralResult[0], options); // relocate center to original position\n          }\n        } else {\n          // packing is enabled\n          var topMostNodes = aux.getTopMostNodes(options.eles.nodes());\n          components = aux.connectComponents(cy, options.eles, topMostNodes);\n          // store component centers\n          components.forEach(function (component) {\n            var boundingBox = component.boundingBox();\n            componentCenters.push({ x: boundingBox.x1 + boundingBox.w / 2, y: boundingBox.y1 + boundingBox.h / 2 });\n          });\n\n          //send each component to spectral layout if randomized\n          if (options.randomize) {\n            components.forEach(function (component) {\n              options.eles = component;\n              spectralResult.push(spectralLayout(options));\n            });\n          }\n\n          if (options.quality == \"default\" || options.quality == \"proof\") {\n            var toBeTiledNodes = cy.collection();\n            if (options.tile) {\n              // behave nodes to be tiled as one component\n              var nodeIndexes = new Map();\n              var _xCoords = [];\n              var _yCoords = [];\n              var count = 0;\n              var tempSpectralResult = { nodeIndexes: nodeIndexes, xCoords: _xCoords, yCoords: _yCoords };\n              var indexesToBeDeleted = [];\n              components.forEach(function (component, index) {\n                if (component.edges().length == 0) {\n                  component.nodes().forEach(function (node, i) {\n                    toBeTiledNodes.merge(component.nodes()[i]);\n                    if (!node.isParent()) {\n                      tempSpectralResult.nodeIndexes.set(component.nodes()[i].id(), count++);\n                      tempSpectralResult.xCoords.push(component.nodes()[0].position().x);\n                      tempSpectralResult.yCoords.push(component.nodes()[0].position().y);\n                    }\n                  });\n                  indexesToBeDeleted.push(index);\n                }\n              });\n              if (toBeTiledNodes.length > 1) {\n                var _boundingBox = toBeTiledNodes.boundingBox();\n                componentCenters.push({ x: _boundingBox.x1 + _boundingBox.w / 2, y: _boundingBox.y1 + _boundingBox.h / 2 });\n                components.push(toBeTiledNodes);\n                spectralResult.push(tempSpectralResult);\n                for (var i = indexesToBeDeleted.length - 1; i >= 0; i--) {\n                  components.splice(indexesToBeDeleted[i], 1);\n                  spectralResult.splice(indexesToBeDeleted[i], 1);\n                  componentCenters.splice(indexesToBeDeleted[i], 1);\n                };\n              }\n            }\n            components.forEach(function (component, index) {\n              // send each component to cose layout\n              options.eles = component;\n              coseResult.push(coseLayout(options, spectralResult[index]));\n              aux.relocateComponent(componentCenters[index], coseResult[index], options); // relocate center to original position\n            });\n          } else {\n            components.forEach(function (component, index) {\n              aux.relocateComponent(componentCenters[index], spectralResult[index], options); // relocate center to original position\n            });\n          }\n\n          // packing\n          var componentsEvaluated = new Set();\n          if (components.length > 1) {\n            var subgraphs = [];\n            var hiddenEles = eles.filter(function (ele) {\n              return ele.css('display') == 'none';\n            });\n            components.forEach(function (component, index) {\n              var nodeIndexes = void 0;\n              if (options.quality == \"draft\") {\n                nodeIndexes = spectralResult[index].nodeIndexes;\n              }\n\n              if (component.nodes().not(hiddenEles).length > 0) {\n                var subgraph = {};\n                subgraph.edges = [];\n                subgraph.nodes = [];\n                var nodeIndex = void 0;\n                component.nodes().not(hiddenEles).forEach(function (node) {\n                  if (options.quality == \"draft\") {\n                    if (!node.isParent()) {\n                      nodeIndex = nodeIndexes.get(node.id());\n                      subgraph.nodes.push({ x: spectralResult[index].xCoords[nodeIndex] - node.boundingbox().w / 2, y: spectralResult[index].yCoords[nodeIndex] - node.boundingbox().h / 2, width: node.boundingbox().w, height: node.boundingbox().h });\n                    } else {\n                      var parentInfo = aux.calcBoundingBox(node, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                      subgraph.nodes.push({ x: parentInfo.topLeftX, y: parentInfo.topLeftY, width: parentInfo.width, height: parentInfo.height });\n                    }\n                  } else {\n                    if (coseResult[index][node.id()]) {\n                      subgraph.nodes.push({ x: coseResult[index][node.id()].getLeft(), y: coseResult[index][node.id()].getTop(), width: coseResult[index][node.id()].getWidth(), height: coseResult[index][node.id()].getHeight() });\n                    }\n                  }\n                });\n                component.edges().forEach(function (edge) {\n                  var source = edge.source();\n                  var target = edge.target();\n                  if (source.css(\"display\") != \"none\" && target.css(\"display\") != \"none\") {\n                    if (options.quality == \"draft\") {\n                      var sourceNodeIndex = nodeIndexes.get(source.id());\n                      var targetNodeIndex = nodeIndexes.get(target.id());\n                      var sourceCenter = [];\n                      var targetCenter = [];\n                      if (source.isParent()) {\n                        var parentInfo = aux.calcBoundingBox(source, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                        sourceCenter.push(parentInfo.topLeftX + parentInfo.width / 2);\n                        sourceCenter.push(parentInfo.topLeftY + parentInfo.height / 2);\n                      } else {\n                        sourceCenter.push(spectralResult[index].xCoords[sourceNodeIndex]);\n                        sourceCenter.push(spectralResult[index].yCoords[sourceNodeIndex]);\n                      }\n                      if (target.isParent()) {\n                        var _parentInfo = aux.calcBoundingBox(target, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);\n                        targetCenter.push(_parentInfo.topLeftX + _parentInfo.width / 2);\n                        targetCenter.push(_parentInfo.topLeftY + _parentInfo.height / 2);\n                      } else {\n                        targetCenter.push(spectralResult[index].xCoords[targetNodeIndex]);\n                        targetCenter.push(spectralResult[index].yCoords[targetNodeIndex]);\n                      }\n                      subgraph.edges.push({ startX: sourceCenter[0], startY: sourceCenter[1], endX: targetCenter[0], endY: targetCenter[1] });\n                    } else {\n                      if (coseResult[index][source.id()] && coseResult[index][target.id()]) {\n                        subgraph.edges.push({ startX: coseResult[index][source.id()].getCenterX(), startY: coseResult[index][source.id()].getCenterY(), endX: coseResult[index][target.id()].getCenterX(), endY: coseResult[index][target.id()].getCenterY() });\n                      }\n                    }\n                  }\n                });\n                if (subgraph.nodes.length > 0) {\n                  subgraphs.push(subgraph);\n                  componentsEvaluated.add(index);\n                }\n              }\n            });\n            var shiftResult = layUtil.packComponents(subgraphs, options.randomize).shifts;\n            if (options.quality == \"draft\") {\n              spectralResult.forEach(function (result, index) {\n                var newXCoords = result.xCoords.map(function (x) {\n                  return x + shiftResult[index].dx;\n                });\n                var newYCoords = result.yCoords.map(function (y) {\n                  return y + shiftResult[index].dy;\n                });\n                result.xCoords = newXCoords;\n                result.yCoords = newYCoords;\n              });\n            } else {\n              var _count = 0;\n              componentsEvaluated.forEach(function (index) {\n                Object.keys(coseResult[index]).forEach(function (item) {\n                  var nodeRectangle = coseResult[index][item];\n                  nodeRectangle.setCenter(nodeRectangle.getCenterX() + shiftResult[_count].dx, nodeRectangle.getCenterY() + shiftResult[_count].dy);\n                });\n                _count++;\n              });\n            }\n          }\n        }\n      }\n\n      // get each element's calculated position\n      var getPositions = function getPositions(ele, i) {\n        if (options.quality == \"default\" || options.quality == \"proof\") {\n          if (typeof ele === \"number\") {\n            ele = i;\n          }\n          var pos = void 0;\n          var node = void 0;\n          var theId = ele.data('id');\n          coseResult.forEach(function (result) {\n            if (theId in result) {\n              pos = { x: result[theId].getRect().getCenterX(), y: result[theId].getRect().getCenterY() };\n              node = result[theId];\n            }\n          });\n          if (options.nodeDimensionsIncludeLabels) {\n            if (node.labelWidth) {\n              if (node.labelPosHorizontal == \"left\") {\n                pos.x += node.labelWidth / 2;\n              } else if (node.labelPosHorizontal == \"right\") {\n                pos.x -= node.labelWidth / 2;\n              }\n            }\n            if (node.labelHeight) {\n              if (node.labelPosVertical == \"top\") {\n                pos.y += node.labelHeight / 2;\n              } else if (node.labelPosVertical == \"bottom\") {\n                pos.y -= node.labelHeight / 2;\n              }\n            }\n          }\n          if (pos == undefined) pos = { x: ele.position(\"x\"), y: ele.position(\"y\") };\n          return {\n            x: pos.x,\n            y: pos.y\n          };\n        } else {\n          var _pos = void 0;\n          spectralResult.forEach(function (result) {\n            var index = result.nodeIndexes.get(ele.id());\n            if (index != undefined) {\n              _pos = { x: result.xCoords[index], y: result.yCoords[index] };\n            }\n          });\n          if (_pos == undefined) _pos = { x: ele.position(\"x\"), y: ele.position(\"y\") };\n          return {\n            x: _pos.x,\n            y: _pos.y\n          };\n        }\n      };\n\n      // quality = \"draft\" and randomize = false are contradictive so in that case positions don't change\n      if (options.quality == \"default\" || options.quality == \"proof\" || options.randomize) {\n        // transfer calculated positions to nodes (positions of only simple nodes are evaluated, compounds are positioned automatically)\n        var parentsWithoutChildren = aux.calcParentsWithoutChildren(cy, eles);\n        var _hiddenEles = eles.filter(function (ele) {\n          return ele.css('display') == 'none';\n        });\n        options.eles = eles.not(_hiddenEles);\n\n        eles.nodes().not(\":parent\").not(_hiddenEles).layoutPositions(layout, options, getPositions);\n\n        if (parentsWithoutChildren.length > 0) {\n          parentsWithoutChildren.forEach(function (ele) {\n            ele.position(getPositions(ele));\n          });\n        }\n      } else {\n        console.log(\"If randomize option is set to false, then quality option must be 'default' or 'proof'.\");\n      }\n    }\n  }]);\n\n  return Layout;\n}();\n\nmodule.exports = Layout;\n\n/***/ }),\n\n/***/ 657:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_41986__) => {\n\n\n\n/**\n  The implementation of the spectral layout that is the first part of the fcose layout algorithm\n*/\n\nvar aux = __nested_webpack_require_41986__(548);\nvar Matrix = __nested_webpack_require_41986__(140).layoutBase.Matrix;\nvar SVD = __nested_webpack_require_41986__(140).layoutBase.SVD;\n\n// main function that spectral layout is processed\nvar spectralLayout = function spectralLayout(options) {\n\n  var cy = options.cy;\n  var eles = options.eles;\n  var nodes = eles.nodes();\n  var parentNodes = eles.nodes(\":parent\");\n\n  var dummyNodes = new Map(); // map to keep dummy nodes and their neighbors\n  var nodeIndexes = new Map(); // map to keep indexes to nodes\n  var parentChildMap = new Map(); // mapping btw. compound and its representative node \n  var allNodesNeighborhood = []; // array to keep neighborhood of all nodes\n  var xCoords = [];\n  var yCoords = [];\n\n  var samplesColumn = []; // sampled vertices\n  var minDistancesColumn = [];\n  var C = []; // column sampling matrix\n  var PHI = []; // intersection of column and row sampling matrices \n  var INV = []; // inverse of PHI \n\n  var firstSample = void 0; // the first sampled node\n  var nodeSize = void 0;\n\n  var infinity = 100000000;\n  var small = 0.000000001;\n\n  var piTol = options.piTol;\n  var samplingType = options.samplingType; // false for random, true for greedy\n  var nodeSeparation = options.nodeSeparation;\n  var sampleSize = void 0;\n\n  /**** Spectral-preprocessing functions ****/\n\n  /**** Spectral layout functions ****/\n\n  // determine which columns to be sampled\n  var randomSampleCR = function randomSampleCR() {\n    var sample = 0;\n    var count = 0;\n    var flag = false;\n\n    while (count < sampleSize) {\n      sample = Math.floor(Math.random() * nodeSize);\n\n      flag = false;\n      for (var i = 0; i < count; i++) {\n        if (samplesColumn[i] == sample) {\n          flag = true;\n          break;\n        }\n      }\n\n      if (!flag) {\n        samplesColumn[count] = sample;\n        count++;\n      } else {\n        continue;\n      }\n    }\n  };\n\n  // takes the index of the node(pivot) to initiate BFS as a parameter\n  var BFS = function BFS(pivot, index, samplingMethod) {\n    var path = []; // the front of the path\n    var front = 0; // the back of the path\n    var back = 0;\n    var current = 0;\n    var temp = void 0;\n    var distance = [];\n\n    var max_dist = 0; // the furthest node to be returned\n    var max_ind = 1;\n\n    for (var i = 0; i < nodeSize; i++) {\n      distance[i] = infinity;\n    }\n\n    path[back] = pivot;\n    distance[pivot] = 0;\n\n    while (back >= front) {\n      current = path[front++];\n      var neighbors = allNodesNeighborhood[current];\n      for (var _i = 0; _i < neighbors.length; _i++) {\n        temp = nodeIndexes.get(neighbors[_i]);\n        if (distance[temp] == infinity) {\n          distance[temp] = distance[current] + 1;\n          path[++back] = temp;\n        }\n      }\n      C[current][index] = distance[current] * nodeSeparation;\n    }\n\n    if (samplingMethod) {\n      for (var _i2 = 0; _i2 < nodeSize; _i2++) {\n        if (C[_i2][index] < minDistancesColumn[_i2]) minDistancesColumn[_i2] = C[_i2][index];\n      }\n\n      for (var _i3 = 0; _i3 < nodeSize; _i3++) {\n        if (minDistancesColumn[_i3] > max_dist) {\n          max_dist = minDistancesColumn[_i3];\n          max_ind = _i3;\n        }\n      }\n    }\n    return max_ind;\n  };\n\n  // apply BFS to all nodes or selected samples\n  var allBFS = function allBFS(samplingMethod) {\n\n    var sample = void 0;\n\n    if (!samplingMethod) {\n      randomSampleCR();\n\n      // call BFS\n      for (var i = 0; i < sampleSize; i++) {\n        BFS(samplesColumn[i], i, samplingMethod, false);\n      }\n    } else {\n      sample = Math.floor(Math.random() * nodeSize);\n      firstSample = sample;\n\n      for (var _i4 = 0; _i4 < nodeSize; _i4++) {\n        minDistancesColumn[_i4] = infinity;\n      }\n\n      for (var _i5 = 0; _i5 < sampleSize; _i5++) {\n        samplesColumn[_i5] = sample;\n        sample = BFS(sample, _i5, samplingMethod);\n      }\n    }\n\n    // form the squared distances for C\n    for (var _i6 = 0; _i6 < nodeSize; _i6++) {\n      for (var j = 0; j < sampleSize; j++) {\n        C[_i6][j] *= C[_i6][j];\n      }\n    }\n\n    // form PHI\n    for (var _i7 = 0; _i7 < sampleSize; _i7++) {\n      PHI[_i7] = [];\n    }\n\n    for (var _i8 = 0; _i8 < sampleSize; _i8++) {\n      for (var _j = 0; _j < sampleSize; _j++) {\n        PHI[_i8][_j] = C[samplesColumn[_j]][_i8];\n      }\n    }\n  };\n\n  // perform the SVD algorithm and apply a regularization step\n  var sample = function sample() {\n\n    var SVDResult = SVD.svd(PHI);\n\n    var a_q = SVDResult.S;\n    var a_u = SVDResult.U;\n    var a_v = SVDResult.V;\n\n    var max_s = a_q[0] * a_q[0] * a_q[0];\n\n    var a_Sig = [];\n\n    //  regularization\n    for (var i = 0; i < sampleSize; i++) {\n      a_Sig[i] = [];\n      for (var j = 0; j < sampleSize; j++) {\n        a_Sig[i][j] = 0;\n        if (i == j) {\n          a_Sig[i][j] = a_q[i] / (a_q[i] * a_q[i] + max_s / (a_q[i] * a_q[i]));\n        }\n      }\n    }\n\n    INV = Matrix.multMat(Matrix.multMat(a_v, a_Sig), Matrix.transpose(a_u));\n  };\n\n  // calculate final coordinates \n  var powerIteration = function powerIteration() {\n    // two largest eigenvalues\n    var theta1 = void 0;\n    var theta2 = void 0;\n\n    // initial guesses for eigenvectors\n    var Y1 = [];\n    var Y2 = [];\n\n    var V1 = [];\n    var V2 = [];\n\n    for (var i = 0; i < nodeSize; i++) {\n      Y1[i] = Math.random();\n      Y2[i] = Math.random();\n    }\n\n    Y1 = Matrix.normalize(Y1);\n    Y2 = Matrix.normalize(Y2);\n\n    var count = 0;\n    // to keep track of the improvement ratio in power iteration\n    var current = small;\n    var previous = small;\n\n    var temp = void 0;\n\n    while (true) {\n      count++;\n\n      for (var _i9 = 0; _i9 < nodeSize; _i9++) {\n        V1[_i9] = Y1[_i9];\n      }\n\n      Y1 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V1), C, INV));\n      theta1 = Matrix.dotProduct(V1, Y1);\n      Y1 = Matrix.normalize(Y1);\n\n      current = Matrix.dotProduct(V1, Y1);\n\n      temp = Math.abs(current / previous);\n\n      if (temp <= 1 + piTol && temp >= 1) {\n        break;\n      }\n\n      previous = current;\n    }\n\n    for (var _i10 = 0; _i10 < nodeSize; _i10++) {\n      V1[_i10] = Y1[_i10];\n    }\n\n    count = 0;\n    previous = small;\n    while (true) {\n      count++;\n\n      for (var _i11 = 0; _i11 < nodeSize; _i11++) {\n        V2[_i11] = Y2[_i11];\n      }\n\n      V2 = Matrix.minusOp(V2, Matrix.multCons(V1, Matrix.dotProduct(V1, V2)));\n      Y2 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V2), C, INV));\n      theta2 = Matrix.dotProduct(V2, Y2);\n      Y2 = Matrix.normalize(Y2);\n\n      current = Matrix.dotProduct(V2, Y2);\n\n      temp = Math.abs(current / previous);\n\n      if (temp <= 1 + piTol && temp >= 1) {\n        break;\n      }\n\n      previous = current;\n    }\n\n    for (var _i12 = 0; _i12 < nodeSize; _i12++) {\n      V2[_i12] = Y2[_i12];\n    }\n\n    // theta1 now contains dominant eigenvalue\n    // theta2 now contains the second-largest eigenvalue\n    // V1 now contains theta1's eigenvector\n    // V2 now contains theta2's eigenvector\n\n    //populate the two vectors\n    xCoords = Matrix.multCons(V1, Math.sqrt(Math.abs(theta1)));\n    yCoords = Matrix.multCons(V2, Math.sqrt(Math.abs(theta2)));\n  };\n\n  /**** Preparation for spectral layout (Preprocessing) ****/\n\n  // connect disconnected components (first top level, then inside of each compound node)\n  aux.connectComponents(cy, eles, aux.getTopMostNodes(nodes), dummyNodes);\n\n  parentNodes.forEach(function (ele) {\n    aux.connectComponents(cy, eles, aux.getTopMostNodes(ele.descendants().intersection(eles)), dummyNodes);\n  });\n\n  // assign indexes to nodes (first real, then dummy nodes)\n  var index = 0;\n  for (var i = 0; i < nodes.length; i++) {\n    if (!nodes[i].isParent()) {\n      nodeIndexes.set(nodes[i].id(), index++);\n    }\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = dummyNodes.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var key = _step.value;\n\n      nodeIndexes.set(key, index++);\n    }\n\n    // instantiate the neighborhood matrix\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  for (var _i13 = 0; _i13 < nodeIndexes.size; _i13++) {\n    allNodesNeighborhood[_i13] = [];\n  }\n\n  // form a parent-child map to keep representative node of each compound node  \n  parentNodes.forEach(function (ele) {\n    var children = ele.children().intersection(eles);\n\n    //      let random = 0;\n    while (children.nodes(\":childless\").length == 0) {\n      //        random = Math.floor(Math.random() * children.nodes().length); // if all children are compound then proceed randomly\n      children = children.nodes()[0].children().intersection(eles);\n    }\n    //  select the representative node - we can apply different methods here\n    //      random = Math.floor(Math.random() * children.nodes(\":childless\").length);\n    var index = 0;\n    var min = children.nodes(\":childless\")[0].connectedEdges().length;\n    children.nodes(\":childless\").forEach(function (ele2, i) {\n      if (ele2.connectedEdges().length < min) {\n        min = ele2.connectedEdges().length;\n        index = i;\n      }\n    });\n    parentChildMap.set(ele.id(), children.nodes(\":childless\")[index].id());\n  });\n\n  // add neighborhood relations (first real, then dummy nodes)\n  nodes.forEach(function (ele) {\n    var eleIndex = void 0;\n\n    if (ele.isParent()) eleIndex = nodeIndexes.get(parentChildMap.get(ele.id()));else eleIndex = nodeIndexes.get(ele.id());\n\n    ele.neighborhood().nodes().forEach(function (node) {\n      if (eles.intersection(ele.edgesWith(node)).length > 0) {\n        if (node.isParent()) allNodesNeighborhood[eleIndex].push(parentChildMap.get(node.id()));else allNodesNeighborhood[eleIndex].push(node.id());\n      }\n    });\n  });\n\n  var _loop = function _loop(_key) {\n    var eleIndex = nodeIndexes.get(_key);\n    var disconnectedId = void 0;\n    dummyNodes.get(_key).forEach(function (id) {\n      if (cy.getElementById(id).isParent()) disconnectedId = parentChildMap.get(id);else disconnectedId = id;\n\n      allNodesNeighborhood[eleIndex].push(disconnectedId);\n      allNodesNeighborhood[nodeIndexes.get(disconnectedId)].push(_key);\n    });\n  };\n\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = dummyNodes.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _key = _step2.value;\n\n      _loop(_key);\n    }\n\n    // nodeSize now only considers the size of transformed graph\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  nodeSize = nodeIndexes.size;\n\n  var spectralResult = void 0;\n\n  // If number of nodes in transformed graph is 1 or 2, either SVD or powerIteration causes problem\n  // So skip spectral and layout the graph with cose\n  if (nodeSize > 2) {\n    // if # of nodes in transformed graph is smaller than sample size,\n    // then use # of nodes as sample size\n    sampleSize = nodeSize < options.sampleSize ? nodeSize : options.sampleSize;\n\n    // instantiates the partial matrices that will be used in spectral layout\n    for (var _i14 = 0; _i14 < nodeSize; _i14++) {\n      C[_i14] = [];\n    }\n    for (var _i15 = 0; _i15 < sampleSize; _i15++) {\n      INV[_i15] = [];\n    }\n\n    /**** Apply spectral layout ****/\n\n    if (options.quality == \"draft\" || options.step == \"all\") {\n      allBFS(samplingType);\n      sample();\n      powerIteration();\n\n      spectralResult = { nodeIndexes: nodeIndexes, xCoords: xCoords, yCoords: yCoords };\n    } else {\n      nodeIndexes.forEach(function (value, key) {\n        xCoords.push(cy.getElementById(key).position(\"x\"));\n        yCoords.push(cy.getElementById(key).position(\"y\"));\n      });\n      spectralResult = { nodeIndexes: nodeIndexes, xCoords: xCoords, yCoords: yCoords };\n    }\n    return spectralResult;\n  } else {\n    var iterator = nodeIndexes.keys();\n    var firstNode = cy.getElementById(iterator.next().value);\n    var firstNodePos = firstNode.position();\n    var firstNodeWidth = firstNode.outerWidth();\n    xCoords.push(firstNodePos.x);\n    yCoords.push(firstNodePos.y);\n    if (nodeSize == 2) {\n      var secondNode = cy.getElementById(iterator.next().value);\n      var secondNodeWidth = secondNode.outerWidth();\n      xCoords.push(firstNodePos.x + firstNodeWidth / 2 + secondNodeWidth / 2 + options.idealEdgeLength);\n      yCoords.push(firstNodePos.y);\n    }\n\n    spectralResult = { nodeIndexes: nodeIndexes, xCoords: xCoords, yCoords: yCoords };\n    return spectralResult;\n  }\n};\n\nmodule.exports = { spectralLayout: spectralLayout };\n\n/***/ }),\n\n/***/ 579:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_55337__) => {\n\n\n\nvar impl = __nested_webpack_require_55337__(212);\n\n// registers the extension on a cytoscape lib ref\nvar register = function register(cytoscape) {\n  if (!cytoscape) {\n    return;\n  } // can't register if cytoscape unspecified\n\n  cytoscape('layout', 'fcose', impl); // register with cytoscape.js\n};\n\nif (typeof cytoscape !== 'undefined') {\n  // expose to global cytoscape (i.e. window.cytoscape)\n  register(cytoscape);\n}\n\nmodule.exports = register;\n\n/***/ }),\n\n/***/ 140:\n/***/ ((module) => {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__140__;\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_56127__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_56127__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \tvar __nested_webpack_exports__ = __nested_webpack_require_56127__(579);\n/******/ \t\n/******/ \treturn __nested_webpack_exports__;\n/******/ })()\n;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlLWZjb3NlL2N5dG9zY2FwZS1mY29zZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLElBQUksSUFBeUQ7QUFDN0QsMkJBQTJCLG1CQUFPLENBQUMscUZBQVc7QUFDOUMsTUFBTSxFQUsrQztBQUNyRCxDQUFDO0FBQ0QseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBOztBQUVBO0FBQ0EscUZBQXFGLGFBQWE7QUFDbEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBOztBQUVBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsK0JBQW1COzs7O0FBSTdELG1DQUFtQyxpQ0FBaUMsZUFBZSxlQUFlLGdCQUFnQixvQkFBb0IsTUFBTSwwQ0FBMEMsK0JBQStCLGFBQWEscUJBQXFCLHVDQUF1QyxjQUFjLFdBQVcsWUFBWSxVQUFVLE1BQU0sMkNBQTJDLFVBQVUsc0JBQXNCLGVBQWUsMkJBQTJCLDBCQUEwQixjQUFjLDJDQUEyQyxnQ0FBZ0MsT0FBTyxtRkFBbUY7O0FBRXJwQjtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLCtCQUFtQjs7QUFFcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVAsc0JBQXNCLDBCQUEwQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFF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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMEJBQW1CLEdBQUcsZ0NBQW1CO0FBQ3ZEO0FBQ0EsaUJBQWlCLDBCQUFtQjtBQUNwQyxVQUFVO0FBQ1Y7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViY2xpLWRlbW8vLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlLWZjb3NlL2N5dG9zY2FwZS1mY29zZS5qcz8wZjUzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImNvc2UtYmFzZVwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJjb3NlLWJhc2VcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiY3l0b3NjYXBlRmNvc2VcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJjb3NlLWJhc2VcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImN5dG9zY2FwZUZjb3NlXCJdID0gZmFjdG9yeShyb290W1wiY29zZUJhc2VcIl0pO1xufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fMTQwX18pIHtcbnJldHVybiAvKioqKioqLyAoKCkgPT4geyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdFwidXNlIHN0cmljdFwiO1xuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIDY1ODpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblxuXG4vLyBTaW1wbGUsIGludGVybmFsIE9iamVjdC5hc3NpZ24oKSBwb2x5ZmlsbCBmb3Igb3B0aW9ucyBvYmplY3RzIGV0Yy5cblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuYXNzaWduICE9IG51bGwgPyBPYmplY3QuYXNzaWduLmJpbmQoT2JqZWN0KSA6IGZ1bmN0aW9uICh0Z3QpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNyY3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgc3Jjc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBzcmNzLmZvckVhY2goZnVuY3Rpb24gKHNyYykge1xuICAgIE9iamVjdC5rZXlzKHNyYykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgcmV0dXJuIHRndFtrXSA9IHNyY1trXTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRndDtcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyA1NDg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKTsgfSB9OyB9KCk7XG5cbi8qXG4gKiBBdXhpbGlhcnkgZnVuY3Rpb25zXG4gKi9cblxudmFyIExpbmtlZExpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MCkubGF5b3V0QmFzZS5MaW5rZWRMaXN0O1xuXG52YXIgYXV4aWxpYXJ5ID0ge307XG5cbi8vIGdldCB0aGUgdG9wIG1vc3Qgbm9kZXNcbmF1eGlsaWFyeS5nZXRUb3BNb3N0Tm9kZXMgPSBmdW5jdGlvbiAobm9kZXMpIHtcbiAgdmFyIG5vZGVzTWFwID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBub2Rlc01hcFtub2Rlc1tpXS5pZCgpXSA9IHRydWU7XG4gIH1cbiAgdmFyIHJvb3RzID0gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChlbGUsIGkpIHtcbiAgICBpZiAodHlwZW9mIGVsZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgZWxlID0gaTtcbiAgICB9XG4gICAgdmFyIHBhcmVudCA9IGVsZS5wYXJlbnQoKVswXTtcbiAgICB3aGlsZSAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgIGlmIChub2Rlc01hcFtwYXJlbnQuaWQoKV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudCgpWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJvb3RzO1xufTtcblxuLy8gZmluZCBkaXNjb25uZWN0ZWQgY29tcG9uZW50cyBhbmQgY3JlYXRlIGR1bW15IG5vZGVzIHRoYXQgY29ubmVjdCB0aGVtXG5hdXhpbGlhcnkuY29ubmVjdENvbXBvbmVudHMgPSBmdW5jdGlvbiAoY3ksIGVsZXMsIHRvcE1vc3ROb2RlcywgZHVtbXlOb2Rlcykge1xuICB2YXIgcXVldWUgPSBuZXcgTGlua2VkTGlzdCgpO1xuICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgdmFyIHZpc2l0ZWRUb3BNb3N0Tm9kZXMgPSBbXTtcbiAgdmFyIGN1cnJlbnROZWlnaGJvciA9IHZvaWQgMDtcbiAgdmFyIG1pbkRlZ3JlZU5vZGUgPSB2b2lkIDA7XG4gIHZhciBtaW5EZWdyZWUgPSB2b2lkIDA7XG5cbiAgdmFyIGlzQ29ubmVjdGVkID0gZmFsc2U7XG4gIHZhciBjb3VudCA9IDE7XG4gIHZhciBub2Rlc0Nvbm5lY3RlZFRvRHVtbXkgPSBbXTtcbiAgdmFyIGNvbXBvbmVudHMgPSBbXTtcblxuICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICB2YXIgY21wdCA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICBjb21wb25lbnRzLnB1c2goY21wdCk7XG5cbiAgICB2YXIgY3VycmVudE5vZGUgPSB0b3BNb3N0Tm9kZXNbMF07XG4gICAgdmFyIGNoaWxkcmVuT2ZDdXJyZW50Tm9kZSA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICBjaGlsZHJlbk9mQ3VycmVudE5vZGUubWVyZ2UoY3VycmVudE5vZGUpLm1lcmdlKGN1cnJlbnROb2RlLmRlc2NlbmRhbnRzKCkuaW50ZXJzZWN0aW9uKGVsZXMpKTtcbiAgICB2aXNpdGVkVG9wTW9zdE5vZGVzLnB1c2goY3VycmVudE5vZGUpO1xuXG4gICAgY2hpbGRyZW5PZkN1cnJlbnROb2RlLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHF1ZXVlLnB1c2gobm9kZSk7XG4gICAgICB2aXNpdGVkLmFkZChub2RlKTtcbiAgICAgIGNtcHQubWVyZ2Uobm9kZSk7XG4gICAgfSk7XG5cbiAgICB2YXIgX2xvb3AyID0gZnVuY3Rpb24gX2xvb3AyKCkge1xuICAgICAgY3VycmVudE5vZGUgPSBxdWV1ZS5zaGlmdCgpO1xuXG4gICAgICAvLyBUcmF2ZXJzZSBhbGwgbmVpZ2hib3JzIG9mIHRoaXMgbm9kZVxuICAgICAgdmFyIG5laWdoYm9yTm9kZXMgPSBjeS5jb2xsZWN0aW9uKCk7XG4gICAgICBjdXJyZW50Tm9kZS5uZWlnaGJvcmhvb2QoKS5ub2RlcygpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKGVsZXMuaW50ZXJzZWN0aW9uKGN1cnJlbnROb2RlLmVkZ2VzV2l0aChub2RlKSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG5laWdoYm9yTm9kZXMubWVyZ2Uobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5laWdoYm9yTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5laWdoYm9yTm9kZSA9IG5laWdoYm9yTm9kZXNbaV07XG4gICAgICAgIGN1cnJlbnROZWlnaGJvciA9IHRvcE1vc3ROb2Rlcy5pbnRlcnNlY3Rpb24obmVpZ2hib3JOb2RlLnVuaW9uKG5laWdoYm9yTm9kZS5hbmNlc3RvcnMoKSkpO1xuICAgICAgICBpZiAoY3VycmVudE5laWdoYm9yICE9IG51bGwgJiYgIXZpc2l0ZWQuaGFzKGN1cnJlbnROZWlnaGJvclswXSkpIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW5PZk5laWdoYm9yID0gY3VycmVudE5laWdoYm9yLnVuaW9uKGN1cnJlbnROZWlnaGJvci5kZXNjZW5kYW50cygpKTtcblxuICAgICAgICAgIGNoaWxkcmVuT2ZOZWlnaGJvci5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgdmlzaXRlZC5hZGQobm9kZSk7XG4gICAgICAgICAgICBjbXB0Lm1lcmdlKG5vZGUpO1xuICAgICAgICAgICAgaWYgKHRvcE1vc3ROb2Rlcy5oYXMobm9kZSkpIHtcbiAgICAgICAgICAgICAgdmlzaXRlZFRvcE1vc3ROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggIT0gMCkge1xuICAgICAgX2xvb3AyKCk7XG4gICAgfVxuXG4gICAgY21wdC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBlbGVzLmludGVyc2VjdGlvbihub2RlLmNvbm5lY3RlZEVkZ2VzKCkpLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgLy8gY29ubmVjdGVkRWRnZXMoKSB1c3VhbGx5IGNhY2hlZFxuICAgICAgICBpZiAoY21wdC5oYXMoZS5zb3VyY2UoKSkgJiYgY21wdC5oYXMoZS50YXJnZXQoKSkpIHtcbiAgICAgICAgICAvLyBoYXMoKSBpcyBjaGVhcFxuICAgICAgICAgIGNtcHQubWVyZ2UoZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaWYgKHZpc2l0ZWRUb3BNb3N0Tm9kZXMubGVuZ3RoID09IHRvcE1vc3ROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIGlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIWlzQ29ubmVjdGVkIHx8IGlzQ29ubmVjdGVkICYmIGNvdW50ID4gMSkge1xuICAgICAgbWluRGVncmVlTm9kZSA9IHZpc2l0ZWRUb3BNb3N0Tm9kZXNbMF07XG4gICAgICBtaW5EZWdyZWUgPSBtaW5EZWdyZWVOb2RlLmNvbm5lY3RlZEVkZ2VzKCkubGVuZ3RoO1xuICAgICAgdmlzaXRlZFRvcE1vc3ROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLmNvbm5lY3RlZEVkZ2VzKCkubGVuZ3RoIDwgbWluRGVncmVlKSB7XG4gICAgICAgICAgbWluRGVncmVlID0gbm9kZS5jb25uZWN0ZWRFZGdlcygpLmxlbmd0aDtcbiAgICAgICAgICBtaW5EZWdyZWVOb2RlID0gbm9kZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBub2Rlc0Nvbm5lY3RlZFRvRHVtbXkucHVzaChtaW5EZWdyZWVOb2RlLmlkKCkpO1xuICAgICAgLy8gVE8gRE86IENoZWNrIGVmZmljaWVuY3kgb2YgdGhpcyBwYXJ0XG4gICAgICB2YXIgdGVtcCA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgIHRlbXAubWVyZ2UodmlzaXRlZFRvcE1vc3ROb2Rlc1swXSk7XG4gICAgICB2aXNpdGVkVG9wTW9zdE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdGVtcC5tZXJnZShub2RlKTtcbiAgICAgIH0pO1xuICAgICAgdmlzaXRlZFRvcE1vc3ROb2RlcyA9IFtdO1xuICAgICAgdG9wTW9zdE5vZGVzID0gdG9wTW9zdE5vZGVzLmRpZmZlcmVuY2UodGVtcCk7XG4gICAgICBjb3VudCsrO1xuICAgIH1cbiAgfTtcblxuICBkbyB7XG4gICAgX2xvb3AoKTtcbiAgfSB3aGlsZSAoIWlzQ29ubmVjdGVkKTtcblxuICBpZiAoZHVtbXlOb2Rlcykge1xuICAgIGlmIChub2Rlc0Nvbm5lY3RlZFRvRHVtbXkubGVuZ3RoID4gMCkge1xuICAgICAgZHVtbXlOb2Rlcy5zZXQoJ2R1bW15JyArIChkdW1teU5vZGVzLnNpemUgKyAxKSwgbm9kZXNDb25uZWN0ZWRUb0R1bW15KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbXBvbmVudHM7XG59O1xuXG4vLyByZWxvY2F0ZXMgY29tcG9uZW50UmVzdWx0IHRvIG9yaWdpbmFsQ2VudGVyIGlmIHRoZXJlIGlzIG5vIGZpeGVkTm9kZUNvbnN0cmFpbnRcbmF1eGlsaWFyeS5yZWxvY2F0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uIChvcmlnaW5hbENlbnRlciwgY29tcG9uZW50UmVzdWx0LCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucy5maXhlZE5vZGVDb25zdHJhaW50KSB7XG4gICAgdmFyIG1pblhDb29yZCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB2YXIgbWF4WENvb3JkID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIHZhciBtaW5ZQ29vcmQgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgdmFyIG1heFlDb29yZCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICBpZiAob3B0aW9ucy5xdWFsaXR5ID09IFwiZHJhZnRcIikge1xuICAgICAgLy8gY2FsY3VsYXRlIGN1cnJlbnQgYm91bmRpbmcgYm94XG4gICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gY29tcG9uZW50UmVzdWx0Lm5vZGVJbmRleGVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBfcmVmID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICB2YXIgX3JlZjIgPSBfc2xpY2VkVG9BcnJheShfcmVmLCAyKTtcblxuICAgICAgICAgIHZhciBrZXkgPSBfcmVmMlswXTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBfcmVmMlsxXTtcblxuICAgICAgICAgIHZhciBjeU5vZGUgPSBvcHRpb25zLmN5LmdldEVsZW1lbnRCeUlkKGtleSk7XG4gICAgICAgICAgaWYgKGN5Tm9kZSkge1xuICAgICAgICAgICAgdmFyIG5vZGVCQiA9IGN5Tm9kZS5ib3VuZGluZ0JveCgpO1xuICAgICAgICAgICAgdmFyIGxlZnRYID0gY29tcG9uZW50UmVzdWx0LnhDb29yZHNbdmFsdWVdIC0gbm9kZUJCLncgLyAyO1xuICAgICAgICAgICAgdmFyIHJpZ2h0WCA9IGNvbXBvbmVudFJlc3VsdC54Q29vcmRzW3ZhbHVlXSArIG5vZGVCQi53IC8gMjtcbiAgICAgICAgICAgIHZhciB0b3BZID0gY29tcG9uZW50UmVzdWx0LnlDb29yZHNbdmFsdWVdIC0gbm9kZUJCLmggLyAyO1xuICAgICAgICAgICAgdmFyIGJvdHRvbVkgPSBjb21wb25lbnRSZXN1bHQueUNvb3Jkc1t2YWx1ZV0gKyBub2RlQkIuaCAvIDI7XG5cbiAgICAgICAgICAgIGlmIChsZWZ0WCA8IG1pblhDb29yZCkgbWluWENvb3JkID0gbGVmdFg7XG4gICAgICAgICAgICBpZiAocmlnaHRYID4gbWF4WENvb3JkKSBtYXhYQ29vcmQgPSByaWdodFg7XG4gICAgICAgICAgICBpZiAodG9wWSA8IG1pbllDb29yZCkgbWluWUNvb3JkID0gdG9wWTtcbiAgICAgICAgICAgIGlmIChib3R0b21ZID4gbWF4WUNvb3JkKSBtYXhZQ29vcmQgPSBib3R0b21ZO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBmaW5kIGRpZmZlcmVuY2UgYmV0d2VlbiBjdXJyZW50IGFuZCBvcmlnaW5hbCBjZW50ZXJcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZGlmZk9uWCA9IG9yaWdpbmFsQ2VudGVyLnggLSAobWF4WENvb3JkICsgbWluWENvb3JkKSAvIDI7XG4gICAgICB2YXIgZGlmZk9uWSA9IG9yaWdpbmFsQ2VudGVyLnkgLSAobWF4WUNvb3JkICsgbWluWUNvb3JkKSAvIDI7XG4gICAgICAvLyBtb3ZlIGNvbXBvbmVudCB0byBvcmlnaW5hbCBjZW50ZXJcbiAgICAgIGNvbXBvbmVudFJlc3VsdC54Q29vcmRzID0gY29tcG9uZW50UmVzdWx0LnhDb29yZHMubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB4ICsgZGlmZk9uWDtcbiAgICAgIH0pO1xuICAgICAgY29tcG9uZW50UmVzdWx0LnlDb29yZHMgPSBjb21wb25lbnRSZXN1bHQueUNvb3Jkcy5tYXAoZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgcmV0dXJuIHkgKyBkaWZmT25ZO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNhbGN1bGF0ZSBjdXJyZW50IGJvdW5kaW5nIGJveFxuICAgICAgT2JqZWN0LmtleXMoY29tcG9uZW50UmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBub2RlID0gY29tcG9uZW50UmVzdWx0W2l0ZW1dO1xuICAgICAgICB2YXIgbGVmdFggPSBub2RlLmdldFJlY3QoKS54O1xuICAgICAgICB2YXIgcmlnaHRYID0gbm9kZS5nZXRSZWN0KCkueCArIG5vZGUuZ2V0UmVjdCgpLndpZHRoO1xuICAgICAgICB2YXIgdG9wWSA9IG5vZGUuZ2V0UmVjdCgpLnk7XG4gICAgICAgIHZhciBib3R0b21ZID0gbm9kZS5nZXRSZWN0KCkueSArIG5vZGUuZ2V0UmVjdCgpLmhlaWdodDtcblxuICAgICAgICBpZiAobGVmdFggPCBtaW5YQ29vcmQpIG1pblhDb29yZCA9IGxlZnRYO1xuICAgICAgICBpZiAocmlnaHRYID4gbWF4WENvb3JkKSBtYXhYQ29vcmQgPSByaWdodFg7XG4gICAgICAgIGlmICh0b3BZIDwgbWluWUNvb3JkKSBtaW5ZQ29vcmQgPSB0b3BZO1xuICAgICAgICBpZiAoYm90dG9tWSA+IG1heFlDb29yZCkgbWF4WUNvb3JkID0gYm90dG9tWTtcbiAgICAgIH0pO1xuICAgICAgLy8gZmluZCBkaWZmZXJlbmNlIGJldHdlZW4gY3VycmVudCBhbmQgb3JpZ2luYWwgY2VudGVyXG4gICAgICB2YXIgX2RpZmZPblggPSBvcmlnaW5hbENlbnRlci54IC0gKG1heFhDb29yZCArIG1pblhDb29yZCkgLyAyO1xuICAgICAgdmFyIF9kaWZmT25ZID0gb3JpZ2luYWxDZW50ZXIueSAtIChtYXhZQ29vcmQgKyBtaW5ZQ29vcmQpIC8gMjtcbiAgICAgIC8vIG1vdmUgY29tcG9uZW50IHRvIG9yaWdpbmFsIGNlbnRlclxuICAgICAgT2JqZWN0LmtleXMoY29tcG9uZW50UmVzdWx0KS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciBub2RlID0gY29tcG9uZW50UmVzdWx0W2l0ZW1dO1xuICAgICAgICBub2RlLnNldENlbnRlcihub2RlLmdldENlbnRlclgoKSArIF9kaWZmT25YLCBub2RlLmdldENlbnRlclkoKSArIF9kaWZmT25ZKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufTtcblxuYXV4aWxpYXJ5LmNhbGNCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIChwYXJlbnROb2RlLCB4Q29vcmRzLCB5Q29vcmRzLCBub2RlSW5kZXhlcykge1xuICAvLyBjYWxjdWxhdGUgYm91bmRzXG4gIHZhciBsZWZ0ID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gIHZhciByaWdodCA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICB2YXIgdG9wID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gIHZhciBib3R0b20gPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcbiAgdmFyIG5vZGVMZWZ0ID0gdm9pZCAwO1xuICB2YXIgbm9kZVJpZ2h0ID0gdm9pZCAwO1xuICB2YXIgbm9kZVRvcCA9IHZvaWQgMDtcbiAgdmFyIG5vZGVCb3R0b20gPSB2b2lkIDA7XG5cbiAgdmFyIG5vZGVzID0gcGFyZW50Tm9kZS5kZXNjZW5kYW50cygpLm5vdChcIjpwYXJlbnRcIik7XG4gIHZhciBzID0gbm9kZXMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIHZhciBub2RlID0gbm9kZXNbaV07XG5cbiAgICBub2RlTGVmdCA9IHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGUuaWQoKSldIC0gbm9kZS53aWR0aCgpIC8gMjtcbiAgICBub2RlUmlnaHQgPSB4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlLmlkKCkpXSArIG5vZGUud2lkdGgoKSAvIDI7XG4gICAgbm9kZVRvcCA9IHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGUuaWQoKSldIC0gbm9kZS5oZWlnaHQoKSAvIDI7XG4gICAgbm9kZUJvdHRvbSA9IHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGUuaWQoKSldICsgbm9kZS5oZWlnaHQoKSAvIDI7XG5cbiAgICBpZiAobGVmdCA+IG5vZGVMZWZ0KSB7XG4gICAgICBsZWZ0ID0gbm9kZUxlZnQ7XG4gICAgfVxuXG4gICAgaWYgKHJpZ2h0IDwgbm9kZVJpZ2h0KSB7XG4gICAgICByaWdodCA9IG5vZGVSaWdodDtcbiAgICB9XG5cbiAgICBpZiAodG9wID4gbm9kZVRvcCkge1xuICAgICAgdG9wID0gbm9kZVRvcDtcbiAgICB9XG5cbiAgICBpZiAoYm90dG9tIDwgbm9kZUJvdHRvbSkge1xuICAgICAgYm90dG9tID0gbm9kZUJvdHRvbTtcbiAgICB9XG4gIH1cblxuICB2YXIgYm91bmRpbmdCb3ggPSB7fTtcbiAgYm91bmRpbmdCb3gudG9wTGVmdFggPSBsZWZ0O1xuICBib3VuZGluZ0JveC50b3BMZWZ0WSA9IHRvcDtcbiAgYm91bmRpbmdCb3gud2lkdGggPSByaWdodCAtIGxlZnQ7XG4gIGJvdW5kaW5nQm94LmhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgcmV0dXJuIGJvdW5kaW5nQm94O1xufTtcblxuLy8gVGhpcyBmdW5jdGlvbiBmaW5kcyBhbmQgcmV0dXJucyBwYXJlbnQgbm9kZXMgd2hvc2UgYWxsIGNoaWxkcmVuIGFyZSBoaWRkZW5cbmF1eGlsaWFyeS5jYWxjUGFyZW50c1dpdGhvdXRDaGlsZHJlbiA9IGZ1bmN0aW9uIChjeSwgZWxlcykge1xuICB2YXIgcGFyZW50c1dpdGhvdXRDaGlsZHJlbiA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgZWxlcy5ub2RlcygnOnBhcmVudCcpLmZvckVhY2goZnVuY3Rpb24gKHBhcmVudCkge1xuICAgIHZhciBjaGVjayA9IGZhbHNlO1xuICAgIHBhcmVudC5jaGlsZHJlbigpLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQuY3NzKCdkaXNwbGF5JykgIT0gJ25vbmUnKSB7XG4gICAgICAgIGNoZWNrID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIWNoZWNrKSB7XG4gICAgICBwYXJlbnRzV2l0aG91dENoaWxkcmVuLm1lcmdlKHBhcmVudCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyZW50c1dpdGhvdXRDaGlsZHJlbjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYXV4aWxpYXJ5O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gODE2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuLyoqXG4gIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgcG9zdHByb2Nlc3NpbmcgcGFydCB0aGF0IGFwcGxpZXMgQ29TRSBsYXlvdXQgb3ZlciB0aGUgc3BlY3RyYWwgbGF5b3V0XG4qL1xuXG52YXIgYXV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NDgpO1xudmFyIENvU0VMYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MCkuQ29TRUxheW91dDtcbnZhciBDb1NFTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKS5Db1NFTm9kZTtcbnZhciBQb2ludEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MCkubGF5b3V0QmFzZS5Qb2ludEQ7XG52YXIgRGltZW5zaW9uRCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKS5sYXlvdXRCYXNlLkRpbWVuc2lvbkQ7XG52YXIgTGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDApLmxheW91dEJhc2UuTGF5b3V0Q29uc3RhbnRzO1xudmFyIEZETGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDApLmxheW91dEJhc2UuRkRMYXlvdXRDb25zdGFudHM7XG52YXIgQ29TRUNvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKS5Db1NFQ29uc3RhbnRzO1xuXG4vLyBtYWluIGZ1bmN0aW9uIHRoYXQgY29zZSBsYXlvdXQgaXMgcHJvY2Vzc2VkXG52YXIgY29zZUxheW91dCA9IGZ1bmN0aW9uIGNvc2VMYXlvdXQob3B0aW9ucywgc3BlY3RyYWxSZXN1bHQpIHtcblxuICB2YXIgY3kgPSBvcHRpb25zLmN5O1xuICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpO1xuICB2YXIgZWRnZXMgPSBlbGVzLmVkZ2VzKCk7XG5cbiAgdmFyIG5vZGVJbmRleGVzID0gdm9pZCAwO1xuICB2YXIgeENvb3JkcyA9IHZvaWQgMDtcbiAgdmFyIHlDb29yZHMgPSB2b2lkIDA7XG4gIHZhciBpZFRvTE5vZGUgPSB7fTtcblxuICBpZiAob3B0aW9ucy5yYW5kb21pemUpIHtcbiAgICBub2RlSW5kZXhlcyA9IHNwZWN0cmFsUmVzdWx0W1wibm9kZUluZGV4ZXNcIl07XG4gICAgeENvb3JkcyA9IHNwZWN0cmFsUmVzdWx0W1wieENvb3Jkc1wiXTtcbiAgICB5Q29vcmRzID0gc3BlY3RyYWxSZXN1bHRbXCJ5Q29vcmRzXCJdO1xuICB9XG5cbiAgdmFyIGlzRm4gPSBmdW5jdGlvbiBpc0ZuKGZuKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJztcbiAgfTtcblxuICB2YXIgb3B0Rm4gPSBmdW5jdGlvbiBvcHRGbihvcHQsIGVsZSkge1xuICAgIGlmIChpc0ZuKG9wdCkpIHtcbiAgICAgIHJldHVybiBvcHQoZWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9wdDtcbiAgICB9XG4gIH07XG5cbiAgLyoqKiogUG9zdHByb2Nlc3NpbmcgZnVuY3Rpb25zICoqKiovXG5cbiAgdmFyIHBhcmVudHNXaXRob3V0Q2hpbGRyZW4gPSBhdXguY2FsY1BhcmVudHNXaXRob3V0Q2hpbGRyZW4oY3ksIGVsZXMpO1xuXG4gIC8vIHRyYW5zZmVyIGN5dG9zY2FwZSBub2RlcyB0byBjb3NlIG5vZGVzXG4gIHZhciBwcm9jZXNzQ2hpbGRyZW5MaXN0ID0gZnVuY3Rpb24gcHJvY2Vzc0NoaWxkcmVuTGlzdChwYXJlbnQsIGNoaWxkcmVuLCBsYXlvdXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgc2l6ZSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgdmFyIHRoZUNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICB2YXIgY2hpbGRyZW5fb2ZfY2hpbGRyZW4gPSBudWxsO1xuICAgICAgaWYgKHRoZUNoaWxkLmludGVyc2VjdGlvbihwYXJlbnRzV2l0aG91dENoaWxkcmVuKS5sZW5ndGggPT0gMCkge1xuICAgICAgICBjaGlsZHJlbl9vZl9jaGlsZHJlbiA9IHRoZUNoaWxkLmNoaWxkcmVuKCk7XG4gICAgICB9XG4gICAgICB2YXIgdGhlTm9kZSA9IHZvaWQgMDtcblxuICAgICAgdmFyIGRpbWVuc2lvbnMgPSB0aGVDaGlsZC5sYXlvdXREaW1lbnNpb25zKHtcbiAgICAgICAgbm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzOiBvcHRpb25zLm5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsc1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGVDaGlsZC5vdXRlcldpZHRoKCkgIT0gbnVsbCAmJiB0aGVDaGlsZC5vdXRlckhlaWdodCgpICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucmFuZG9taXplKSB7XG4gICAgICAgICAgaWYgKCF0aGVDaGlsZC5pc1BhcmVudCgpKSB7XG4gICAgICAgICAgICB0aGVOb2RlID0gcGFyZW50LmFkZChuZXcgQ29TRU5vZGUobGF5b3V0LmdyYXBoTWFuYWdlciwgbmV3IFBvaW50RCh4Q29vcmRzW25vZGVJbmRleGVzLmdldCh0aGVDaGlsZC5pZCgpKV0gLSBkaW1lbnNpb25zLncgLyAyLCB5Q29vcmRzW25vZGVJbmRleGVzLmdldCh0aGVDaGlsZC5pZCgpKV0gLSBkaW1lbnNpb25zLmggLyAyKSwgbmV3IERpbWVuc2lvbkQocGFyc2VGbG9hdChkaW1lbnNpb25zLncpLCBwYXJzZUZsb2F0KGRpbWVuc2lvbnMuaCkpKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRJbmZvID0gYXV4LmNhbGNCb3VuZGluZ0JveCh0aGVDaGlsZCwgeENvb3JkcywgeUNvb3Jkcywgbm9kZUluZGV4ZXMpO1xuICAgICAgICAgICAgaWYgKHRoZUNoaWxkLmludGVyc2VjdGlvbihwYXJlbnRzV2l0aG91dENoaWxkcmVuKS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICB0aGVOb2RlID0gcGFyZW50LmFkZChuZXcgQ29TRU5vZGUobGF5b3V0LmdyYXBoTWFuYWdlciwgbmV3IFBvaW50RChwYXJlbnRJbmZvLnRvcExlZnRYLCBwYXJlbnRJbmZvLnRvcExlZnRZKSwgbmV3IERpbWVuc2lvbkQocGFyZW50SW5mby53aWR0aCwgcGFyZW50SW5mby5oZWlnaHQpKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBmb3IgdGhlIHBhcmVudHNXaXRob3V0Q2hpbGRyZW5cbiAgICAgICAgICAgICAgdGhlTm9kZSA9IHBhcmVudC5hZGQobmV3IENvU0VOb2RlKGxheW91dC5ncmFwaE1hbmFnZXIsIG5ldyBQb2ludEQocGFyZW50SW5mby50b3BMZWZ0WCwgcGFyZW50SW5mby50b3BMZWZ0WSksIG5ldyBEaW1lbnNpb25EKHBhcnNlRmxvYXQoZGltZW5zaW9ucy53KSwgcGFyc2VGbG9hdChkaW1lbnNpb25zLmgpKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGVOb2RlID0gcGFyZW50LmFkZChuZXcgQ29TRU5vZGUobGF5b3V0LmdyYXBoTWFuYWdlciwgbmV3IFBvaW50RCh0aGVDaGlsZC5wb3NpdGlvbigneCcpIC0gZGltZW5zaW9ucy53IC8gMiwgdGhlQ2hpbGQucG9zaXRpb24oJ3knKSAtIGRpbWVuc2lvbnMuaCAvIDIpLCBuZXcgRGltZW5zaW9uRChwYXJzZUZsb2F0KGRpbWVuc2lvbnMudyksIHBhcnNlRmxvYXQoZGltZW5zaW9ucy5oKSkpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhlTm9kZSA9IHBhcmVudC5hZGQobmV3IENvU0VOb2RlKHRoaXMuZ3JhcGhNYW5hZ2VyKSk7XG4gICAgICB9XG4gICAgICAvLyBBdHRhY2ggaWQgdG8gdGhlIGxheW91dCBub2RlIGFuZCByZXB1bHNpb24gdmFsdWVcbiAgICAgIHRoZU5vZGUuaWQgPSB0aGVDaGlsZC5kYXRhKFwiaWRcIik7XG4gICAgICB0aGVOb2RlLm5vZGVSZXB1bHNpb24gPSBvcHRGbihvcHRpb25zLm5vZGVSZXB1bHNpb24sIHRoZUNoaWxkKTtcbiAgICAgIC8vIEF0dGFjaCB0aGUgcGFkZGluZ3Mgb2YgY3kgbm9kZSB0byBsYXlvdXQgbm9kZVxuICAgICAgdGhlTm9kZS5wYWRkaW5nTGVmdCA9IHBhcnNlSW50KHRoZUNoaWxkLmNzcygncGFkZGluZycpKTtcbiAgICAgIHRoZU5vZGUucGFkZGluZ1RvcCA9IHBhcnNlSW50KHRoZUNoaWxkLmNzcygncGFkZGluZycpKTtcbiAgICAgIHRoZU5vZGUucGFkZGluZ1JpZ2h0ID0gcGFyc2VJbnQodGhlQ2hpbGQuY3NzKCdwYWRkaW5nJykpO1xuICAgICAgdGhlTm9kZS5wYWRkaW5nQm90dG9tID0gcGFyc2VJbnQodGhlQ2hpbGQuY3NzKCdwYWRkaW5nJykpO1xuXG4gICAgICAvL0F0dGFjaCB0aGUgbGFiZWwgcHJvcGVydGllcyB0byBib3RoIGNvbXBvdW5kIGFuZCBzaW1wbGUgbm9kZXMgaWYgbGFiZWxzIHdpbGwgYmUgaW5jbHVkZWQgaW4gbm9kZSBkaW1lbnNpb25zXG4gICAgICAvL1RoZXNlIHByb3BlcnRpZXMgd2lsbCBiZSB1c2VkIHdoaWxlIHVwZGF0aW5nIGJvdW5kcyBvZiBjb21wb3VuZHMgZHVyaW5nIGl0ZXJhdGlvbnMgb3IgdGlsaW5nXG4gICAgICAvL2FuZCB3aWxsIGJlIHVzZWQgZm9yIHNpbXBsZSBub2RlcyB3aGlsZSB0cmFuc2ZlcnJpbmcgZmluYWwgcG9zaXRpb25zIHRvIGN5dG9zY2FwZVxuICAgICAgaWYgKG9wdGlvbnMubm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzKSB7XG4gICAgICAgIHRoZU5vZGUubGFiZWxXaWR0aCA9IHRoZUNoaWxkLmJvdW5kaW5nQm94KHsgaW5jbHVkZUxhYmVsczogdHJ1ZSwgaW5jbHVkZU5vZGVzOiBmYWxzZSwgaW5jbHVkZU92ZXJsYXlzOiBmYWxzZSB9KS53O1xuICAgICAgICB0aGVOb2RlLmxhYmVsSGVpZ2h0ID0gdGhlQ2hpbGQuYm91bmRpbmdCb3goeyBpbmNsdWRlTGFiZWxzOiB0cnVlLCBpbmNsdWRlTm9kZXM6IGZhbHNlLCBpbmNsdWRlT3ZlcmxheXM6IGZhbHNlIH0pLmg7XG4gICAgICAgIHRoZU5vZGUubGFiZWxQb3NWZXJ0aWNhbCA9IHRoZUNoaWxkLmNzcyhcInRleHQtdmFsaWduXCIpO1xuICAgICAgICB0aGVOb2RlLmxhYmVsUG9zSG9yaXpvbnRhbCA9IHRoZUNoaWxkLmNzcyhcInRleHQtaGFsaWduXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBNYXAgdGhlIGxheW91dCBub2RlXG4gICAgICBpZFRvTE5vZGVbdGhlQ2hpbGQuZGF0YShcImlkXCIpXSA9IHRoZU5vZGU7XG5cbiAgICAgIGlmIChpc05hTih0aGVOb2RlLnJlY3QueCkpIHtcbiAgICAgICAgdGhlTm9kZS5yZWN0LnggPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNOYU4odGhlTm9kZS5yZWN0LnkpKSB7XG4gICAgICAgIHRoZU5vZGUucmVjdC55ID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGNoaWxkcmVuX29mX2NoaWxkcmVuICE9IG51bGwgJiYgY2hpbGRyZW5fb2ZfY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgdGhlTmV3R3JhcGggPSB2b2lkIDA7XG4gICAgICAgIHRoZU5ld0dyYXBoID0gbGF5b3V0LmdldEdyYXBoTWFuYWdlcigpLmFkZChsYXlvdXQubmV3R3JhcGgoKSwgdGhlTm9kZSk7XG4gICAgICAgIHByb2Nlc3NDaGlsZHJlbkxpc3QodGhlTmV3R3JhcGgsIGNoaWxkcmVuX29mX2NoaWxkcmVuLCBsYXlvdXQsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyB0cmFuc2ZlciBjeXRvc2NhcGUgZWRnZXMgdG8gY29zZSBlZGdlc1xuICB2YXIgcHJvY2Vzc0VkZ2VzID0gZnVuY3Rpb24gcHJvY2Vzc0VkZ2VzKGxheW91dCwgZ20sIGVkZ2VzKSB7XG4gICAgdmFyIGlkZWFsTGVuZ3RoVG90YWwgPSAwO1xuICAgIHZhciBlZGdlQ291bnQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgICB2YXIgc291cmNlTm9kZSA9IGlkVG9MTm9kZVtlZGdlLmRhdGEoXCJzb3VyY2VcIildO1xuICAgICAgdmFyIHRhcmdldE5vZGUgPSBpZFRvTE5vZGVbZWRnZS5kYXRhKFwidGFyZ2V0XCIpXTtcbiAgICAgIGlmIChzb3VyY2VOb2RlICYmIHRhcmdldE5vZGUgJiYgc291cmNlTm9kZSAhPT0gdGFyZ2V0Tm9kZSAmJiBzb3VyY2VOb2RlLmdldEVkZ2VzQmV0d2Vlbih0YXJnZXROb2RlKS5sZW5ndGggPT0gMCkge1xuICAgICAgICB2YXIgZTEgPSBnbS5hZGQobGF5b3V0Lm5ld0VkZ2UoKSwgc291cmNlTm9kZSwgdGFyZ2V0Tm9kZSk7XG4gICAgICAgIGUxLmlkID0gZWRnZS5pZCgpO1xuICAgICAgICBlMS5pZGVhbExlbmd0aCA9IG9wdEZuKG9wdGlvbnMuaWRlYWxFZGdlTGVuZ3RoLCBlZGdlKTtcbiAgICAgICAgZTEuZWRnZUVsYXN0aWNpdHkgPSBvcHRGbihvcHRpb25zLmVkZ2VFbGFzdGljaXR5LCBlZGdlKTtcbiAgICAgICAgaWRlYWxMZW5ndGhUb3RhbCArPSBlMS5pZGVhbExlbmd0aDtcbiAgICAgICAgZWRnZUNvdW50Kys7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBpZGVhbCBlZGdlIGxlbmd0aCBjb25zdGFudCB3aXRoIHRoZSBhdmcuIGlkZWFsIGxlbmd0aCB2YWx1ZSBhZnRlciBwcm9jZXNzaW5nIGVkZ2VzXG4gICAgLy8gaW4gY2FzZSB0aGVyZSBpcyBubyBlZGdlLCB1c2Ugb3RoZXIgb3B0aW9uc1xuICAgIGlmIChvcHRpb25zLmlkZWFsRWRnZUxlbmd0aCAhPSBudWxsKSB7XG4gICAgICBpZiAoZWRnZUNvdW50ID4gMCkgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCA9IGlkZWFsTGVuZ3RoVG90YWwgLyBlZGdlQ291bnQ7ZWxzZSBpZiAoIWlzRm4ob3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGgpKSAvLyBpbiBjYXNlIHRoZXJlIGlzIG5vIGVkZ2UsIGJ1dCBvcHRpb24gZ2l2ZXMgYSB2YWx1ZSB0byB1c2VcbiAgICAgICAgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCA9IG9wdGlvbnMuaWRlYWxFZGdlTGVuZ3RoO2Vsc2UgLy8gaW4gY2FzZSB0aGVyZSBpcyBubyBlZGdlIGFuZCB3ZSBjYW5ub3QgZ2V0IGEgdmFsdWUgZnJvbSBvcHRpb24gKGJlY2F1c2UgaXQncyBhIGZ1bmN0aW9uKVxuICAgICAgICBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIID0gNTA7XG4gICAgICAvLyB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGVzZSBjb25zdGFudCB2YWx1ZXMgYmFzZWQgb24gdGhlIGlkZWFsIGVkZ2UgbGVuZ3RoIGNvbnN0YW50XG4gICAgICBDb1NFQ29uc3RhbnRzLk1JTl9SRVBVTFNJT05fRElTVCA9IEZETGF5b3V0Q29uc3RhbnRzLk1JTl9SRVBVTFNJT05fRElTVCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggLyAxMC4wO1xuICAgICAgQ29TRUNvbnN0YW50cy5ERUZBVUxUX1JBRElBTF9TRVBBUkFUSU9OID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSDtcbiAgICB9XG4gIH07XG5cbiAgLy8gdHJhbnNmZXIgY3l0b3NjYXBlIGNvbnN0cmFpbnRzIHRvIGNvc2UgbGF5b3V0XG4gIHZhciBwcm9jZXNzQ29uc3RyYWludHMgPSBmdW5jdGlvbiBwcm9jZXNzQ29uc3RyYWludHMobGF5b3V0LCBvcHRpb25zKSB7XG4gICAgLy8gZ2V0IG5vZGVzIHRvIGJlIGZpeGVkXG4gICAgaWYgKG9wdGlvbnMuZml4ZWROb2RlQ29uc3RyYWludCkge1xuICAgICAgbGF5b3V0LmNvbnN0cmFpbnRzW1wiZml4ZWROb2RlQ29uc3RyYWludFwiXSA9IG9wdGlvbnMuZml4ZWROb2RlQ29uc3RyYWludDtcbiAgICB9XG4gICAgLy8gZ2V0IG5vZGVzIHRvIGJlIGFsaWduZWRcbiAgICBpZiAob3B0aW9ucy5hbGlnbm1lbnRDb25zdHJhaW50KSB7XG4gICAgICBsYXlvdXQuY29uc3RyYWludHNbXCJhbGlnbm1lbnRDb25zdHJhaW50XCJdID0gb3B0aW9ucy5hbGlnbm1lbnRDb25zdHJhaW50O1xuICAgIH1cbiAgICAvLyBnZXQgbm9kZXMgdG8gYmUgcmVsYXRpdmVseSBwbGFjZWRcbiAgICBpZiAob3B0aW9ucy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQpIHtcbiAgICAgIGxheW91dC5jb25zdHJhaW50c1tcInJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludFwiXSA9IG9wdGlvbnMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50O1xuICAgIH1cbiAgfTtcblxuICAvKioqKiBBcHBseSBwb3N0cHJvY2Vzc2luZyAqKioqL1xuICBpZiAob3B0aW9ucy5uZXN0aW5nRmFjdG9yICE9IG51bGwpIENvU0VDb25zdGFudHMuUEVSX0xFVkVMX0lERUFMX0VER0VfTEVOR1RIX0ZBQ1RPUiA9IEZETGF5b3V0Q29uc3RhbnRzLlBFUl9MRVZFTF9JREVBTF9FREdFX0xFTkdUSF9GQUNUT1IgPSBvcHRpb25zLm5lc3RpbmdGYWN0b3I7XG4gIGlmIChvcHRpb25zLmdyYXZpdHkgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfU1RSRU5HVEggPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfU1RSRU5HVEggPSBvcHRpb25zLmdyYXZpdHk7XG4gIGlmIChvcHRpb25zLm51bUl0ZXIgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5NQVhfSVRFUkFUSU9OUyA9IEZETGF5b3V0Q29uc3RhbnRzLk1BWF9JVEVSQVRJT05TID0gb3B0aW9ucy5udW1JdGVyO1xuICBpZiAob3B0aW9ucy5ncmF2aXR5UmFuZ2UgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfUkFOR0VfRkFDVE9SID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUiA9IG9wdGlvbnMuZ3Jhdml0eVJhbmdlO1xuICBpZiAob3B0aW9ucy5ncmF2aXR5Q29tcG91bmQgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfU1RSRU5HVEggPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfU1RSRU5HVEggPSBvcHRpb25zLmdyYXZpdHlDb21wb3VuZDtcbiAgaWYgKG9wdGlvbnMuZ3Jhdml0eVJhbmdlQ29tcG91bmQgIT0gbnVsbCkgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfUkFOR0VfRkFDVE9SID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUiA9IG9wdGlvbnMuZ3Jhdml0eVJhbmdlQ29tcG91bmQ7XG4gIGlmIChvcHRpb25zLmluaXRpYWxFbmVyZ3lPbkluY3JlbWVudGFsICE9IG51bGwpIENvU0VDb25zdGFudHMuREVGQVVMVF9DT09MSU5HX0ZBQ1RPUl9JTkNSRU1FTlRBTCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09PTElOR19GQUNUT1JfSU5DUkVNRU5UQUwgPSBvcHRpb25zLmluaXRpYWxFbmVyZ3lPbkluY3JlbWVudGFsO1xuXG4gIGlmIChvcHRpb25zLnRpbGluZ0NvbXBhcmVCeSAhPSBudWxsKSBDb1NFQ29uc3RhbnRzLlRJTElOR19DT01QQVJFX0JZID0gb3B0aW9ucy50aWxpbmdDb21wYXJlQnk7XG5cbiAgaWYgKG9wdGlvbnMucXVhbGl0eSA9PSAncHJvb2YnKSBMYXlvdXRDb25zdGFudHMuUVVBTElUWSA9IDI7ZWxzZSBMYXlvdXRDb25zdGFudHMuUVVBTElUWSA9IDA7XG5cbiAgQ29TRUNvbnN0YW50cy5OT0RFX0RJTUVOU0lPTlNfSU5DTFVERV9MQUJFTFMgPSBGRExheW91dENvbnN0YW50cy5OT0RFX0RJTUVOU0lPTlNfSU5DTFVERV9MQUJFTFMgPSBMYXlvdXRDb25zdGFudHMuTk9ERV9ESU1FTlNJT05TX0lOQ0xVREVfTEFCRUxTID0gb3B0aW9ucy5ub2RlRGltZW5zaW9uc0luY2x1ZGVMYWJlbHM7XG4gIENvU0VDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfSU5DUkVNRU5UQUwgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTCA9ICFvcHRpb25zLnJhbmRvbWl6ZTtcbiAgQ29TRUNvbnN0YW50cy5BTklNQVRFID0gRkRMYXlvdXRDb25zdGFudHMuQU5JTUFURSA9IExheW91dENvbnN0YW50cy5BTklNQVRFID0gb3B0aW9ucy5hbmltYXRlO1xuICBDb1NFQ29uc3RhbnRzLlRJTEUgPSBvcHRpb25zLnRpbGU7XG4gIENvU0VDb25zdGFudHMuVElMSU5HX1BBRERJTkdfVkVSVElDQUwgPSB0eXBlb2Ygb3B0aW9ucy50aWxpbmdQYWRkaW5nVmVydGljYWwgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLnRpbGluZ1BhZGRpbmdWZXJ0aWNhbC5jYWxsKCkgOiBvcHRpb25zLnRpbGluZ1BhZGRpbmdWZXJ0aWNhbDtcbiAgQ29TRUNvbnN0YW50cy5USUxJTkdfUEFERElOR19IT1JJWk9OVEFMID0gdHlwZW9mIG9wdGlvbnMudGlsaW5nUGFkZGluZ0hvcml6b250YWwgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLnRpbGluZ1BhZGRpbmdIb3Jpem9udGFsLmNhbGwoKSA6IG9wdGlvbnMudGlsaW5nUGFkZGluZ0hvcml6b250YWw7XG5cbiAgQ29TRUNvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMID0gdHJ1ZTtcbiAgQ29TRUNvbnN0YW50cy5QVVJFX0lOQ1JFTUVOVEFMID0gIW9wdGlvbnMucmFuZG9taXplO1xuICBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9VTklGT1JNX0xFQUZfTk9ERV9TSVpFUyA9IG9wdGlvbnMudW5pZm9ybU5vZGVEaW1lbnNpb25zO1xuXG4gIC8vIFRoaXMgcGFydCBpcyBmb3IgZGVidWcvZGVtbyBwdXJwb3NlXG4gIGlmIChvcHRpb25zLnN0ZXAgPT0gXCJ0cmFuc2Zvcm1lZFwiKSB7XG4gICAgQ29TRUNvbnN0YW50cy5UUkFOU0ZPUk1fT05fQ09OU1RSQUlOVF9IQU5ETElORyA9IHRydWU7XG4gICAgQ29TRUNvbnN0YW50cy5FTkZPUkNFX0NPTlNUUkFJTlRTID0gZmFsc2U7XG4gICAgQ29TRUNvbnN0YW50cy5BUFBMWV9MQVlPVVQgPSBmYWxzZTtcbiAgfVxuICBpZiAob3B0aW9ucy5zdGVwID09IFwiZW5mb3JjZWRcIikge1xuICAgIENvU0VDb25zdGFudHMuVFJBTlNGT1JNX09OX0NPTlNUUkFJTlRfSEFORExJTkcgPSBmYWxzZTtcbiAgICBDb1NFQ29uc3RhbnRzLkVORk9SQ0VfQ09OU1RSQUlOVFMgPSB0cnVlO1xuICAgIENvU0VDb25zdGFudHMuQVBQTFlfTEFZT1VUID0gZmFsc2U7XG4gIH1cbiAgaWYgKG9wdGlvbnMuc3RlcCA9PSBcImNvc2VcIikge1xuICAgIENvU0VDb25zdGFudHMuVFJBTlNGT1JNX09OX0NPTlNUUkFJTlRfSEFORExJTkcgPSBmYWxzZTtcbiAgICBDb1NFQ29uc3RhbnRzLkVORk9SQ0VfQ09OU1RSQUlOVFMgPSBmYWxzZTtcbiAgICBDb1NFQ29uc3RhbnRzLkFQUExZX0xBWU9VVCA9IHRydWU7XG4gIH1cbiAgaWYgKG9wdGlvbnMuc3RlcCA9PSBcImFsbFwiKSB7XG4gICAgaWYgKG9wdGlvbnMucmFuZG9taXplKSBDb1NFQ29uc3RhbnRzLlRSQU5TRk9STV9PTl9DT05TVFJBSU5UX0hBTkRMSU5HID0gdHJ1ZTtlbHNlIENvU0VDb25zdGFudHMuVFJBTlNGT1JNX09OX0NPTlNUUkFJTlRfSEFORExJTkcgPSBmYWxzZTtcbiAgICBDb1NFQ29uc3RhbnRzLkVORk9SQ0VfQ09OU1RSQUlOVFMgPSB0cnVlO1xuICAgIENvU0VDb25zdGFudHMuQVBQTFlfTEFZT1VUID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLmZpeGVkTm9kZUNvbnN0cmFpbnQgfHwgb3B0aW9ucy5hbGlnbm1lbnRDb25zdHJhaW50IHx8IG9wdGlvbnMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50KSB7XG4gICAgQ29TRUNvbnN0YW50cy5UUkVFX1JFRFVDVElPTl9PTl9JTkNSRU1FTlRBTCA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIENvU0VDb25zdGFudHMuVFJFRV9SRURVQ1RJT05fT05fSU5DUkVNRU5UQUwgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGNvc2VMYXlvdXQgPSBuZXcgQ29TRUxheW91dCgpO1xuICB2YXIgZ20gPSBjb3NlTGF5b3V0Lm5ld0dyYXBoTWFuYWdlcigpO1xuXG4gIHByb2Nlc3NDaGlsZHJlbkxpc3QoZ20uYWRkUm9vdCgpLCBhdXguZ2V0VG9wTW9zdE5vZGVzKG5vZGVzKSwgY29zZUxheW91dCwgb3B0aW9ucyk7XG4gIHByb2Nlc3NFZGdlcyhjb3NlTGF5b3V0LCBnbSwgZWRnZXMpO1xuICBwcm9jZXNzQ29uc3RyYWludHMoY29zZUxheW91dCwgb3B0aW9ucyk7XG5cbiAgY29zZUxheW91dC5ydW5MYXlvdXQoKTtcblxuICByZXR1cm4gaWRUb0xOb2RlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7IGNvc2VMYXlvdXQ6IGNvc2VMYXlvdXQgfTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDIxMjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICBUaGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIGZjb3NlIGxheW91dCBhbGdvcml0aG1cbiovXG5cbnZhciBhc3NpZ24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1OCk7XG52YXIgYXV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NDgpO1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1NyksXG4gICAgc3BlY3RyYWxMYXlvdXQgPSBfcmVxdWlyZS5zcGVjdHJhbExheW91dDtcblxudmFyIF9yZXF1aXJlMiA9IF9fd2VicGFja19yZXF1aXJlX18oODE2KSxcbiAgICBjb3NlTGF5b3V0ID0gX3JlcXVpcmUyLmNvc2VMYXlvdXQ7XG5cbnZhciBkZWZhdWx0cyA9IE9iamVjdC5mcmVlemUoe1xuXG4gIC8vICdkcmFmdCcsICdkZWZhdWx0JyBvciAncHJvb2YnIFxuICAvLyAtICdkcmFmdCcgb25seSBhcHBsaWVzIHNwZWN0cmFsIGxheW91dCBcbiAgLy8gLSAnZGVmYXVsdCcgaW1wcm92ZXMgdGhlIHF1YWxpdHkgd2l0aCBzdWJzZXF1ZW50IENvU0UgbGF5b3V0IChmYXN0IGNvb2xpbmcgcmF0ZSlcbiAgLy8gLSAncHJvb2YnIGltcHJvdmVzIHRoZSBxdWFsaXR5IHdpdGggc3Vic2VxdWVudCBDb1NFIGxheW91dCAoc2xvdyBjb29saW5nIHJhdGUpIFxuICBxdWFsaXR5OiBcImRlZmF1bHRcIixcbiAgLy8gVXNlIHJhbmRvbSBub2RlIHBvc2l0aW9ucyBhdCBiZWdpbm5pbmcgb2YgbGF5b3V0XG4gIC8vIGlmIHRoaXMgaXMgc2V0IHRvIGZhbHNlLCB0aGVuIHF1YWxpdHkgb3B0aW9uIG11c3QgYmUgXCJwcm9vZlwiXG4gIHJhbmRvbWl6ZTogdHJ1ZSxcbiAgLy8gV2hldGhlciBvciBub3QgdG8gYW5pbWF0ZSB0aGUgbGF5b3V0XG4gIGFuaW1hdGU6IHRydWUsXG4gIC8vIER1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcywgaWYgZW5hYmxlZFxuICBhbmltYXRpb25EdXJhdGlvbjogMTAwMCxcbiAgLy8gRWFzaW5nIG9mIGFuaW1hdGlvbiwgaWYgZW5hYmxlZFxuICBhbmltYXRpb25FYXNpbmc6IHVuZGVmaW5lZCxcbiAgLy8gRml0IHRoZSB2aWV3cG9ydCB0byB0aGUgcmVwb3NpdGlvbmVkIG5vZGVzXG4gIGZpdDogdHJ1ZSxcbiAgLy8gUGFkZGluZyBhcm91bmQgbGF5b3V0XG4gIHBhZGRpbmc6IDMwLFxuICAvLyBXaGV0aGVyIHRvIGluY2x1ZGUgbGFiZWxzIGluIG5vZGUgZGltZW5zaW9ucy4gVmFsaWQgaW4gXCJwcm9vZlwiIHF1YWxpdHlcbiAgbm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzOiBmYWxzZSxcbiAgLy8gV2hldGhlciBvciBub3Qgc2ltcGxlIG5vZGVzIChub24tY29tcG91bmQgbm9kZXMpIGFyZSBvZiB1bmlmb3JtIGRpbWVuc2lvbnNcbiAgdW5pZm9ybU5vZGVEaW1lbnNpb25zOiBmYWxzZSxcbiAgLy8gV2hldGhlciB0byBwYWNrIGRpc2Nvbm5lY3RlZCBjb21wb25lbnRzIC0gdmFsaWQgb25seSBpZiByYW5kb21pemU6IHRydWVcbiAgcGFja0NvbXBvbmVudHM6IHRydWUsXG4gIC8vIExheW91dCBzdGVwIC0gYWxsLCB0cmFuc2Zvcm1lZCwgZW5mb3JjZWQsIGNvc2UgLSBmb3IgZGVidWcgcHVycG9zZSBvbmx5XG4gIHN0ZXA6IFwiYWxsXCIsXG5cbiAgLyogc3BlY3RyYWwgbGF5b3V0IG9wdGlvbnMgKi9cblxuICAvLyBGYWxzZSBmb3IgcmFuZG9tLCB0cnVlIGZvciBncmVlZHlcbiAgc2FtcGxpbmdUeXBlOiB0cnVlLFxuICAvLyBTYW1wbGUgc2l6ZSB0byBjb25zdHJ1Y3QgZGlzdGFuY2UgbWF0cml4XG4gIHNhbXBsZVNpemU6IDI1LFxuICAvLyBTZXBhcmF0aW9uIGFtb3VudCBiZXR3ZWVuIG5vZGVzXG4gIG5vZGVTZXBhcmF0aW9uOiA3NSxcbiAgLy8gUG93ZXIgaXRlcmF0aW9uIHRvbGVyYW5jZVxuICBwaVRvbDogMC4wMDAwMDAxLFxuXG4gIC8qIENvU0UgbGF5b3V0IG9wdGlvbnMgKi9cblxuICAvLyBOb2RlIHJlcHVsc2lvbiAobm9uIG92ZXJsYXBwaW5nKSBtdWx0aXBsaWVyXG4gIG5vZGVSZXB1bHNpb246IGZ1bmN0aW9uIG5vZGVSZXB1bHNpb24obm9kZSkge1xuICAgIHJldHVybiA0NTAwO1xuICB9LFxuICAvLyBJZGVhbCBlZGdlIChub24gbmVzdGVkKSBsZW5ndGhcbiAgaWRlYWxFZGdlTGVuZ3RoOiBmdW5jdGlvbiBpZGVhbEVkZ2VMZW5ndGgoZWRnZSkge1xuICAgIHJldHVybiA1MDtcbiAgfSxcbiAgLy8gRGl2aXNvciB0byBjb21wdXRlIGVkZ2UgZm9yY2VzXG4gIGVkZ2VFbGFzdGljaXR5OiBmdW5jdGlvbiBlZGdlRWxhc3RpY2l0eShlZGdlKSB7XG4gICAgcmV0dXJuIDAuNDU7XG4gIH0sXG4gIC8vIE5lc3RpbmcgZmFjdG9yIChtdWx0aXBsaWVyKSB0byBjb21wdXRlIGlkZWFsIGVkZ2UgbGVuZ3RoIGZvciBuZXN0ZWQgZWRnZXNcbiAgbmVzdGluZ0ZhY3RvcjogMC4xLFxuICAvLyBHcmF2aXR5IGZvcmNlIChjb25zdGFudClcbiAgZ3Jhdml0eTogMC4yNSxcbiAgLy8gTWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBwZXJmb3JtXG4gIG51bUl0ZXI6IDI1MDAsXG4gIC8vIEZvciBlbmFibGluZyB0aWxpbmdcbiAgdGlsZTogdHJ1ZSxcbiAgLy8gVGhlIGZ1bmN0aW9uIHRoYXQgc3BlY2lmaWVzIHRoZSBjcml0ZXJpYSBmb3IgY29tcGFyaW5nIG5vZGVzIHdoaWxlIHNvcnRpbmcgdGhlbSBkdXJpbmcgdGlsaW5nIG9wZXJhdGlvbi5cbiAgLy8gVGFrZXMgdGhlIG5vZGUgaWQgYXMgYSBwYXJhbWV0ZXIgYW5kIHRoZSBkZWZhdWx0IHRpbGluZyBvcGVyYXRpb24gaXMgcGVyZm9tZWQgd2hlbiB0aGlzIG9wdGlvbiBpcyBub3Qgc2V0LlxuICB0aWxpbmdDb21wYXJlQnk6IHVuZGVmaW5lZCxcbiAgLy8gUmVwcmVzZW50cyB0aGUgYW1vdW50IG9mIHRoZSB2ZXJ0aWNhbCBzcGFjZSB0byBwdXQgYmV0d2VlbiB0aGUgemVybyBkZWdyZWUgbWVtYmVycyBkdXJpbmcgdGhlIHRpbGluZyBvcGVyYXRpb24oY2FuIGFsc28gYmUgYSBmdW5jdGlvbilcbiAgdGlsaW5nUGFkZGluZ1ZlcnRpY2FsOiAxMCxcbiAgLy8gUmVwcmVzZW50cyB0aGUgYW1vdW50IG9mIHRoZSBob3Jpem9udGFsIHNwYWNlIHRvIHB1dCBiZXR3ZWVuIHRoZSB6ZXJvIGRlZ3JlZSBtZW1iZXJzIGR1cmluZyB0aGUgdGlsaW5nIG9wZXJhdGlvbihjYW4gYWxzbyBiZSBhIGZ1bmN0aW9uKVxuICB0aWxpbmdQYWRkaW5nSG9yaXpvbnRhbDogMTAsXG4gIC8vIEdyYXZpdHkgcmFuZ2UgKGNvbnN0YW50KSBmb3IgY29tcG91bmRzXG4gIGdyYXZpdHlSYW5nZUNvbXBvdW5kOiAxLjUsXG4gIC8vIEdyYXZpdHkgZm9yY2UgKGNvbnN0YW50KSBmb3IgY29tcG91bmRzXG4gIGdyYXZpdHlDb21wb3VuZDogMS4wLFxuICAvLyBHcmF2aXR5IHJhbmdlIChjb25zdGFudClcbiAgZ3Jhdml0eVJhbmdlOiAzLjgsXG4gIC8vIEluaXRpYWwgY29vbGluZyBmYWN0b3IgZm9yIGluY3JlbWVudGFsIGxheW91dCAgXG4gIGluaXRpYWxFbmVyZ3lPbkluY3JlbWVudGFsOiAwLjMsXG5cbiAgLyogY29uc3RyYWludCBvcHRpb25zICovXG5cbiAgLy8gRml4IHJlcXVpcmVkIG5vZGVzIHRvIHByZWRlZmluZWQgcG9zaXRpb25zXG4gIC8vIFt7bm9kZUlkOiAnbjEnLCBwb3NpdGlvbjoge3g6IDEwMCwgeTogMjAwfSwgey4uLn1dXG4gIGZpeGVkTm9kZUNvbnN0cmFpbnQ6IHVuZGVmaW5lZCxcbiAgLy8gQWxpZ24gcmVxdWlyZWQgbm9kZXMgaW4gdmVydGljYWwvaG9yaXpvbnRhbCBkaXJlY3Rpb25cbiAgLy8ge3ZlcnRpY2FsOiBbWyduMScsICduMicpXSwgWyduMycsICduNCddXSwgaG9yaXpvbnRhbDogWyduMicsICduNCddfVxuICBhbGlnbm1lbnRDb25zdHJhaW50OiB1bmRlZmluZWQsXG4gIC8vIFBsYWNlIHR3byBub2RlcyByZWxhdGl2ZWx5IGluIHZlcnRpY2FsL2hvcml6b250YWwgZGlyZWN0aW9uIFxuICAvLyBbe3RvcDogJ24xJywgYm90dG9tOiAnbjInLCBnYXA6IDEwMH0sIHtsZWZ0OiAnbjMnLCByaWdodDogJ240JywgZ2FwOiA3NX1dXG4gIHJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludDogdW5kZWZpbmVkLFxuXG4gIC8qIGxheW91dCBldmVudCBjYWxsYmFja3MgKi9cbiAgcmVhZHk6IGZ1bmN0aW9uIHJlYWR5KCkge30sIC8vIG9uIGxheW91dHJlYWR5XG4gIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7fSAvLyBvbiBsYXlvdXRzdG9wXG59KTtcblxudmFyIExheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTGF5b3V0KG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGF5b3V0KTtcblxuICAgIHRoaXMub3B0aW9ucyA9IGFzc2lnbih7fSwgZGVmYXVsdHMsIG9wdGlvbnMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExheW91dCwgW3tcbiAgICBrZXk6ICdydW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBydW4oKSB7XG4gICAgICB2YXIgbGF5b3V0ID0gdGhpcztcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgdmFyIGN5ID0gb3B0aW9ucy5jeTtcbiAgICAgIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuXG4gICAgICB2YXIgc3BlY3RyYWxSZXN1bHQgPSBbXTtcbiAgICAgIHZhciB4Q29vcmRzID0gdm9pZCAwO1xuICAgICAgdmFyIHlDb29yZHMgPSB2b2lkIDA7XG4gICAgICB2YXIgY29zZVJlc3VsdCA9IFtdO1xuICAgICAgdmFyIGNvbXBvbmVudHMgPSB2b2lkIDA7XG4gICAgICB2YXIgY29tcG9uZW50Q2VudGVycyA9IFtdO1xuXG4gICAgICAvLyBiYXNpYyB2YWxpZGl0eSBjaGVjayBmb3IgY29uc3RyYWludCBpbnB1dHMgXG4gICAgICBpZiAob3B0aW9ucy5maXhlZE5vZGVDb25zdHJhaW50ICYmICghQXJyYXkuaXNBcnJheShvcHRpb25zLmZpeGVkTm9kZUNvbnN0cmFpbnQpIHx8IG9wdGlvbnMuZml4ZWROb2RlQ29uc3RyYWludC5sZW5ndGggPT0gMCkpIHtcbiAgICAgICAgb3B0aW9ucy5maXhlZE5vZGVDb25zdHJhaW50ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5hbGlnbm1lbnRDb25zdHJhaW50KSB7XG4gICAgICAgIGlmIChvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWwgJiYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMuYWxpZ25tZW50Q29uc3RyYWludC52ZXJ0aWNhbCkgfHwgb3B0aW9ucy5hbGlnbm1lbnRDb25zdHJhaW50LnZlcnRpY2FsLmxlbmd0aCA9PSAwKSkge1xuICAgICAgICAgIG9wdGlvbnMuYWxpZ25tZW50Q29uc3RyYWludC52ZXJ0aWNhbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5hbGlnbm1lbnRDb25zdHJhaW50Lmhvcml6b250YWwgJiYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMuYWxpZ25tZW50Q29uc3RyYWludC5ob3Jpem9udGFsKSB8fCBvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQuaG9yaXpvbnRhbC5sZW5ndGggPT0gMCkpIHtcbiAgICAgICAgICBvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQuaG9yaXpvbnRhbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQgJiYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50KSB8fCBvcHRpb25zLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludC5sZW5ndGggPT0gMCkpIHtcbiAgICAgICAgb3B0aW9ucy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIGFueSBjb25zdHJhaW50IGV4aXN0cywgc2V0IHNvbWUgb3B0aW9uc1xuICAgICAgdmFyIGNvbnN0cmFpbnRFeGlzdCA9IG9wdGlvbnMuZml4ZWROb2RlQ29uc3RyYWludCB8fCBvcHRpb25zLmFsaWdubWVudENvbnN0cmFpbnQgfHwgb3B0aW9ucy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQ7XG4gICAgICBpZiAoY29uc3RyYWludEV4aXN0KSB7XG4gICAgICAgIC8vIGNvbnN0cmFpbnRzIHdvcmsgd2l0aCB0aGVzZSBvcHRpb25zXG4gICAgICAgIG9wdGlvbnMudGlsZSA9IGZhbHNlO1xuICAgICAgICBvcHRpb25zLnBhY2tDb21wb25lbnRzID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIGRlY2lkZSBjb21wb25lbnQgcGFja2luZyBpcyBlbmFibGVkIG9yIG5vdFxuICAgICAgdmFyIGxheVV0aWwgPSB2b2lkIDA7XG4gICAgICB2YXIgcGFja2luZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgIGlmIChjeS5sYXlvdXRVdGlsaXRpZXMgJiYgb3B0aW9ucy5wYWNrQ29tcG9uZW50cykge1xuICAgICAgICBsYXlVdGlsID0gY3kubGF5b3V0VXRpbGl0aWVzKFwiZ2V0XCIpO1xuICAgICAgICBpZiAoIWxheVV0aWwpIGxheVV0aWwgPSBjeS5sYXlvdXRVdGlsaXRpZXMoKTtcbiAgICAgICAgcGFja2luZ0VuYWJsZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlcy5ub2RlcygpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gaWYgcGFja2luZyBpcyBub3QgZW5hYmxlZCwgcGVyZm9ybSBsYXlvdXQgb24gdGhlIHdob2xlIGdyYXBoXG4gICAgICAgIGlmICghcGFja2luZ0VuYWJsZWQpIHtcbiAgICAgICAgICAvLyBzdG9yZSBjb21wb25lbnQgY2VudGVyXG4gICAgICAgICAgdmFyIGJvdW5kaW5nQm94ID0gb3B0aW9ucy5lbGVzLmJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgY29tcG9uZW50Q2VudGVycy5wdXNoKHsgeDogYm91bmRpbmdCb3gueDEgKyBib3VuZGluZ0JveC53IC8gMiwgeTogYm91bmRpbmdCb3gueTEgKyBib3VuZGluZ0JveC5oIC8gMiB9KTtcbiAgICAgICAgICAvLyBhcHBseSBzcGVjdHJhbCBsYXlvdXRcbiAgICAgICAgICBpZiAob3B0aW9ucy5yYW5kb21pemUpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBzcGVjdHJhbExheW91dChvcHRpb25zKTtcbiAgICAgICAgICAgIHNwZWN0cmFsUmVzdWx0LnB1c2gocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gYXBwbHkgY29zZSBsYXlvdXQgYXMgcG9zdHByb2Nlc3NpbmdcbiAgICAgICAgICBpZiAob3B0aW9ucy5xdWFsaXR5ID09IFwiZGVmYXVsdFwiIHx8IG9wdGlvbnMucXVhbGl0eSA9PSBcInByb29mXCIpIHtcbiAgICAgICAgICAgIGNvc2VSZXN1bHQucHVzaChjb3NlTGF5b3V0KG9wdGlvbnMsIHNwZWN0cmFsUmVzdWx0WzBdKSk7XG4gICAgICAgICAgICBhdXgucmVsb2NhdGVDb21wb25lbnQoY29tcG9uZW50Q2VudGVyc1swXSwgY29zZVJlc3VsdFswXSwgb3B0aW9ucyk7IC8vIHJlbG9jYXRlIGNlbnRlciB0byBvcmlnaW5hbCBwb3NpdGlvblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdXgucmVsb2NhdGVDb21wb25lbnQoY29tcG9uZW50Q2VudGVyc1swXSwgc3BlY3RyYWxSZXN1bHRbMF0sIG9wdGlvbnMpOyAvLyByZWxvY2F0ZSBjZW50ZXIgdG8gb3JpZ2luYWwgcG9zaXRpb25cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gcGFja2luZyBpcyBlbmFibGVkXG4gICAgICAgICAgdmFyIHRvcE1vc3ROb2RlcyA9IGF1eC5nZXRUb3BNb3N0Tm9kZXMob3B0aW9ucy5lbGVzLm5vZGVzKCkpO1xuICAgICAgICAgIGNvbXBvbmVudHMgPSBhdXguY29ubmVjdENvbXBvbmVudHMoY3ksIG9wdGlvbnMuZWxlcywgdG9wTW9zdE5vZGVzKTtcbiAgICAgICAgICAvLyBzdG9yZSBjb21wb25lbnQgY2VudGVyc1xuICAgICAgICAgIGNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICB2YXIgYm91bmRpbmdCb3ggPSBjb21wb25lbnQuYm91bmRpbmdCb3goKTtcbiAgICAgICAgICAgIGNvbXBvbmVudENlbnRlcnMucHVzaCh7IHg6IGJvdW5kaW5nQm94LngxICsgYm91bmRpbmdCb3gudyAvIDIsIHk6IGJvdW5kaW5nQm94LnkxICsgYm91bmRpbmdCb3guaCAvIDIgfSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvL3NlbmQgZWFjaCBjb21wb25lbnQgdG8gc3BlY3RyYWwgbGF5b3V0IGlmIHJhbmRvbWl6ZWRcbiAgICAgICAgICBpZiAob3B0aW9ucy5yYW5kb21pemUpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMuZWxlcyA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgICAgc3BlY3RyYWxSZXN1bHQucHVzaChzcGVjdHJhbExheW91dChvcHRpb25zKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5xdWFsaXR5ID09IFwiZGVmYXVsdFwiIHx8IG9wdGlvbnMucXVhbGl0eSA9PSBcInByb29mXCIpIHtcbiAgICAgICAgICAgIHZhciB0b0JlVGlsZWROb2RlcyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnRpbGUpIHtcbiAgICAgICAgICAgICAgLy8gYmVoYXZlIG5vZGVzIHRvIGJlIHRpbGVkIGFzIG9uZSBjb21wb25lbnRcbiAgICAgICAgICAgICAgdmFyIG5vZGVJbmRleGVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICB2YXIgX3hDb29yZHMgPSBbXTtcbiAgICAgICAgICAgICAgdmFyIF95Q29vcmRzID0gW107XG4gICAgICAgICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgICAgICAgIHZhciB0ZW1wU3BlY3RyYWxSZXN1bHQgPSB7IG5vZGVJbmRleGVzOiBub2RlSW5kZXhlcywgeENvb3JkczogX3hDb29yZHMsIHlDb29yZHM6IF95Q29vcmRzIH07XG4gICAgICAgICAgICAgIHZhciBpbmRleGVzVG9CZURlbGV0ZWQgPSBbXTtcbiAgICAgICAgICAgICAgY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5lZGdlcygpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICBjb21wb25lbnQubm9kZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvQmVUaWxlZE5vZGVzLm1lcmdlKGNvbXBvbmVudC5ub2RlcygpW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLmlzUGFyZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICB0ZW1wU3BlY3RyYWxSZXN1bHQubm9kZUluZGV4ZXMuc2V0KGNvbXBvbmVudC5ub2RlcygpW2ldLmlkKCksIGNvdW50KyspO1xuICAgICAgICAgICAgICAgICAgICAgIHRlbXBTcGVjdHJhbFJlc3VsdC54Q29vcmRzLnB1c2goY29tcG9uZW50Lm5vZGVzKClbMF0ucG9zaXRpb24oKS54KTtcbiAgICAgICAgICAgICAgICAgICAgICB0ZW1wU3BlY3RyYWxSZXN1bHQueUNvb3Jkcy5wdXNoKGNvbXBvbmVudC5ub2RlcygpWzBdLnBvc2l0aW9uKCkueSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgaW5kZXhlc1RvQmVEZWxldGVkLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmICh0b0JlVGlsZWROb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9ib3VuZGluZ0JveCA9IHRvQmVUaWxlZE5vZGVzLmJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50Q2VudGVycy5wdXNoKHsgeDogX2JvdW5kaW5nQm94LngxICsgX2JvdW5kaW5nQm94LncgLyAyLCB5OiBfYm91bmRpbmdCb3gueTEgKyBfYm91bmRpbmdCb3guaCAvIDIgfSk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50cy5wdXNoKHRvQmVUaWxlZE5vZGVzKTtcbiAgICAgICAgICAgICAgICBzcGVjdHJhbFJlc3VsdC5wdXNoKHRlbXBTcGVjdHJhbFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGluZGV4ZXNUb0JlRGVsZXRlZC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgY29tcG9uZW50cy5zcGxpY2UoaW5kZXhlc1RvQmVEZWxldGVkW2ldLCAxKTtcbiAgICAgICAgICAgICAgICAgIHNwZWN0cmFsUmVzdWx0LnNwbGljZShpbmRleGVzVG9CZURlbGV0ZWRbaV0sIDEpO1xuICAgICAgICAgICAgICAgICAgY29tcG9uZW50Q2VudGVycy5zcGxpY2UoaW5kZXhlc1RvQmVEZWxldGVkW2ldLCAxKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgLy8gc2VuZCBlYWNoIGNvbXBvbmVudCB0byBjb3NlIGxheW91dFxuICAgICAgICAgICAgICBvcHRpb25zLmVsZXMgPSBjb21wb25lbnQ7XG4gICAgICAgICAgICAgIGNvc2VSZXN1bHQucHVzaChjb3NlTGF5b3V0KG9wdGlvbnMsIHNwZWN0cmFsUmVzdWx0W2luZGV4XSkpO1xuICAgICAgICAgICAgICBhdXgucmVsb2NhdGVDb21wb25lbnQoY29tcG9uZW50Q2VudGVyc1tpbmRleF0sIGNvc2VSZXN1bHRbaW5kZXhdLCBvcHRpb25zKTsgLy8gcmVsb2NhdGUgY2VudGVyIHRvIG9yaWdpbmFsIHBvc2l0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgIGF1eC5yZWxvY2F0ZUNvbXBvbmVudChjb21wb25lbnRDZW50ZXJzW2luZGV4XSwgc3BlY3RyYWxSZXN1bHRbaW5kZXhdLCBvcHRpb25zKTsgLy8gcmVsb2NhdGUgY2VudGVyIHRvIG9yaWdpbmFsIHBvc2l0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBwYWNraW5nXG4gICAgICAgICAgdmFyIGNvbXBvbmVudHNFdmFsdWF0ZWQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgaWYgKGNvbXBvbmVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIHN1YmdyYXBocyA9IFtdO1xuICAgICAgICAgICAgdmFyIGhpZGRlbkVsZXMgPSBlbGVzLmZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlbGUuY3NzKCdkaXNwbGF5JykgPT0gJ25vbmUnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgdmFyIG5vZGVJbmRleGVzID0gdm9pZCAwO1xuICAgICAgICAgICAgICBpZiAob3B0aW9ucy5xdWFsaXR5ID09IFwiZHJhZnRcIikge1xuICAgICAgICAgICAgICAgIG5vZGVJbmRleGVzID0gc3BlY3RyYWxSZXN1bHRbaW5kZXhdLm5vZGVJbmRleGVzO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5ub2RlcygpLm5vdChoaWRkZW5FbGVzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YmdyYXBoID0ge307XG4gICAgICAgICAgICAgICAgc3ViZ3JhcGguZWRnZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBzdWJncmFwaC5ub2RlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBub2RlSW5kZXggPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50Lm5vZGVzKCkubm90KGhpZGRlbkVsZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkcmFmdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5pc1BhcmVudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbm9kZUluZGV4ID0gbm9kZUluZGV4ZXMuZ2V0KG5vZGUuaWQoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgc3ViZ3JhcGgubm9kZXMucHVzaCh7IHg6IHNwZWN0cmFsUmVzdWx0W2luZGV4XS54Q29vcmRzW25vZGVJbmRleF0gLSBub2RlLmJvdW5kaW5nYm94KCkudyAvIDIsIHk6IHNwZWN0cmFsUmVzdWx0W2luZGV4XS55Q29vcmRzW25vZGVJbmRleF0gLSBub2RlLmJvdW5kaW5nYm94KCkuaCAvIDIsIHdpZHRoOiBub2RlLmJvdW5kaW5nYm94KCkudywgaGVpZ2h0OiBub2RlLmJvdW5kaW5nYm94KCkuaCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50SW5mbyA9IGF1eC5jYWxjQm91bmRpbmdCb3gobm9kZSwgc3BlY3RyYWxSZXN1bHRbaW5kZXhdLnhDb29yZHMsIHNwZWN0cmFsUmVzdWx0W2luZGV4XS55Q29vcmRzLCBub2RlSW5kZXhlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgc3ViZ3JhcGgubm9kZXMucHVzaCh7IHg6IHBhcmVudEluZm8udG9wTGVmdFgsIHk6IHBhcmVudEluZm8udG9wTGVmdFksIHdpZHRoOiBwYXJlbnRJbmZvLndpZHRoLCBoZWlnaHQ6IHBhcmVudEluZm8uaGVpZ2h0IH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29zZVJlc3VsdFtpbmRleF1bbm9kZS5pZCgpXSkge1xuICAgICAgICAgICAgICAgICAgICAgIHN1YmdyYXBoLm5vZGVzLnB1c2goeyB4OiBjb3NlUmVzdWx0W2luZGV4XVtub2RlLmlkKCldLmdldExlZnQoKSwgeTogY29zZVJlc3VsdFtpbmRleF1bbm9kZS5pZCgpXS5nZXRUb3AoKSwgd2lkdGg6IGNvc2VSZXN1bHRbaW5kZXhdW25vZGUuaWQoKV0uZ2V0V2lkdGgoKSwgaGVpZ2h0OiBjb3NlUmVzdWx0W2luZGV4XVtub2RlLmlkKCldLmdldEhlaWdodCgpIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LmVkZ2VzKCkuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGVkZ2Uuc291cmNlKCk7XG4gICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZWRnZS50YXJnZXQoKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY3NzKFwiZGlzcGxheVwiKSAhPSBcIm5vbmVcIiAmJiB0YXJnZXQuY3NzKFwiZGlzcGxheVwiKSAhPSBcIm5vbmVcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5xdWFsaXR5ID09IFwiZHJhZnRcIikge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VOb2RlSW5kZXggPSBub2RlSW5kZXhlcy5nZXQoc291cmNlLmlkKCkpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXROb2RlSW5kZXggPSBub2RlSW5kZXhlcy5nZXQodGFyZ2V0LmlkKCkpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VDZW50ZXIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0Q2VudGVyID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5pc1BhcmVudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50SW5mbyA9IGF1eC5jYWxjQm91bmRpbmdCb3goc291cmNlLCBzcGVjdHJhbFJlc3VsdFtpbmRleF0ueENvb3Jkcywgc3BlY3RyYWxSZXN1bHRbaW5kZXhdLnlDb29yZHMsIG5vZGVJbmRleGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZUNlbnRlci5wdXNoKHBhcmVudEluZm8udG9wTGVmdFggKyBwYXJlbnRJbmZvLndpZHRoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VDZW50ZXIucHVzaChwYXJlbnRJbmZvLnRvcExlZnRZICsgcGFyZW50SW5mby5oZWlnaHQgLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlQ2VudGVyLnB1c2goc3BlY3RyYWxSZXN1bHRbaW5kZXhdLnhDb29yZHNbc291cmNlTm9kZUluZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VDZW50ZXIucHVzaChzcGVjdHJhbFJlc3VsdFtpbmRleF0ueUNvb3Jkc1tzb3VyY2VOb2RlSW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldC5pc1BhcmVudCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3BhcmVudEluZm8gPSBhdXguY2FsY0JvdW5kaW5nQm94KHRhcmdldCwgc3BlY3RyYWxSZXN1bHRbaW5kZXhdLnhDb29yZHMsIHNwZWN0cmFsUmVzdWx0W2luZGV4XS55Q29vcmRzLCBub2RlSW5kZXhlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRDZW50ZXIucHVzaChfcGFyZW50SW5mby50b3BMZWZ0WCArIF9wYXJlbnRJbmZvLndpZHRoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRDZW50ZXIucHVzaChfcGFyZW50SW5mby50b3BMZWZ0WSArIF9wYXJlbnRJbmZvLmhlaWdodCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRDZW50ZXIucHVzaChzcGVjdHJhbFJlc3VsdFtpbmRleF0ueENvb3Jkc1t0YXJnZXROb2RlSW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldENlbnRlci5wdXNoKHNwZWN0cmFsUmVzdWx0W2luZGV4XS55Q29vcmRzW3RhcmdldE5vZGVJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBzdWJncmFwaC5lZGdlcy5wdXNoKHsgc3RhcnRYOiBzb3VyY2VDZW50ZXJbMF0sIHN0YXJ0WTogc291cmNlQ2VudGVyWzFdLCBlbmRYOiB0YXJnZXRDZW50ZXJbMF0sIGVuZFk6IHRhcmdldENlbnRlclsxXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoY29zZVJlc3VsdFtpbmRleF1bc291cmNlLmlkKCldICYmIGNvc2VSZXN1bHRbaW5kZXhdW3RhcmdldC5pZCgpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViZ3JhcGguZWRnZXMucHVzaCh7IHN0YXJ0WDogY29zZVJlc3VsdFtpbmRleF1bc291cmNlLmlkKCldLmdldENlbnRlclgoKSwgc3RhcnRZOiBjb3NlUmVzdWx0W2luZGV4XVtzb3VyY2UuaWQoKV0uZ2V0Q2VudGVyWSgpLCBlbmRYOiBjb3NlUmVzdWx0W2luZGV4XVt0YXJnZXQuaWQoKV0uZ2V0Q2VudGVyWCgpLCBlbmRZOiBjb3NlUmVzdWx0W2luZGV4XVt0YXJnZXQuaWQoKV0uZ2V0Q2VudGVyWSgpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChzdWJncmFwaC5ub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBzdWJncmFwaHMucHVzaChzdWJncmFwaCk7XG4gICAgICAgICAgICAgICAgICBjb21wb25lbnRzRXZhbHVhdGVkLmFkZChpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBzaGlmdFJlc3VsdCA9IGxheVV0aWwucGFja0NvbXBvbmVudHMoc3ViZ3JhcGhzLCBvcHRpb25zLnJhbmRvbWl6ZSkuc2hpZnRzO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucXVhbGl0eSA9PSBcImRyYWZ0XCIpIHtcbiAgICAgICAgICAgICAgc3BlY3RyYWxSZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0LCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdYQ29vcmRzID0gcmVzdWx0LnhDb29yZHMubWFwKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4geCArIHNoaWZ0UmVzdWx0W2luZGV4XS5keDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3WUNvb3JkcyA9IHJlc3VsdC55Q29vcmRzLm1hcChmdW5jdGlvbiAoeSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHkgKyBzaGlmdFJlc3VsdFtpbmRleF0uZHk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnhDb29yZHMgPSBuZXdYQ29vcmRzO1xuICAgICAgICAgICAgICAgIHJlc3VsdC55Q29vcmRzID0gbmV3WUNvb3JkcztcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgX2NvdW50ID0gMDtcbiAgICAgICAgICAgICAgY29tcG9uZW50c0V2YWx1YXRlZC5mb3JFYWNoKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGNvc2VSZXN1bHRbaW5kZXhdKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbm9kZVJlY3RhbmdsZSA9IGNvc2VSZXN1bHRbaW5kZXhdW2l0ZW1dO1xuICAgICAgICAgICAgICAgICAgbm9kZVJlY3RhbmdsZS5zZXRDZW50ZXIobm9kZVJlY3RhbmdsZS5nZXRDZW50ZXJYKCkgKyBzaGlmdFJlc3VsdFtfY291bnRdLmR4LCBub2RlUmVjdGFuZ2xlLmdldENlbnRlclkoKSArIHNoaWZ0UmVzdWx0W19jb3VudF0uZHkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIF9jb3VudCsrO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZ2V0IGVhY2ggZWxlbWVudCdzIGNhbGN1bGF0ZWQgcG9zaXRpb25cbiAgICAgIHZhciBnZXRQb3NpdGlvbnMgPSBmdW5jdGlvbiBnZXRQb3NpdGlvbnMoZWxlLCBpKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnF1YWxpdHkgPT0gXCJkZWZhdWx0XCIgfHwgb3B0aW9ucy5xdWFsaXR5ID09IFwicHJvb2ZcIikge1xuICAgICAgICAgIGlmICh0eXBlb2YgZWxlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBlbGUgPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcG9zID0gdm9pZCAwO1xuICAgICAgICAgIHZhciBub2RlID0gdm9pZCAwO1xuICAgICAgICAgIHZhciB0aGVJZCA9IGVsZS5kYXRhKCdpZCcpO1xuICAgICAgICAgIGNvc2VSZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAodGhlSWQgaW4gcmVzdWx0KSB7XG4gICAgICAgICAgICAgIHBvcyA9IHsgeDogcmVzdWx0W3RoZUlkXS5nZXRSZWN0KCkuZ2V0Q2VudGVyWCgpLCB5OiByZXN1bHRbdGhlSWRdLmdldFJlY3QoKS5nZXRDZW50ZXJZKCkgfTtcbiAgICAgICAgICAgICAgbm9kZSA9IHJlc3VsdFt0aGVJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKG9wdGlvbnMubm9kZURpbWVuc2lvbnNJbmNsdWRlTGFiZWxzKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5sYWJlbFdpZHRoKSB7XG4gICAgICAgICAgICAgIGlmIChub2RlLmxhYmVsUG9zSG9yaXpvbnRhbCA9PSBcImxlZnRcIikge1xuICAgICAgICAgICAgICAgIHBvcy54ICs9IG5vZGUubGFiZWxXaWR0aCAvIDI7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5sYWJlbFBvc0hvcml6b250YWwgPT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgICAgICAgcG9zLnggLT0gbm9kZS5sYWJlbFdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUubGFiZWxIZWlnaHQpIHtcbiAgICAgICAgICAgICAgaWYgKG5vZGUubGFiZWxQb3NWZXJ0aWNhbCA9PSBcInRvcFwiKSB7XG4gICAgICAgICAgICAgICAgcG9zLnkgKz0gbm9kZS5sYWJlbEhlaWdodCAvIDI7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5sYWJlbFBvc1ZlcnRpY2FsID09IFwiYm90dG9tXCIpIHtcbiAgICAgICAgICAgICAgICBwb3MueSAtPSBub2RlLmxhYmVsSGVpZ2h0IC8gMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocG9zID09IHVuZGVmaW5lZCkgcG9zID0geyB4OiBlbGUucG9zaXRpb24oXCJ4XCIpLCB5OiBlbGUucG9zaXRpb24oXCJ5XCIpIH07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHBvcy54LFxuICAgICAgICAgICAgeTogcG9zLnlcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfcG9zID0gdm9pZCAwO1xuICAgICAgICAgIHNwZWN0cmFsUmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gcmVzdWx0Lm5vZGVJbmRleGVzLmdldChlbGUuaWQoKSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIF9wb3MgPSB7IHg6IHJlc3VsdC54Q29vcmRzW2luZGV4XSwgeTogcmVzdWx0LnlDb29yZHNbaW5kZXhdIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKF9wb3MgPT0gdW5kZWZpbmVkKSBfcG9zID0geyB4OiBlbGUucG9zaXRpb24oXCJ4XCIpLCB5OiBlbGUucG9zaXRpb24oXCJ5XCIpIH07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IF9wb3MueCxcbiAgICAgICAgICAgIHk6IF9wb3MueVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIHF1YWxpdHkgPSBcImRyYWZ0XCIgYW5kIHJhbmRvbWl6ZSA9IGZhbHNlIGFyZSBjb250cmFkaWN0aXZlIHNvIGluIHRoYXQgY2FzZSBwb3NpdGlvbnMgZG9uJ3QgY2hhbmdlXG4gICAgICBpZiAob3B0aW9ucy5xdWFsaXR5ID09IFwiZGVmYXVsdFwiIHx8IG9wdGlvbnMucXVhbGl0eSA9PSBcInByb29mXCIgfHwgb3B0aW9ucy5yYW5kb21pemUpIHtcbiAgICAgICAgLy8gdHJhbnNmZXIgY2FsY3VsYXRlZCBwb3NpdGlvbnMgdG8gbm9kZXMgKHBvc2l0aW9ucyBvZiBvbmx5IHNpbXBsZSBub2RlcyBhcmUgZXZhbHVhdGVkLCBjb21wb3VuZHMgYXJlIHBvc2l0aW9uZWQgYXV0b21hdGljYWxseSlcbiAgICAgICAgdmFyIHBhcmVudHNXaXRob3V0Q2hpbGRyZW4gPSBhdXguY2FsY1BhcmVudHNXaXRob3V0Q2hpbGRyZW4oY3ksIGVsZXMpO1xuICAgICAgICB2YXIgX2hpZGRlbkVsZXMgPSBlbGVzLmZpbHRlcihmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZS5jc3MoJ2Rpc3BsYXknKSA9PSAnbm9uZSc7XG4gICAgICAgIH0pO1xuICAgICAgICBvcHRpb25zLmVsZXMgPSBlbGVzLm5vdChfaGlkZGVuRWxlcyk7XG5cbiAgICAgICAgZWxlcy5ub2RlcygpLm5vdChcIjpwYXJlbnRcIikubm90KF9oaWRkZW5FbGVzKS5sYXlvdXRQb3NpdGlvbnMobGF5b3V0LCBvcHRpb25zLCBnZXRQb3NpdGlvbnMpO1xuXG4gICAgICAgIGlmIChwYXJlbnRzV2l0aG91dENoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBwYXJlbnRzV2l0aG91dENoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGVsZSkge1xuICAgICAgICAgICAgZWxlLnBvc2l0aW9uKGdldFBvc2l0aW9ucyhlbGUpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJJZiByYW5kb21pemUgb3B0aW9uIGlzIHNldCB0byBmYWxzZSwgdGhlbiBxdWFsaXR5IG9wdGlvbiBtdXN0IGJlICdkZWZhdWx0JyBvciAncHJvb2YnLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTGF5b3V0O1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExheW91dDtcblxuLyoqKi8gfSksXG5cbi8qKiovIDY1Nzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG5cbi8qKlxuICBUaGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIHNwZWN0cmFsIGxheW91dCB0aGF0IGlzIHRoZSBmaXJzdCBwYXJ0IG9mIHRoZSBmY29zZSBsYXlvdXQgYWxnb3JpdGhtXG4qL1xuXG52YXIgYXV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NDgpO1xudmFyIE1hdHJpeCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKS5sYXlvdXRCYXNlLk1hdHJpeDtcbnZhciBTVkQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0MCkubGF5b3V0QmFzZS5TVkQ7XG5cbi8vIG1haW4gZnVuY3Rpb24gdGhhdCBzcGVjdHJhbCBsYXlvdXQgaXMgcHJvY2Vzc2VkXG52YXIgc3BlY3RyYWxMYXlvdXQgPSBmdW5jdGlvbiBzcGVjdHJhbExheW91dChvcHRpb25zKSB7XG5cbiAgdmFyIGN5ID0gb3B0aW9ucy5jeTtcbiAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKTtcbiAgdmFyIHBhcmVudE5vZGVzID0gZWxlcy5ub2RlcyhcIjpwYXJlbnRcIik7XG5cbiAgdmFyIGR1bW15Tm9kZXMgPSBuZXcgTWFwKCk7IC8vIG1hcCB0byBrZWVwIGR1bW15IG5vZGVzIGFuZCB0aGVpciBuZWlnaGJvcnNcbiAgdmFyIG5vZGVJbmRleGVzID0gbmV3IE1hcCgpOyAvLyBtYXAgdG8ga2VlcCBpbmRleGVzIHRvIG5vZGVzXG4gIHZhciBwYXJlbnRDaGlsZE1hcCA9IG5ldyBNYXAoKTsgLy8gbWFwcGluZyBidHcuIGNvbXBvdW5kIGFuZCBpdHMgcmVwcmVzZW50YXRpdmUgbm9kZSBcbiAgdmFyIGFsbE5vZGVzTmVpZ2hib3Job29kID0gW107IC8vIGFycmF5IHRvIGtlZXAgbmVpZ2hib3Job29kIG9mIGFsbCBub2Rlc1xuICB2YXIgeENvb3JkcyA9IFtdO1xuICB2YXIgeUNvb3JkcyA9IFtdO1xuXG4gIHZhciBzYW1wbGVzQ29sdW1uID0gW107IC8vIHNhbXBsZWQgdmVydGljZXNcbiAgdmFyIG1pbkRpc3RhbmNlc0NvbHVtbiA9IFtdO1xuICB2YXIgQyA9IFtdOyAvLyBjb2x1bW4gc2FtcGxpbmcgbWF0cml4XG4gIHZhciBQSEkgPSBbXTsgLy8gaW50ZXJzZWN0aW9uIG9mIGNvbHVtbiBhbmQgcm93IHNhbXBsaW5nIG1hdHJpY2VzIFxuICB2YXIgSU5WID0gW107IC8vIGludmVyc2Ugb2YgUEhJIFxuXG4gIHZhciBmaXJzdFNhbXBsZSA9IHZvaWQgMDsgLy8gdGhlIGZpcnN0IHNhbXBsZWQgbm9kZVxuICB2YXIgbm9kZVNpemUgPSB2b2lkIDA7XG5cbiAgdmFyIGluZmluaXR5ID0gMTAwMDAwMDAwO1xuICB2YXIgc21hbGwgPSAwLjAwMDAwMDAwMTtcblxuICB2YXIgcGlUb2wgPSBvcHRpb25zLnBpVG9sO1xuICB2YXIgc2FtcGxpbmdUeXBlID0gb3B0aW9ucy5zYW1wbGluZ1R5cGU7IC8vIGZhbHNlIGZvciByYW5kb20sIHRydWUgZm9yIGdyZWVkeVxuICB2YXIgbm9kZVNlcGFyYXRpb24gPSBvcHRpb25zLm5vZGVTZXBhcmF0aW9uO1xuICB2YXIgc2FtcGxlU2l6ZSA9IHZvaWQgMDtcblxuICAvKioqKiBTcGVjdHJhbC1wcmVwcm9jZXNzaW5nIGZ1bmN0aW9ucyAqKioqL1xuXG4gIC8qKioqIFNwZWN0cmFsIGxheW91dCBmdW5jdGlvbnMgKioqKi9cblxuICAvLyBkZXRlcm1pbmUgd2hpY2ggY29sdW1ucyB0byBiZSBzYW1wbGVkXG4gIHZhciByYW5kb21TYW1wbGVDUiA9IGZ1bmN0aW9uIHJhbmRvbVNhbXBsZUNSKCkge1xuICAgIHZhciBzYW1wbGUgPSAwO1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGZsYWcgPSBmYWxzZTtcblxuICAgIHdoaWxlIChjb3VudCA8IHNhbXBsZVNpemUpIHtcbiAgICAgIHNhbXBsZSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG5vZGVTaXplKTtcblxuICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGlmIChzYW1wbGVzQ29sdW1uW2ldID09IHNhbXBsZSkge1xuICAgICAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZmxhZykge1xuICAgICAgICBzYW1wbGVzQ29sdW1uW2NvdW50XSA9IHNhbXBsZTtcbiAgICAgICAgY291bnQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyB0YWtlcyB0aGUgaW5kZXggb2YgdGhlIG5vZGUocGl2b3QpIHRvIGluaXRpYXRlIEJGUyBhcyBhIHBhcmFtZXRlclxuICB2YXIgQkZTID0gZnVuY3Rpb24gQkZTKHBpdm90LCBpbmRleCwgc2FtcGxpbmdNZXRob2QpIHtcbiAgICB2YXIgcGF0aCA9IFtdOyAvLyB0aGUgZnJvbnQgb2YgdGhlIHBhdGhcbiAgICB2YXIgZnJvbnQgPSAwOyAvLyB0aGUgYmFjayBvZiB0aGUgcGF0aFxuICAgIHZhciBiYWNrID0gMDtcbiAgICB2YXIgY3VycmVudCA9IDA7XG4gICAgdmFyIHRlbXAgPSB2b2lkIDA7XG4gICAgdmFyIGRpc3RhbmNlID0gW107XG5cbiAgICB2YXIgbWF4X2Rpc3QgPSAwOyAvLyB0aGUgZnVydGhlc3Qgbm9kZSB0byBiZSByZXR1cm5lZFxuICAgIHZhciBtYXhfaW5kID0gMTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZVNpemU7IGkrKykge1xuICAgICAgZGlzdGFuY2VbaV0gPSBpbmZpbml0eTtcbiAgICB9XG5cbiAgICBwYXRoW2JhY2tdID0gcGl2b3Q7XG4gICAgZGlzdGFuY2VbcGl2b3RdID0gMDtcblxuICAgIHdoaWxlIChiYWNrID49IGZyb250KSB7XG4gICAgICBjdXJyZW50ID0gcGF0aFtmcm9udCsrXTtcbiAgICAgIHZhciBuZWlnaGJvcnMgPSBhbGxOb2Rlc05laWdoYm9yaG9vZFtjdXJyZW50XTtcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBuZWlnaGJvcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHRlbXAgPSBub2RlSW5kZXhlcy5nZXQobmVpZ2hib3JzW19pXSk7XG4gICAgICAgIGlmIChkaXN0YW5jZVt0ZW1wXSA9PSBpbmZpbml0eSkge1xuICAgICAgICAgIGRpc3RhbmNlW3RlbXBdID0gZGlzdGFuY2VbY3VycmVudF0gKyAxO1xuICAgICAgICAgIHBhdGhbKytiYWNrXSA9IHRlbXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIENbY3VycmVudF1baW5kZXhdID0gZGlzdGFuY2VbY3VycmVudF0gKiBub2RlU2VwYXJhdGlvbjtcbiAgICB9XG5cbiAgICBpZiAoc2FtcGxpbmdNZXRob2QpIHtcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG5vZGVTaXplOyBfaTIrKykge1xuICAgICAgICBpZiAoQ1tfaTJdW2luZGV4XSA8IG1pbkRpc3RhbmNlc0NvbHVtbltfaTJdKSBtaW5EaXN0YW5jZXNDb2x1bW5bX2kyXSA9IENbX2kyXVtpbmRleF07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG5vZGVTaXplOyBfaTMrKykge1xuICAgICAgICBpZiAobWluRGlzdGFuY2VzQ29sdW1uW19pM10gPiBtYXhfZGlzdCkge1xuICAgICAgICAgIG1heF9kaXN0ID0gbWluRGlzdGFuY2VzQ29sdW1uW19pM107XG4gICAgICAgICAgbWF4X2luZCA9IF9pMztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4X2luZDtcbiAgfTtcblxuICAvLyBhcHBseSBCRlMgdG8gYWxsIG5vZGVzIG9yIHNlbGVjdGVkIHNhbXBsZXNcbiAgdmFyIGFsbEJGUyA9IGZ1bmN0aW9uIGFsbEJGUyhzYW1wbGluZ01ldGhvZCkge1xuXG4gICAgdmFyIHNhbXBsZSA9IHZvaWQgMDtcblxuICAgIGlmICghc2FtcGxpbmdNZXRob2QpIHtcbiAgICAgIHJhbmRvbVNhbXBsZUNSKCk7XG5cbiAgICAgIC8vIGNhbGwgQkZTXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNhbXBsZVNpemU7IGkrKykge1xuICAgICAgICBCRlMoc2FtcGxlc0NvbHVtbltpXSwgaSwgc2FtcGxpbmdNZXRob2QsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2FtcGxlID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbm9kZVNpemUpO1xuICAgICAgZmlyc3RTYW1wbGUgPSBzYW1wbGU7XG5cbiAgICAgIGZvciAodmFyIF9pNCA9IDA7IF9pNCA8IG5vZGVTaXplOyBfaTQrKykge1xuICAgICAgICBtaW5EaXN0YW5jZXNDb2x1bW5bX2k0XSA9IGluZmluaXR5O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBzYW1wbGVTaXplOyBfaTUrKykge1xuICAgICAgICBzYW1wbGVzQ29sdW1uW19pNV0gPSBzYW1wbGU7XG4gICAgICAgIHNhbXBsZSA9IEJGUyhzYW1wbGUsIF9pNSwgc2FtcGxpbmdNZXRob2QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZvcm0gdGhlIHNxdWFyZWQgZGlzdGFuY2VzIGZvciBDXG4gICAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgbm9kZVNpemU7IF9pNisrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNhbXBsZVNpemU7IGorKykge1xuICAgICAgICBDW19pNl1bal0gKj0gQ1tfaTZdW2pdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZvcm0gUEhJXG4gICAgZm9yICh2YXIgX2k3ID0gMDsgX2k3IDwgc2FtcGxlU2l6ZTsgX2k3KyspIHtcbiAgICAgIFBISVtfaTddID0gW107XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2k4ID0gMDsgX2k4IDwgc2FtcGxlU2l6ZTsgX2k4KyspIHtcbiAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBzYW1wbGVTaXplOyBfaisrKSB7XG4gICAgICAgIFBISVtfaThdW19qXSA9IENbc2FtcGxlc0NvbHVtbltfal1dW19pOF07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIHBlcmZvcm0gdGhlIFNWRCBhbGdvcml0aG0gYW5kIGFwcGx5IGEgcmVndWxhcml6YXRpb24gc3RlcFxuICB2YXIgc2FtcGxlID0gZnVuY3Rpb24gc2FtcGxlKCkge1xuXG4gICAgdmFyIFNWRFJlc3VsdCA9IFNWRC5zdmQoUEhJKTtcblxuICAgIHZhciBhX3EgPSBTVkRSZXN1bHQuUztcbiAgICB2YXIgYV91ID0gU1ZEUmVzdWx0LlU7XG4gICAgdmFyIGFfdiA9IFNWRFJlc3VsdC5WO1xuXG4gICAgdmFyIG1heF9zID0gYV9xWzBdICogYV9xWzBdICogYV9xWzBdO1xuXG4gICAgdmFyIGFfU2lnID0gW107XG5cbiAgICAvLyAgcmVndWxhcml6YXRpb25cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNhbXBsZVNpemU7IGkrKykge1xuICAgICAgYV9TaWdbaV0gPSBbXTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2FtcGxlU2l6ZTsgaisrKSB7XG4gICAgICAgIGFfU2lnW2ldW2pdID0gMDtcbiAgICAgICAgaWYgKGkgPT0gaikge1xuICAgICAgICAgIGFfU2lnW2ldW2pdID0gYV9xW2ldIC8gKGFfcVtpXSAqIGFfcVtpXSArIG1heF9zIC8gKGFfcVtpXSAqIGFfcVtpXSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgSU5WID0gTWF0cml4Lm11bHRNYXQoTWF0cml4Lm11bHRNYXQoYV92LCBhX1NpZyksIE1hdHJpeC50cmFuc3Bvc2UoYV91KSk7XG4gIH07XG5cbiAgLy8gY2FsY3VsYXRlIGZpbmFsIGNvb3JkaW5hdGVzIFxuICB2YXIgcG93ZXJJdGVyYXRpb24gPSBmdW5jdGlvbiBwb3dlckl0ZXJhdGlvbigpIHtcbiAgICAvLyB0d28gbGFyZ2VzdCBlaWdlbnZhbHVlc1xuICAgIHZhciB0aGV0YTEgPSB2b2lkIDA7XG4gICAgdmFyIHRoZXRhMiA9IHZvaWQgMDtcblxuICAgIC8vIGluaXRpYWwgZ3Vlc3NlcyBmb3IgZWlnZW52ZWN0b3JzXG4gICAgdmFyIFkxID0gW107XG4gICAgdmFyIFkyID0gW107XG5cbiAgICB2YXIgVjEgPSBbXTtcbiAgICB2YXIgVjIgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZVNpemU7IGkrKykge1xuICAgICAgWTFbaV0gPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgWTJbaV0gPSBNYXRoLnJhbmRvbSgpO1xuICAgIH1cblxuICAgIFkxID0gTWF0cml4Lm5vcm1hbGl6ZShZMSk7XG4gICAgWTIgPSBNYXRyaXgubm9ybWFsaXplKFkyKTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgLy8gdG8ga2VlcCB0cmFjayBvZiB0aGUgaW1wcm92ZW1lbnQgcmF0aW8gaW4gcG93ZXIgaXRlcmF0aW9uXG4gICAgdmFyIGN1cnJlbnQgPSBzbWFsbDtcbiAgICB2YXIgcHJldmlvdXMgPSBzbWFsbDtcblxuICAgIHZhciB0ZW1wID0gdm9pZCAwO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvdW50Kys7XG5cbiAgICAgIGZvciAodmFyIF9pOSA9IDA7IF9pOSA8IG5vZGVTaXplOyBfaTkrKykge1xuICAgICAgICBWMVtfaTldID0gWTFbX2k5XTtcbiAgICAgIH1cblxuICAgICAgWTEgPSBNYXRyaXgubXVsdEdhbW1hKE1hdHJpeC5tdWx0TChNYXRyaXgubXVsdEdhbW1hKFYxKSwgQywgSU5WKSk7XG4gICAgICB0aGV0YTEgPSBNYXRyaXguZG90UHJvZHVjdChWMSwgWTEpO1xuICAgICAgWTEgPSBNYXRyaXgubm9ybWFsaXplKFkxKTtcblxuICAgICAgY3VycmVudCA9IE1hdHJpeC5kb3RQcm9kdWN0KFYxLCBZMSk7XG5cbiAgICAgIHRlbXAgPSBNYXRoLmFicyhjdXJyZW50IC8gcHJldmlvdXMpO1xuXG4gICAgICBpZiAodGVtcCA8PSAxICsgcGlUb2wgJiYgdGVtcCA+PSAxKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kxMCA9IDA7IF9pMTAgPCBub2RlU2l6ZTsgX2kxMCsrKSB7XG4gICAgICBWMVtfaTEwXSA9IFkxW19pMTBdO1xuICAgIH1cblxuICAgIGNvdW50ID0gMDtcbiAgICBwcmV2aW91cyA9IHNtYWxsO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb3VudCsrO1xuXG4gICAgICBmb3IgKHZhciBfaTExID0gMDsgX2kxMSA8IG5vZGVTaXplOyBfaTExKyspIHtcbiAgICAgICAgVjJbX2kxMV0gPSBZMltfaTExXTtcbiAgICAgIH1cblxuICAgICAgVjIgPSBNYXRyaXgubWludXNPcChWMiwgTWF0cml4Lm11bHRDb25zKFYxLCBNYXRyaXguZG90UHJvZHVjdChWMSwgVjIpKSk7XG4gICAgICBZMiA9IE1hdHJpeC5tdWx0R2FtbWEoTWF0cml4Lm11bHRMKE1hdHJpeC5tdWx0R2FtbWEoVjIpLCBDLCBJTlYpKTtcbiAgICAgIHRoZXRhMiA9IE1hdHJpeC5kb3RQcm9kdWN0KFYyLCBZMik7XG4gICAgICBZMiA9IE1hdHJpeC5ub3JtYWxpemUoWTIpO1xuXG4gICAgICBjdXJyZW50ID0gTWF0cml4LmRvdFByb2R1Y3QoVjIsIFkyKTtcblxuICAgICAgdGVtcCA9IE1hdGguYWJzKGN1cnJlbnQgLyBwcmV2aW91cyk7XG5cbiAgICAgIGlmICh0ZW1wIDw9IDEgKyBwaVRvbCAmJiB0ZW1wID49IDEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaTEyID0gMDsgX2kxMiA8IG5vZGVTaXplOyBfaTEyKyspIHtcbiAgICAgIFYyW19pMTJdID0gWTJbX2kxMl07XG4gICAgfVxuXG4gICAgLy8gdGhldGExIG5vdyBjb250YWlucyBkb21pbmFudCBlaWdlbnZhbHVlXG4gICAgLy8gdGhldGEyIG5vdyBjb250YWlucyB0aGUgc2Vjb25kLWxhcmdlc3QgZWlnZW52YWx1ZVxuICAgIC8vIFYxIG5vdyBjb250YWlucyB0aGV0YTEncyBlaWdlbnZlY3RvclxuICAgIC8vIFYyIG5vdyBjb250YWlucyB0aGV0YTIncyBlaWdlbnZlY3RvclxuXG4gICAgLy9wb3B1bGF0ZSB0aGUgdHdvIHZlY3RvcnNcbiAgICB4Q29vcmRzID0gTWF0cml4Lm11bHRDb25zKFYxLCBNYXRoLnNxcnQoTWF0aC5hYnModGhldGExKSkpO1xuICAgIHlDb29yZHMgPSBNYXRyaXgubXVsdENvbnMoVjIsIE1hdGguc3FydChNYXRoLmFicyh0aGV0YTIpKSk7XG4gIH07XG5cbiAgLyoqKiogUHJlcGFyYXRpb24gZm9yIHNwZWN0cmFsIGxheW91dCAoUHJlcHJvY2Vzc2luZykgKioqKi9cblxuICAvLyBjb25uZWN0IGRpc2Nvbm5lY3RlZCBjb21wb25lbnRzIChmaXJzdCB0b3AgbGV2ZWwsIHRoZW4gaW5zaWRlIG9mIGVhY2ggY29tcG91bmQgbm9kZSlcbiAgYXV4LmNvbm5lY3RDb21wb25lbnRzKGN5LCBlbGVzLCBhdXguZ2V0VG9wTW9zdE5vZGVzKG5vZGVzKSwgZHVtbXlOb2Rlcyk7XG5cbiAgcGFyZW50Tm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgYXV4LmNvbm5lY3RDb21wb25lbnRzKGN5LCBlbGVzLCBhdXguZ2V0VG9wTW9zdE5vZGVzKGVsZS5kZXNjZW5kYW50cygpLmludGVyc2VjdGlvbihlbGVzKSksIGR1bW15Tm9kZXMpO1xuICB9KTtcblxuICAvLyBhc3NpZ24gaW5kZXhlcyB0byBub2RlcyAoZmlyc3QgcmVhbCwgdGhlbiBkdW1teSBub2RlcylcbiAgdmFyIGluZGV4ID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghbm9kZXNbaV0uaXNQYXJlbnQoKSkge1xuICAgICAgbm9kZUluZGV4ZXMuc2V0KG5vZGVzW2ldLmlkKCksIGluZGV4KyspO1xuICAgIH1cbiAgfVxuXG4gIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gIHZhciBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IGR1bW15Tm9kZXMua2V5cygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgdmFyIGtleSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICBub2RlSW5kZXhlcy5zZXQoa2V5LCBpbmRleCsrKTtcbiAgICB9XG5cbiAgICAvLyBpbnN0YW50aWF0ZSB0aGUgbmVpZ2hib3Job29kIG1hdHJpeFxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9pMTMgPSAwOyBfaTEzIDwgbm9kZUluZGV4ZXMuc2l6ZTsgX2kxMysrKSB7XG4gICAgYWxsTm9kZXNOZWlnaGJvcmhvb2RbX2kxM10gPSBbXTtcbiAgfVxuXG4gIC8vIGZvcm0gYSBwYXJlbnQtY2hpbGQgbWFwIHRvIGtlZXAgcmVwcmVzZW50YXRpdmUgbm9kZSBvZiBlYWNoIGNvbXBvdW5kIG5vZGUgIFxuICBwYXJlbnROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChlbGUpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBlbGUuY2hpbGRyZW4oKS5pbnRlcnNlY3Rpb24oZWxlcyk7XG5cbiAgICAvLyAgICAgIGxldCByYW5kb20gPSAwO1xuICAgIHdoaWxlIChjaGlsZHJlbi5ub2RlcyhcIjpjaGlsZGxlc3NcIikubGVuZ3RoID09IDApIHtcbiAgICAgIC8vICAgICAgICByYW5kb20gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGlsZHJlbi5ub2RlcygpLmxlbmd0aCk7IC8vIGlmIGFsbCBjaGlsZHJlbiBhcmUgY29tcG91bmQgdGhlbiBwcm9jZWVkIHJhbmRvbWx5XG4gICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLm5vZGVzKClbMF0uY2hpbGRyZW4oKS5pbnRlcnNlY3Rpb24oZWxlcyk7XG4gICAgfVxuICAgIC8vICBzZWxlY3QgdGhlIHJlcHJlc2VudGF0aXZlIG5vZGUgLSB3ZSBjYW4gYXBwbHkgZGlmZmVyZW50IG1ldGhvZHMgaGVyZVxuICAgIC8vICAgICAgcmFuZG9tID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hpbGRyZW4ubm9kZXMoXCI6Y2hpbGRsZXNzXCIpLmxlbmd0aCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgbWluID0gY2hpbGRyZW4ubm9kZXMoXCI6Y2hpbGRsZXNzXCIpWzBdLmNvbm5lY3RlZEVkZ2VzKCkubGVuZ3RoO1xuICAgIGNoaWxkcmVuLm5vZGVzKFwiOmNoaWxkbGVzc1wiKS5mb3JFYWNoKGZ1bmN0aW9uIChlbGUyLCBpKSB7XG4gICAgICBpZiAoZWxlMi5jb25uZWN0ZWRFZGdlcygpLmxlbmd0aCA8IG1pbikge1xuICAgICAgICBtaW4gPSBlbGUyLmNvbm5lY3RlZEVkZ2VzKCkubGVuZ3RoO1xuICAgICAgICBpbmRleCA9IGk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcGFyZW50Q2hpbGRNYXAuc2V0KGVsZS5pZCgpLCBjaGlsZHJlbi5ub2RlcyhcIjpjaGlsZGxlc3NcIilbaW5kZXhdLmlkKCkpO1xuICB9KTtcblxuICAvLyBhZGQgbmVpZ2hib3Job29kIHJlbGF0aW9ucyAoZmlyc3QgcmVhbCwgdGhlbiBkdW1teSBub2RlcylcbiAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgdmFyIGVsZUluZGV4ID0gdm9pZCAwO1xuXG4gICAgaWYgKGVsZS5pc1BhcmVudCgpKSBlbGVJbmRleCA9IG5vZGVJbmRleGVzLmdldChwYXJlbnRDaGlsZE1hcC5nZXQoZWxlLmlkKCkpKTtlbHNlIGVsZUluZGV4ID0gbm9kZUluZGV4ZXMuZ2V0KGVsZS5pZCgpKTtcblxuICAgIGVsZS5uZWlnaGJvcmhvb2QoKS5ub2RlcygpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIGlmIChlbGVzLmludGVyc2VjdGlvbihlbGUuZWRnZXNXaXRoKG5vZGUpKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChub2RlLmlzUGFyZW50KCkpIGFsbE5vZGVzTmVpZ2hib3Job29kW2VsZUluZGV4XS5wdXNoKHBhcmVudENoaWxkTWFwLmdldChub2RlLmlkKCkpKTtlbHNlIGFsbE5vZGVzTmVpZ2hib3Job29kW2VsZUluZGV4XS5wdXNoKG5vZGUuaWQoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKF9rZXkpIHtcbiAgICB2YXIgZWxlSW5kZXggPSBub2RlSW5kZXhlcy5nZXQoX2tleSk7XG4gICAgdmFyIGRpc2Nvbm5lY3RlZElkID0gdm9pZCAwO1xuICAgIGR1bW15Tm9kZXMuZ2V0KF9rZXkpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICBpZiAoY3kuZ2V0RWxlbWVudEJ5SWQoaWQpLmlzUGFyZW50KCkpIGRpc2Nvbm5lY3RlZElkID0gcGFyZW50Q2hpbGRNYXAuZ2V0KGlkKTtlbHNlIGRpc2Nvbm5lY3RlZElkID0gaWQ7XG5cbiAgICAgIGFsbE5vZGVzTmVpZ2hib3Job29kW2VsZUluZGV4XS5wdXNoKGRpc2Nvbm5lY3RlZElkKTtcbiAgICAgIGFsbE5vZGVzTmVpZ2hib3Job29kW25vZGVJbmRleGVzLmdldChkaXNjb25uZWN0ZWRJZCldLnB1c2goX2tleSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbiAgdmFyIF9kaWRJdGVyYXRvckVycm9yMiA9IGZhbHNlO1xuICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yMiA9IGR1bW15Tm9kZXMua2V5cygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAyOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlKSB7XG4gICAgICB2YXIgX2tleSA9IF9zdGVwMi52YWx1ZTtcblxuICAgICAgX2xvb3AoX2tleSk7XG4gICAgfVxuXG4gICAgLy8gbm9kZVNpemUgbm93IG9ubHkgY29uc2lkZXJzIHRoZSBzaXplIG9mIHRyYW5zZm9ybWVkIGdyYXBoXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgX2l0ZXJhdG9yRXJyb3IyID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yICYmIF9pdGVyYXRvcjIucmV0dXJuKSB7XG4gICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG5vZGVTaXplID0gbm9kZUluZGV4ZXMuc2l6ZTtcblxuICB2YXIgc3BlY3RyYWxSZXN1bHQgPSB2b2lkIDA7XG5cbiAgLy8gSWYgbnVtYmVyIG9mIG5vZGVzIGluIHRyYW5zZm9ybWVkIGdyYXBoIGlzIDEgb3IgMiwgZWl0aGVyIFNWRCBvciBwb3dlckl0ZXJhdGlvbiBjYXVzZXMgcHJvYmxlbVxuICAvLyBTbyBza2lwIHNwZWN0cmFsIGFuZCBsYXlvdXQgdGhlIGdyYXBoIHdpdGggY29zZVxuICBpZiAobm9kZVNpemUgPiAyKSB7XG4gICAgLy8gaWYgIyBvZiBub2RlcyBpbiB0cmFuc2Zvcm1lZCBncmFwaCBpcyBzbWFsbGVyIHRoYW4gc2FtcGxlIHNpemUsXG4gICAgLy8gdGhlbiB1c2UgIyBvZiBub2RlcyBhcyBzYW1wbGUgc2l6ZVxuICAgIHNhbXBsZVNpemUgPSBub2RlU2l6ZSA8IG9wdGlvbnMuc2FtcGxlU2l6ZSA/IG5vZGVTaXplIDogb3B0aW9ucy5zYW1wbGVTaXplO1xuXG4gICAgLy8gaW5zdGFudGlhdGVzIHRoZSBwYXJ0aWFsIG1hdHJpY2VzIHRoYXQgd2lsbCBiZSB1c2VkIGluIHNwZWN0cmFsIGxheW91dFxuICAgIGZvciAodmFyIF9pMTQgPSAwOyBfaTE0IDwgbm9kZVNpemU7IF9pMTQrKykge1xuICAgICAgQ1tfaTE0XSA9IFtdO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaTE1ID0gMDsgX2kxNSA8IHNhbXBsZVNpemU7IF9pMTUrKykge1xuICAgICAgSU5WW19pMTVdID0gW107XG4gICAgfVxuXG4gICAgLyoqKiogQXBwbHkgc3BlY3RyYWwgbGF5b3V0ICoqKiovXG5cbiAgICBpZiAob3B0aW9ucy5xdWFsaXR5ID09IFwiZHJhZnRcIiB8fCBvcHRpb25zLnN0ZXAgPT0gXCJhbGxcIikge1xuICAgICAgYWxsQkZTKHNhbXBsaW5nVHlwZSk7XG4gICAgICBzYW1wbGUoKTtcbiAgICAgIHBvd2VySXRlcmF0aW9uKCk7XG5cbiAgICAgIHNwZWN0cmFsUmVzdWx0ID0geyBub2RlSW5kZXhlczogbm9kZUluZGV4ZXMsIHhDb29yZHM6IHhDb29yZHMsIHlDb29yZHM6IHlDb29yZHMgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZUluZGV4ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICB4Q29vcmRzLnB1c2goY3kuZ2V0RWxlbWVudEJ5SWQoa2V5KS5wb3NpdGlvbihcInhcIikpO1xuICAgICAgICB5Q29vcmRzLnB1c2goY3kuZ2V0RWxlbWVudEJ5SWQoa2V5KS5wb3NpdGlvbihcInlcIikpO1xuICAgICAgfSk7XG4gICAgICBzcGVjdHJhbFJlc3VsdCA9IHsgbm9kZUluZGV4ZXM6IG5vZGVJbmRleGVzLCB4Q29vcmRzOiB4Q29vcmRzLCB5Q29vcmRzOiB5Q29vcmRzIH07XG4gICAgfVxuICAgIHJldHVybiBzcGVjdHJhbFJlc3VsdDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgaXRlcmF0b3IgPSBub2RlSW5kZXhlcy5rZXlzKCk7XG4gICAgdmFyIGZpcnN0Tm9kZSA9IGN5LmdldEVsZW1lbnRCeUlkKGl0ZXJhdG9yLm5leHQoKS52YWx1ZSk7XG4gICAgdmFyIGZpcnN0Tm9kZVBvcyA9IGZpcnN0Tm9kZS5wb3NpdGlvbigpO1xuICAgIHZhciBmaXJzdE5vZGVXaWR0aCA9IGZpcnN0Tm9kZS5vdXRlcldpZHRoKCk7XG4gICAgeENvb3Jkcy5wdXNoKGZpcnN0Tm9kZVBvcy54KTtcbiAgICB5Q29vcmRzLnB1c2goZmlyc3ROb2RlUG9zLnkpO1xuICAgIGlmIChub2RlU2l6ZSA9PSAyKSB7XG4gICAgICB2YXIgc2Vjb25kTm9kZSA9IGN5LmdldEVsZW1lbnRCeUlkKGl0ZXJhdG9yLm5leHQoKS52YWx1ZSk7XG4gICAgICB2YXIgc2Vjb25kTm9kZVdpZHRoID0gc2Vjb25kTm9kZS5vdXRlcldpZHRoKCk7XG4gICAgICB4Q29vcmRzLnB1c2goZmlyc3ROb2RlUG9zLnggKyBmaXJzdE5vZGVXaWR0aCAvIDIgKyBzZWNvbmROb2RlV2lkdGggLyAyICsgb3B0aW9ucy5pZGVhbEVkZ2VMZW5ndGgpO1xuICAgICAgeUNvb3Jkcy5wdXNoKGZpcnN0Tm9kZVBvcy55KTtcbiAgICB9XG5cbiAgICBzcGVjdHJhbFJlc3VsdCA9IHsgbm9kZUluZGV4ZXM6IG5vZGVJbmRleGVzLCB4Q29vcmRzOiB4Q29vcmRzLCB5Q29vcmRzOiB5Q29vcmRzIH07XG4gICAgcmV0dXJuIHNwZWN0cmFsUmVzdWx0O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgc3BlY3RyYWxMYXlvdXQ6IHNwZWN0cmFsTGF5b3V0IH07XG5cbi8qKiovIH0pLFxuXG4vKioqLyA1Nzk6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG52YXIgaW1wbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjEyKTtcblxuLy8gcmVnaXN0ZXJzIHRoZSBleHRlbnNpb24gb24gYSBjeXRvc2NhcGUgbGliIHJlZlxudmFyIHJlZ2lzdGVyID0gZnVuY3Rpb24gcmVnaXN0ZXIoY3l0b3NjYXBlKSB7XG4gIGlmICghY3l0b3NjYXBlKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIGNhbid0IHJlZ2lzdGVyIGlmIGN5dG9zY2FwZSB1bnNwZWNpZmllZFxuXG4gIGN5dG9zY2FwZSgnbGF5b3V0JywgJ2Zjb3NlJywgaW1wbCk7IC8vIHJlZ2lzdGVyIHdpdGggY3l0b3NjYXBlLmpzXG59O1xuXG5pZiAodHlwZW9mIGN5dG9zY2FwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgLy8gZXhwb3NlIHRvIGdsb2JhbCBjeXRvc2NhcGUgKGkuZS4gd2luZG93LmN5dG9zY2FwZSlcbiAgcmVnaXN0ZXIoY3l0b3NjYXBlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWdpc3RlcjtcblxuLyoqKi8gfSksXG5cbi8qKiovIDE0MDpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fMTQwX187XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIFx0fSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcbi8qKioqKiovIFx0XHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBzdGFydHVwXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHQvLyBUaGlzIGVudHJ5IG1vZHVsZSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIG1vZHVsZXMgc28gaXQgY2FuJ3QgYmUgaW5saW5lZFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNTc5KTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfZXhwb3J0c19fO1xuLyoqKioqKi8gfSkoKVxuO1xufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/cytoscape-fcose/cytoscape-fcose.js\n");

/***/ }),

/***/ "./node_modules/cytoscape-fcose/node_modules/cose-base/cose-base.js":
/*!**************************************************************************!*\
  !*** ./node_modules/cytoscape-fcose/node_modules/cose-base/cose-base.js ***!
  \**************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(/*! layout-base */ \"./node_modules/cytoscape-fcose/node_modules/layout-base/layout-base.js\"));\n\telse {}\n})(this, function(__WEBPACK_EXTERNAL_MODULE__551__) {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 45:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_630__) => {\n\n\n\nvar coseBase = {};\n\ncoseBase.layoutBase = __nested_webpack_require_630__(551);\ncoseBase.CoSEConstants = __nested_webpack_require_630__(806);\ncoseBase.CoSEEdge = __nested_webpack_require_630__(767);\ncoseBase.CoSEGraph = __nested_webpack_require_630__(880);\ncoseBase.CoSEGraphManager = __nested_webpack_require_630__(578);\ncoseBase.CoSELayout = __nested_webpack_require_630__(765);\ncoseBase.CoSENode = __nested_webpack_require_630__(991);\ncoseBase.ConstraintHandler = __nested_webpack_require_630__(902);\n\nmodule.exports = coseBase;\n\n/***/ }),\n\n/***/ 806:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_1167__) => {\n\n\n\nvar FDLayoutConstants = __nested_webpack_require_1167__(551).FDLayoutConstants;\n\nfunction CoSEConstants() {}\n\n//CoSEConstants inherits static props in FDLayoutConstants\nfor (var prop in FDLayoutConstants) {\n  CoSEConstants[prop] = FDLayoutConstants[prop];\n}\n\nCoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;\nCoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\nCoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;\nCoSEConstants.TILE = true;\nCoSEConstants.TILING_PADDING_VERTICAL = 10;\nCoSEConstants.TILING_PADDING_HORIZONTAL = 10;\nCoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;\nCoSEConstants.ENFORCE_CONSTRAINTS = true;\nCoSEConstants.APPLY_LAYOUT = true;\nCoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS = true;\nCoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true; // this should be set to false if there will be a constraint\n// This constant is for differentiating whether actual layout algorithm that uses cose-base wants to apply only incremental layout or \n// an incremental layout on top of a randomized layout. If it is only incremental layout, then this constant should be true.\nCoSEConstants.PURE_INCREMENTAL = CoSEConstants.DEFAULT_INCREMENTAL;\n\nmodule.exports = CoSEConstants;\n\n/***/ }),\n\n/***/ 767:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_2468__) => {\n\n\n\nvar FDLayoutEdge = __nested_webpack_require_2468__(551).FDLayoutEdge;\n\nfunction CoSEEdge(source, target, vEdge) {\n  FDLayoutEdge.call(this, source, target, vEdge);\n}\n\nCoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);\nfor (var prop in FDLayoutEdge) {\n  CoSEEdge[prop] = FDLayoutEdge[prop];\n}\n\nmodule.exports = CoSEEdge;\n\n/***/ }),\n\n/***/ 880:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_2879__) => {\n\n\n\nvar LGraph = __nested_webpack_require_2879__(551).LGraph;\n\nfunction CoSEGraph(parent, graphMgr, vGraph) {\n  LGraph.call(this, parent, graphMgr, vGraph);\n}\n\nCoSEGraph.prototype = Object.create(LGraph.prototype);\nfor (var prop in LGraph) {\n  CoSEGraph[prop] = LGraph[prop];\n}\n\nmodule.exports = CoSEGraph;\n\n/***/ }),\n\n/***/ 578:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_3264__) => {\n\n\n\nvar LGraphManager = __nested_webpack_require_3264__(551).LGraphManager;\n\nfunction CoSEGraphManager(layout) {\n  LGraphManager.call(this, layout);\n}\n\nCoSEGraphManager.prototype = Object.create(LGraphManager.prototype);\nfor (var prop in LGraphManager) {\n  CoSEGraphManager[prop] = LGraphManager[prop];\n}\n\nmodule.exports = CoSEGraphManager;\n\n/***/ }),\n\n/***/ 765:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_3683__) => {\n\n\n\nvar FDLayout = __nested_webpack_require_3683__(551).FDLayout;\nvar CoSEGraphManager = __nested_webpack_require_3683__(578);\nvar CoSEGraph = __nested_webpack_require_3683__(880);\nvar CoSENode = __nested_webpack_require_3683__(991);\nvar CoSEEdge = __nested_webpack_require_3683__(767);\nvar CoSEConstants = __nested_webpack_require_3683__(806);\nvar ConstraintHandler = __nested_webpack_require_3683__(902);\nvar FDLayoutConstants = __nested_webpack_require_3683__(551).FDLayoutConstants;\nvar LayoutConstants = __nested_webpack_require_3683__(551).LayoutConstants;\nvar Point = __nested_webpack_require_3683__(551).Point;\nvar PointD = __nested_webpack_require_3683__(551).PointD;\nvar DimensionD = __nested_webpack_require_3683__(551).DimensionD;\nvar Layout = __nested_webpack_require_3683__(551).Layout;\nvar Integer = __nested_webpack_require_3683__(551).Integer;\nvar IGeometry = __nested_webpack_require_3683__(551).IGeometry;\nvar LGraph = __nested_webpack_require_3683__(551).LGraph;\nvar Transform = __nested_webpack_require_3683__(551).Transform;\nvar LinkedList = __nested_webpack_require_3683__(551).LinkedList;\n\nfunction CoSELayout() {\n  FDLayout.call(this);\n\n  this.toBeTiled = {}; // Memorize if a node is to be tiled or is tiled\n  this.constraints = {}; // keep layout constraints\n}\n\nCoSELayout.prototype = Object.create(FDLayout.prototype);\n\nfor (var prop in FDLayout) {\n  CoSELayout[prop] = FDLayout[prop];\n}\n\nCoSELayout.prototype.newGraphManager = function () {\n  var gm = new CoSEGraphManager(this);\n  this.graphManager = gm;\n  return gm;\n};\n\nCoSELayout.prototype.newGraph = function (vGraph) {\n  return new CoSEGraph(null, this.graphManager, vGraph);\n};\n\nCoSELayout.prototype.newNode = function (vNode) {\n  return new CoSENode(this.graphManager, vNode);\n};\n\nCoSELayout.prototype.newEdge = function (vEdge) {\n  return new CoSEEdge(null, null, vEdge);\n};\n\nCoSELayout.prototype.initParameters = function () {\n  FDLayout.prototype.initParameters.call(this, arguments);\n  if (!this.isSubLayout) {\n    if (CoSEConstants.DEFAULT_EDGE_LENGTH < 10) {\n      this.idealEdgeLength = 10;\n    } else {\n      this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;\n    }\n\n    this.useSmartIdealEdgeLengthCalculation = CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n    this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n    this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n    this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n    this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n\n    // variables for tree reduction support\n    this.prunedNodesAll = [];\n    this.growTreeIterations = 0;\n    this.afterGrowthIterations = 0;\n    this.isTreeGrowing = false;\n    this.isGrowthFinished = false;\n  }\n};\n\n// This method is used to set CoSE related parameters used by spring embedder.\nCoSELayout.prototype.initSpringEmbedder = function () {\n  FDLayout.prototype.initSpringEmbedder.call(this);\n\n  // variables for cooling\n  this.coolingCycle = 0;\n  this.maxCoolingCycle = this.maxIterations / FDLayoutConstants.CONVERGENCE_CHECK_PERIOD;\n  this.finalTemperature = 0.04;\n  this.coolingAdjuster = 1;\n};\n\nCoSELayout.prototype.layout = function () {\n  var createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n  if (createBendsAsNeeded) {\n    this.createBendpoints();\n    this.graphManager.resetAllEdges();\n  }\n\n  this.level = 0;\n  return this.classicLayout();\n};\n\nCoSELayout.prototype.classicLayout = function () {\n  this.nodesWithGravity = this.calculateNodesToApplyGravitationTo();\n  this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity);\n  this.calcNoOfChildrenForAllNodes();\n  this.graphManager.calcLowestCommonAncestors();\n  this.graphManager.calcInclusionTreeDepths();\n  this.graphManager.getRoot().calcEstimatedSize();\n  this.calcIdealEdgeLengths();\n\n  if (!this.incremental) {\n    var forest = this.getFlatForest();\n\n    // The graph associated with this layout is flat and a forest\n    if (forest.length > 0) {\n      this.positionNodesRadially(forest);\n    }\n    // The graph associated with this layout is not flat or a forest\n    else {\n        // Reduce the trees when incremental mode is not enabled and graph is not a forest \n        this.reduceTrees();\n        // Update nodes that gravity will be applied\n        this.graphManager.resetAllNodesToApplyGravitation();\n        var allNodes = new Set(this.getAllNodes());\n        var intersection = this.nodesWithGravity.filter(function (x) {\n          return allNodes.has(x);\n        });\n        this.graphManager.setAllNodesToApplyGravitation(intersection);\n\n        this.positionNodesRandomly();\n      }\n  } else {\n    if (CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL) {\n      // Reduce the trees in incremental mode if only this constant is set to true \n      this.reduceTrees();\n      // Update nodes that gravity will be applied\n      this.graphManager.resetAllNodesToApplyGravitation();\n      var allNodes = new Set(this.getAllNodes());\n      var intersection = this.nodesWithGravity.filter(function (x) {\n        return allNodes.has(x);\n      });\n      this.graphManager.setAllNodesToApplyGravitation(intersection);\n    }\n  }\n\n  if (Object.keys(this.constraints).length > 0) {\n    ConstraintHandler.handleConstraints(this);\n    this.initConstraintVariables();\n  }\n\n  this.initSpringEmbedder();\n  if (CoSEConstants.APPLY_LAYOUT) {\n    this.runSpringEmbedder();\n  }\n\n  return true;\n};\n\nCoSELayout.prototype.tick = function () {\n  this.totalIterations++;\n\n  if (this.totalIterations === this.maxIterations && !this.isTreeGrowing && !this.isGrowthFinished) {\n    if (this.prunedNodesAll.length > 0) {\n      this.isTreeGrowing = true;\n    } else {\n      return true;\n    }\n  }\n\n  if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0 && !this.isTreeGrowing && !this.isGrowthFinished) {\n    if (this.isConverged()) {\n      if (this.prunedNodesAll.length > 0) {\n        this.isTreeGrowing = true;\n      } else {\n        return true;\n      }\n    }\n\n    this.coolingCycle++;\n\n    if (this.layoutQuality == 0) {\n      // quality - \"draft\"\n      this.coolingAdjuster = this.coolingCycle;\n    } else if (this.layoutQuality == 1) {\n      // quality - \"default\"\n      this.coolingAdjuster = this.coolingCycle / 3;\n    }\n\n    // cooling schedule is based on http://www.btluke.com/simanf1.html -> cooling schedule 3\n    this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature);\n    this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));\n  }\n  // Operations while tree is growing again \n  if (this.isTreeGrowing) {\n    if (this.growTreeIterations % 10 == 0) {\n      if (this.prunedNodesAll.length > 0) {\n        this.graphManager.updateBounds();\n        this.updateGrid();\n        this.growTree(this.prunedNodesAll);\n        // Update nodes that gravity will be applied\n        this.graphManager.resetAllNodesToApplyGravitation();\n        var allNodes = new Set(this.getAllNodes());\n        var intersection = this.nodesWithGravity.filter(function (x) {\n          return allNodes.has(x);\n        });\n        this.graphManager.setAllNodesToApplyGravitation(intersection);\n\n        this.graphManager.updateBounds();\n        this.updateGrid();\n        if (CoSEConstants.PURE_INCREMENTAL) this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2;else this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n      } else {\n        this.isTreeGrowing = false;\n        this.isGrowthFinished = true;\n      }\n    }\n    this.growTreeIterations++;\n  }\n  // Operations after growth is finished\n  if (this.isGrowthFinished) {\n    if (this.isConverged()) {\n      return true;\n    }\n    if (this.afterGrowthIterations % 10 == 0) {\n      this.graphManager.updateBounds();\n      this.updateGrid();\n    }\n    if (CoSEConstants.PURE_INCREMENTAL) this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2 * ((100 - this.afterGrowthIterations) / 100);else this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100);\n    this.afterGrowthIterations++;\n  }\n\n  var gridUpdateAllowed = !this.isTreeGrowing && !this.isGrowthFinished;\n  var forceToNodeSurroundingUpdate = this.growTreeIterations % 10 == 1 && this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 && this.isGrowthFinished;\n\n  this.totalDisplacement = 0;\n  this.graphManager.updateBounds();\n  this.calcSpringForces();\n  this.calcRepulsionForces(gridUpdateAllowed, forceToNodeSurroundingUpdate);\n  this.calcGravitationalForces();\n  this.moveNodes();\n  this.animate();\n\n  return false; // Layout is not ended yet return false\n};\n\nCoSELayout.prototype.getPositionsData = function () {\n  var allNodes = this.graphManager.getAllNodes();\n  var pData = {};\n  for (var i = 0; i < allNodes.length; i++) {\n    var rect = allNodes[i].rect;\n    var id = allNodes[i].id;\n    pData[id] = {\n      id: id,\n      x: rect.getCenterX(),\n      y: rect.getCenterY(),\n      w: rect.width,\n      h: rect.height\n    };\n  }\n\n  return pData;\n};\n\nCoSELayout.prototype.runSpringEmbedder = function () {\n  this.initialAnimationPeriod = 25;\n  this.animationPeriod = this.initialAnimationPeriod;\n  var layoutEnded = false;\n\n  // If aminate option is 'during' signal that layout is supposed to start iterating\n  if (FDLayoutConstants.ANIMATE === 'during') {\n    this.emit('layoutstarted');\n  } else {\n    // If aminate option is 'during' tick() function will be called on index.js\n    while (!layoutEnded) {\n      layoutEnded = this.tick();\n    }\n\n    this.graphManager.updateBounds();\n  }\n};\n\n// overrides moveNodes method in FDLayout\nCoSELayout.prototype.moveNodes = function () {\n  var lNodes = this.getAllNodes();\n  var node;\n\n  // calculate displacement for each node \n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    node.calculateDisplacement();\n  }\n\n  if (Object.keys(this.constraints).length > 0) {\n    this.updateDisplacements();\n  }\n\n  // move each node\n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    node.move();\n  }\n};\n\n// constraint related methods: initConstraintVariables and updateDisplacements\n\n// initialize constraint related variables\nCoSELayout.prototype.initConstraintVariables = function () {\n  var self = this;\n  this.idToNodeMap = new Map();\n  this.fixedNodeSet = new Set();\n\n  var allNodes = this.graphManager.getAllNodes();\n\n  // fill idToNodeMap\n  for (var i = 0; i < allNodes.length; i++) {\n    var node = allNodes[i];\n    this.idToNodeMap.set(node.id, node);\n  }\n\n  // calculate fixed node weight for given compound node\n  var calculateCompoundWeight = function calculateCompoundWeight(compoundNode) {\n    var nodes = compoundNode.getChild().getNodes();\n    var node;\n    var fixedNodeWeight = 0;\n    for (var i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n      if (node.getChild() == null) {\n        if (self.fixedNodeSet.has(node.id)) {\n          fixedNodeWeight += 100;\n        }\n      } else {\n        fixedNodeWeight += calculateCompoundWeight(node);\n      }\n    }\n    return fixedNodeWeight;\n  };\n\n  if (this.constraints.fixedNodeConstraint) {\n    // fill fixedNodeSet\n    this.constraints.fixedNodeConstraint.forEach(function (nodeData) {\n      self.fixedNodeSet.add(nodeData.nodeId);\n    });\n\n    // assign fixed node weights to compounds if they contain fixed nodes\n    var allNodes = this.graphManager.getAllNodes();\n    var node;\n\n    for (var i = 0; i < allNodes.length; i++) {\n      node = allNodes[i];\n      if (node.getChild() != null) {\n        var fixedNodeWeight = calculateCompoundWeight(node);\n        if (fixedNodeWeight > 0) {\n          node.fixedNodeWeight = fixedNodeWeight;\n        }\n      }\n    }\n  }\n\n  if (this.constraints.relativePlacementConstraint) {\n    var nodeToDummyForVerticalAlignment = new Map();\n    var nodeToDummyForHorizontalAlignment = new Map();\n    this.dummyToNodeForVerticalAlignment = new Map();\n    this.dummyToNodeForHorizontalAlignment = new Map();\n    this.fixedNodesOnHorizontal = new Set();\n    this.fixedNodesOnVertical = new Set();\n\n    // fill maps and sets\n    this.fixedNodeSet.forEach(function (nodeId) {\n      self.fixedNodesOnHorizontal.add(nodeId);\n      self.fixedNodesOnVertical.add(nodeId);\n    });\n\n    if (this.constraints.alignmentConstraint) {\n      if (this.constraints.alignmentConstraint.vertical) {\n        var verticalAlignment = this.constraints.alignmentConstraint.vertical;\n        for (var i = 0; i < verticalAlignment.length; i++) {\n          this.dummyToNodeForVerticalAlignment.set(\"dummy\" + i, []);\n          verticalAlignment[i].forEach(function (nodeId) {\n            nodeToDummyForVerticalAlignment.set(nodeId, \"dummy\" + i);\n            self.dummyToNodeForVerticalAlignment.get(\"dummy\" + i).push(nodeId);\n            if (self.fixedNodeSet.has(nodeId)) {\n              self.fixedNodesOnHorizontal.add(\"dummy\" + i);\n            }\n          });\n        }\n      }\n      if (this.constraints.alignmentConstraint.horizontal) {\n        var horizontalAlignment = this.constraints.alignmentConstraint.horizontal;\n        for (var i = 0; i < horizontalAlignment.length; i++) {\n          this.dummyToNodeForHorizontalAlignment.set(\"dummy\" + i, []);\n          horizontalAlignment[i].forEach(function (nodeId) {\n            nodeToDummyForHorizontalAlignment.set(nodeId, \"dummy\" + i);\n            self.dummyToNodeForHorizontalAlignment.get(\"dummy\" + i).push(nodeId);\n            if (self.fixedNodeSet.has(nodeId)) {\n              self.fixedNodesOnVertical.add(\"dummy\" + i);\n            }\n          });\n        }\n      }\n    }\n\n    if (CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS) {\n\n      this.shuffle = function (array) {\n        var j, x, i;\n        for (i = array.length - 1; i >= 2 * array.length / 3; i--) {\n          j = Math.floor(Math.random() * (i + 1));\n          x = array[i];\n          array[i] = array[j];\n          array[j] = x;\n        }\n        return array;\n      };\n\n      this.nodesInRelativeHorizontal = [];\n      this.nodesInRelativeVertical = [];\n      this.nodeToRelativeConstraintMapHorizontal = new Map();\n      this.nodeToRelativeConstraintMapVertical = new Map();\n      this.nodeToTempPositionMapHorizontal = new Map();\n      this.nodeToTempPositionMapVertical = new Map();\n\n      // fill arrays and maps\n      this.constraints.relativePlacementConstraint.forEach(function (constraint) {\n        if (constraint.left) {\n          var nodeIdLeft = nodeToDummyForVerticalAlignment.has(constraint.left) ? nodeToDummyForVerticalAlignment.get(constraint.left) : constraint.left;\n          var nodeIdRight = nodeToDummyForVerticalAlignment.has(constraint.right) ? nodeToDummyForVerticalAlignment.get(constraint.right) : constraint.right;\n\n          if (!self.nodesInRelativeHorizontal.includes(nodeIdLeft)) {\n            self.nodesInRelativeHorizontal.push(nodeIdLeft);\n            self.nodeToRelativeConstraintMapHorizontal.set(nodeIdLeft, []);\n            if (self.dummyToNodeForVerticalAlignment.has(nodeIdLeft)) {\n              self.nodeToTempPositionMapHorizontal.set(nodeIdLeft, self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeIdLeft)[0]).getCenterX());\n            } else {\n              self.nodeToTempPositionMapHorizontal.set(nodeIdLeft, self.idToNodeMap.get(nodeIdLeft).getCenterX());\n            }\n          }\n          if (!self.nodesInRelativeHorizontal.includes(nodeIdRight)) {\n            self.nodesInRelativeHorizontal.push(nodeIdRight);\n            self.nodeToRelativeConstraintMapHorizontal.set(nodeIdRight, []);\n            if (self.dummyToNodeForVerticalAlignment.has(nodeIdRight)) {\n              self.nodeToTempPositionMapHorizontal.set(nodeIdRight, self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeIdRight)[0]).getCenterX());\n            } else {\n              self.nodeToTempPositionMapHorizontal.set(nodeIdRight, self.idToNodeMap.get(nodeIdRight).getCenterX());\n            }\n          }\n\n          self.nodeToRelativeConstraintMapHorizontal.get(nodeIdLeft).push({ right: nodeIdRight, gap: constraint.gap });\n          self.nodeToRelativeConstraintMapHorizontal.get(nodeIdRight).push({ left: nodeIdLeft, gap: constraint.gap });\n        } else {\n          var nodeIdTop = nodeToDummyForHorizontalAlignment.has(constraint.top) ? nodeToDummyForHorizontalAlignment.get(constraint.top) : constraint.top;\n          var nodeIdBottom = nodeToDummyForHorizontalAlignment.has(constraint.bottom) ? nodeToDummyForHorizontalAlignment.get(constraint.bottom) : constraint.bottom;\n\n          if (!self.nodesInRelativeVertical.includes(nodeIdTop)) {\n            self.nodesInRelativeVertical.push(nodeIdTop);\n            self.nodeToRelativeConstraintMapVertical.set(nodeIdTop, []);\n            if (self.dummyToNodeForHorizontalAlignment.has(nodeIdTop)) {\n              self.nodeToTempPositionMapVertical.set(nodeIdTop, self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeIdTop)[0]).getCenterY());\n            } else {\n              self.nodeToTempPositionMapVertical.set(nodeIdTop, self.idToNodeMap.get(nodeIdTop).getCenterY());\n            }\n          }\n          if (!self.nodesInRelativeVertical.includes(nodeIdBottom)) {\n            self.nodesInRelativeVertical.push(nodeIdBottom);\n            self.nodeToRelativeConstraintMapVertical.set(nodeIdBottom, []);\n            if (self.dummyToNodeForHorizontalAlignment.has(nodeIdBottom)) {\n              self.nodeToTempPositionMapVertical.set(nodeIdBottom, self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeIdBottom)[0]).getCenterY());\n            } else {\n              self.nodeToTempPositionMapVertical.set(nodeIdBottom, self.idToNodeMap.get(nodeIdBottom).getCenterY());\n            }\n          }\n          self.nodeToRelativeConstraintMapVertical.get(nodeIdTop).push({ bottom: nodeIdBottom, gap: constraint.gap });\n          self.nodeToRelativeConstraintMapVertical.get(nodeIdBottom).push({ top: nodeIdTop, gap: constraint.gap });\n        }\n      });\n    } else {\n      var subGraphOnHorizontal = new Map(); // subgraph from vertical RP constraints\n      var subGraphOnVertical = new Map(); // subgraph from vertical RP constraints\n\n      // construct subgraphs from relative placement constraints \n      this.constraints.relativePlacementConstraint.forEach(function (constraint) {\n        if (constraint.left) {\n          var left = nodeToDummyForVerticalAlignment.has(constraint.left) ? nodeToDummyForVerticalAlignment.get(constraint.left) : constraint.left;\n          var right = nodeToDummyForVerticalAlignment.has(constraint.right) ? nodeToDummyForVerticalAlignment.get(constraint.right) : constraint.right;\n          if (subGraphOnHorizontal.has(left)) {\n            subGraphOnHorizontal.get(left).push(right);\n          } else {\n            subGraphOnHorizontal.set(left, [right]);\n          }\n          if (subGraphOnHorizontal.has(right)) {\n            subGraphOnHorizontal.get(right).push(left);\n          } else {\n            subGraphOnHorizontal.set(right, [left]);\n          }\n        } else {\n          var top = nodeToDummyForHorizontalAlignment.has(constraint.top) ? nodeToDummyForHorizontalAlignment.get(constraint.top) : constraint.top;\n          var bottom = nodeToDummyForHorizontalAlignment.has(constraint.bottom) ? nodeToDummyForHorizontalAlignment.get(constraint.bottom) : constraint.bottom;\n          if (subGraphOnVertical.has(top)) {\n            subGraphOnVertical.get(top).push(bottom);\n          } else {\n            subGraphOnVertical.set(top, [bottom]);\n          }\n          if (subGraphOnVertical.has(bottom)) {\n            subGraphOnVertical.get(bottom).push(top);\n          } else {\n            subGraphOnVertical.set(bottom, [top]);\n          }\n        }\n      });\n\n      // function to construct components from a given graph \n      // also returns an array that keeps whether each component contains fixed node\n      var constructComponents = function constructComponents(graph, fixedNodes) {\n        var components = [];\n        var isFixed = [];\n        var queue = new LinkedList();\n        var visited = new Set();\n        var count = 0;\n\n        graph.forEach(function (value, key) {\n          if (!visited.has(key)) {\n            components[count] = [];\n            isFixed[count] = false;\n            var currentNode = key;\n            queue.push(currentNode);\n            visited.add(currentNode);\n            components[count].push(currentNode);\n\n            while (queue.length != 0) {\n              currentNode = queue.shift();\n              if (fixedNodes.has(currentNode)) {\n                isFixed[count] = true;\n              }\n              var neighbors = graph.get(currentNode);\n              neighbors.forEach(function (neighbor) {\n                if (!visited.has(neighbor)) {\n                  queue.push(neighbor);\n                  visited.add(neighbor);\n                  components[count].push(neighbor);\n                }\n              });\n            }\n            count++;\n          }\n        });\n\n        return { components: components, isFixed: isFixed };\n      };\n\n      var resultOnHorizontal = constructComponents(subGraphOnHorizontal, self.fixedNodesOnHorizontal);\n      this.componentsOnHorizontal = resultOnHorizontal.components;\n      this.fixedComponentsOnHorizontal = resultOnHorizontal.isFixed;\n      var resultOnVertical = constructComponents(subGraphOnVertical, self.fixedNodesOnVertical);\n      this.componentsOnVertical = resultOnVertical.components;\n      this.fixedComponentsOnVertical = resultOnVertical.isFixed;\n    }\n  }\n};\n\n// updates node displacements based on constraints\nCoSELayout.prototype.updateDisplacements = function () {\n  var self = this;\n  if (this.constraints.fixedNodeConstraint) {\n    this.constraints.fixedNodeConstraint.forEach(function (nodeData) {\n      var fixedNode = self.idToNodeMap.get(nodeData.nodeId);\n      fixedNode.displacementX = 0;\n      fixedNode.displacementY = 0;\n    });\n  }\n\n  if (this.constraints.alignmentConstraint) {\n    if (this.constraints.alignmentConstraint.vertical) {\n      var allVerticalAlignments = this.constraints.alignmentConstraint.vertical;\n      for (var i = 0; i < allVerticalAlignments.length; i++) {\n        var totalDisplacementX = 0;\n        for (var j = 0; j < allVerticalAlignments[i].length; j++) {\n          if (this.fixedNodeSet.has(allVerticalAlignments[i][j])) {\n            totalDisplacementX = 0;\n            break;\n          }\n          totalDisplacementX += this.idToNodeMap.get(allVerticalAlignments[i][j]).displacementX;\n        }\n        var averageDisplacementX = totalDisplacementX / allVerticalAlignments[i].length;\n        for (var j = 0; j < allVerticalAlignments[i].length; j++) {\n          this.idToNodeMap.get(allVerticalAlignments[i][j]).displacementX = averageDisplacementX;\n        }\n      }\n    }\n    if (this.constraints.alignmentConstraint.horizontal) {\n      var allHorizontalAlignments = this.constraints.alignmentConstraint.horizontal;\n      for (var i = 0; i < allHorizontalAlignments.length; i++) {\n        var totalDisplacementY = 0;\n        for (var j = 0; j < allHorizontalAlignments[i].length; j++) {\n          if (this.fixedNodeSet.has(allHorizontalAlignments[i][j])) {\n            totalDisplacementY = 0;\n            break;\n          }\n          totalDisplacementY += this.idToNodeMap.get(allHorizontalAlignments[i][j]).displacementY;\n        }\n        var averageDisplacementY = totalDisplacementY / allHorizontalAlignments[i].length;\n        for (var j = 0; j < allHorizontalAlignments[i].length; j++) {\n          this.idToNodeMap.get(allHorizontalAlignments[i][j]).displacementY = averageDisplacementY;\n        }\n      }\n    }\n  }\n\n  if (this.constraints.relativePlacementConstraint) {\n\n    if (CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS) {\n      // shuffle array to randomize node processing order\n      if (this.totalIterations % 10 == 0) {\n        this.shuffle(this.nodesInRelativeHorizontal);\n        this.shuffle(this.nodesInRelativeVertical);\n      }\n\n      this.nodesInRelativeHorizontal.forEach(function (nodeId) {\n        if (!self.fixedNodesOnHorizontal.has(nodeId)) {\n          var displacement = 0;\n          if (self.dummyToNodeForVerticalAlignment.has(nodeId)) {\n            displacement = self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeId)[0]).displacementX;\n          } else {\n            displacement = self.idToNodeMap.get(nodeId).displacementX;\n          }\n          self.nodeToRelativeConstraintMapHorizontal.get(nodeId).forEach(function (constraint) {\n            if (constraint.right) {\n              var diff = self.nodeToTempPositionMapHorizontal.get(constraint.right) - self.nodeToTempPositionMapHorizontal.get(nodeId) - displacement;\n              if (diff < constraint.gap) {\n                displacement -= constraint.gap - diff;\n              }\n            } else {\n              var diff = self.nodeToTempPositionMapHorizontal.get(nodeId) - self.nodeToTempPositionMapHorizontal.get(constraint.left) + displacement;\n              if (diff < constraint.gap) {\n                displacement += constraint.gap - diff;\n              }\n            }\n          });\n          self.nodeToTempPositionMapHorizontal.set(nodeId, self.nodeToTempPositionMapHorizontal.get(nodeId) + displacement);\n          if (self.dummyToNodeForVerticalAlignment.has(nodeId)) {\n            self.dummyToNodeForVerticalAlignment.get(nodeId).forEach(function (nodeId) {\n              self.idToNodeMap.get(nodeId).displacementX = displacement;\n            });\n          } else {\n            self.idToNodeMap.get(nodeId).displacementX = displacement;\n          }\n        }\n      });\n\n      this.nodesInRelativeVertical.forEach(function (nodeId) {\n        if (!self.fixedNodesOnHorizontal.has(nodeId)) {\n          var displacement = 0;\n          if (self.dummyToNodeForHorizontalAlignment.has(nodeId)) {\n            displacement = self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeId)[0]).displacementY;\n          } else {\n            displacement = self.idToNodeMap.get(nodeId).displacementY;\n          }\n          self.nodeToRelativeConstraintMapVertical.get(nodeId).forEach(function (constraint) {\n            if (constraint.bottom) {\n              var diff = self.nodeToTempPositionMapVertical.get(constraint.bottom) - self.nodeToTempPositionMapVertical.get(nodeId) - displacement;\n              if (diff < constraint.gap) {\n                displacement -= constraint.gap - diff;\n              }\n            } else {\n              var diff = self.nodeToTempPositionMapVertical.get(nodeId) - self.nodeToTempPositionMapVertical.get(constraint.top) + displacement;\n              if (diff < constraint.gap) {\n                displacement += constraint.gap - diff;\n              }\n            }\n          });\n          self.nodeToTempPositionMapVertical.set(nodeId, self.nodeToTempPositionMapVertical.get(nodeId) + displacement);\n          if (self.dummyToNodeForHorizontalAlignment.has(nodeId)) {\n            self.dummyToNodeForHorizontalAlignment.get(nodeId).forEach(function (nodeId) {\n              self.idToNodeMap.get(nodeId).displacementY = displacement;\n            });\n          } else {\n            self.idToNodeMap.get(nodeId).displacementY = displacement;\n          }\n        }\n      });\n    } else {\n      for (var i = 0; i < this.componentsOnHorizontal.length; i++) {\n        var component = this.componentsOnHorizontal[i];\n        if (this.fixedComponentsOnHorizontal[i]) {\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n              this.dummyToNodeForVerticalAlignment.get(component[j]).forEach(function (nodeId) {\n                self.idToNodeMap.get(nodeId).displacementX = 0;\n              });\n            } else {\n              this.idToNodeMap.get(component[j]).displacementX = 0;\n            }\n          }\n        } else {\n          var sum = 0;\n          var count = 0;\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n              var actualNodes = this.dummyToNodeForVerticalAlignment.get(component[j]);\n              sum += actualNodes.length * this.idToNodeMap.get(actualNodes[0]).displacementX;\n              count += actualNodes.length;\n            } else {\n              sum += this.idToNodeMap.get(component[j]).displacementX;\n              count++;\n            }\n          }\n          var averageDisplacement = sum / count;\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForVerticalAlignment.has(component[j])) {\n              this.dummyToNodeForVerticalAlignment.get(component[j]).forEach(function (nodeId) {\n                self.idToNodeMap.get(nodeId).displacementX = averageDisplacement;\n              });\n            } else {\n              this.idToNodeMap.get(component[j]).displacementX = averageDisplacement;\n            }\n          }\n        }\n      }\n\n      for (var i = 0; i < this.componentsOnVertical.length; i++) {\n        var component = this.componentsOnVertical[i];\n        if (this.fixedComponentsOnVertical[i]) {\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n              this.dummyToNodeForHorizontalAlignment.get(component[j]).forEach(function (nodeId) {\n                self.idToNodeMap.get(nodeId).displacementY = 0;\n              });\n            } else {\n              this.idToNodeMap.get(component[j]).displacementY = 0;\n            }\n          }\n        } else {\n          var sum = 0;\n          var count = 0;\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n              var actualNodes = this.dummyToNodeForHorizontalAlignment.get(component[j]);\n              sum += actualNodes.length * this.idToNodeMap.get(actualNodes[0]).displacementY;\n              count += actualNodes.length;\n            } else {\n              sum += this.idToNodeMap.get(component[j]).displacementY;\n              count++;\n            }\n          }\n          var averageDisplacement = sum / count;\n          for (var j = 0; j < component.length; j++) {\n            if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {\n              this.dummyToNodeForHorizontalAlignment.get(component[j]).forEach(function (nodeId) {\n                self.idToNodeMap.get(nodeId).displacementY = averageDisplacement;\n              });\n            } else {\n              this.idToNodeMap.get(component[j]).displacementY = averageDisplacement;\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nCoSELayout.prototype.calculateNodesToApplyGravitationTo = function () {\n  var nodeList = [];\n  var graph;\n\n  var graphs = this.graphManager.getGraphs();\n  var size = graphs.length;\n  var i;\n  for (i = 0; i < size; i++) {\n    graph = graphs[i];\n\n    graph.updateConnected();\n\n    if (!graph.isConnected) {\n      nodeList = nodeList.concat(graph.getNodes());\n    }\n  }\n\n  return nodeList;\n};\n\nCoSELayout.prototype.createBendpoints = function () {\n  var edges = [];\n  edges = edges.concat(this.graphManager.getAllEdges());\n  var visited = new Set();\n  var i;\n  for (i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n\n    if (!visited.has(edge)) {\n      var source = edge.getSource();\n      var target = edge.getTarget();\n\n      if (source == target) {\n        edge.getBendpoints().push(new PointD());\n        edge.getBendpoints().push(new PointD());\n        this.createDummyNodesForBendpoints(edge);\n        visited.add(edge);\n      } else {\n        var edgeList = [];\n\n        edgeList = edgeList.concat(source.getEdgeListToNode(target));\n        edgeList = edgeList.concat(target.getEdgeListToNode(source));\n\n        if (!visited.has(edgeList[0])) {\n          if (edgeList.length > 1) {\n            var k;\n            for (k = 0; k < edgeList.length; k++) {\n              var multiEdge = edgeList[k];\n              multiEdge.getBendpoints().push(new PointD());\n              this.createDummyNodesForBendpoints(multiEdge);\n            }\n          }\n          edgeList.forEach(function (edge) {\n            visited.add(edge);\n          });\n        }\n      }\n    }\n\n    if (visited.size == edges.length) {\n      break;\n    }\n  }\n};\n\nCoSELayout.prototype.positionNodesRadially = function (forest) {\n  // We tile the trees to a grid row by row; first tree starts at (0,0)\n  var currentStartingPoint = new Point(0, 0);\n  var numberOfColumns = Math.ceil(Math.sqrt(forest.length));\n  var height = 0;\n  var currentY = 0;\n  var currentX = 0;\n  var point = new PointD(0, 0);\n\n  for (var i = 0; i < forest.length; i++) {\n    if (i % numberOfColumns == 0) {\n      // Start of a new row, make the x coordinate 0, increment the\n      // y coordinate with the max height of the previous row\n      currentX = 0;\n      currentY = height;\n\n      if (i != 0) {\n        currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;\n      }\n\n      height = 0;\n    }\n\n    var tree = forest[i];\n\n    // Find the center of the tree\n    var centerNode = Layout.findCenterOfTree(tree);\n\n    // Set the staring point of the next tree\n    currentStartingPoint.x = currentX;\n    currentStartingPoint.y = currentY;\n\n    // Do a radial layout starting with the center\n    point = CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);\n\n    if (point.y > height) {\n      height = Math.floor(point.y);\n    }\n\n    currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);\n  }\n\n  this.transform(new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2, LayoutConstants.WORLD_CENTER_Y - point.y / 2));\n};\n\nCoSELayout.radialLayout = function (tree, centerNode, startingPoint) {\n  var radialSep = Math.max(this.maxDiagonalInTree(tree), CoSEConstants.DEFAULT_RADIAL_SEPARATION);\n  CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);\n  var bounds = LGraph.calculateBounds(tree);\n\n  var transform = new Transform();\n  transform.setDeviceOrgX(bounds.getMinX());\n  transform.setDeviceOrgY(bounds.getMinY());\n  transform.setWorldOrgX(startingPoint.x);\n  transform.setWorldOrgY(startingPoint.y);\n\n  for (var i = 0; i < tree.length; i++) {\n    var node = tree[i];\n    node.transform(transform);\n  }\n\n  var bottomRight = new PointD(bounds.getMaxX(), bounds.getMaxY());\n\n  return transform.inverseTransformPoint(bottomRight);\n};\n\nCoSELayout.branchRadialLayout = function (node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {\n  // First, position this node by finding its angle.\n  var halfInterval = (endAngle - startAngle + 1) / 2;\n\n  if (halfInterval < 0) {\n    halfInterval += 180;\n  }\n\n  var nodeAngle = (halfInterval + startAngle) % 360;\n  var teta = nodeAngle * IGeometry.TWO_PI / 360;\n\n  // Make polar to java cordinate conversion.\n  var cos_teta = Math.cos(teta);\n  var x_ = distance * Math.cos(teta);\n  var y_ = distance * Math.sin(teta);\n\n  node.setCenter(x_, y_);\n\n  // Traverse all neighbors of this node and recursively call this\n  // function.\n  var neighborEdges = [];\n  neighborEdges = neighborEdges.concat(node.getEdges());\n  var childCount = neighborEdges.length;\n\n  if (parentOfNode != null) {\n    childCount--;\n  }\n\n  var branchCount = 0;\n\n  var incEdgesCount = neighborEdges.length;\n  var startIndex;\n\n  var edges = node.getEdgesBetween(parentOfNode);\n\n  // If there are multiple edges, prune them until there remains only one\n  // edge.\n  while (edges.length > 1) {\n    //neighborEdges.remove(edges.remove(0));\n    var temp = edges[0];\n    edges.splice(0, 1);\n    var index = neighborEdges.indexOf(temp);\n    if (index >= 0) {\n      neighborEdges.splice(index, 1);\n    }\n    incEdgesCount--;\n    childCount--;\n  }\n\n  if (parentOfNode != null) {\n    //assert edges.length == 1;\n    startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;\n  } else {\n    startIndex = 0;\n  }\n\n  var stepAngle = Math.abs(endAngle - startAngle) / childCount;\n\n  for (var i = startIndex; branchCount != childCount; i = ++i % incEdgesCount) {\n    var currentNeighbor = neighborEdges[i].getOtherEnd(node);\n\n    // Don't back traverse to root node in current tree.\n    if (currentNeighbor == parentOfNode) {\n      continue;\n    }\n\n    var childStartAngle = (startAngle + branchCount * stepAngle) % 360;\n    var childEndAngle = (childStartAngle + stepAngle) % 360;\n\n    CoSELayout.branchRadialLayout(currentNeighbor, node, childStartAngle, childEndAngle, distance + radialSeparation, radialSeparation);\n\n    branchCount++;\n  }\n};\n\nCoSELayout.maxDiagonalInTree = function (tree) {\n  var maxDiagonal = Integer.MIN_VALUE;\n\n  for (var i = 0; i < tree.length; i++) {\n    var node = tree[i];\n    var diagonal = node.getDiagonal();\n\n    if (diagonal > maxDiagonal) {\n      maxDiagonal = diagonal;\n    }\n  }\n\n  return maxDiagonal;\n};\n\nCoSELayout.prototype.calcRepulsionRange = function () {\n  // formula is 2 x (level + 1) x idealEdgeLength\n  return 2 * (this.level + 1) * this.idealEdgeLength;\n};\n\n// Tiling methods\n\n// Group zero degree members whose parents are not to be tiled, create dummy parents where needed and fill memberGroups by their dummp parent id's\nCoSELayout.prototype.groupZeroDegreeMembers = function () {\n  var self = this;\n  // array of [parent_id x oneDegreeNode_id]\n  var tempMemberGroups = {}; // A temporary map of parent node and its zero degree members\n  this.memberGroups = {}; // A map of dummy parent node and its zero degree members whose parents are not to be tiled\n  this.idToDummyNode = {}; // A map of id to dummy node \n\n  var zeroDegree = []; // List of zero degree nodes whose parents are not to be tiled\n  var allNodes = this.graphManager.getAllNodes();\n\n  // Fill zero degree list\n  for (var i = 0; i < allNodes.length; i++) {\n    var node = allNodes[i];\n    var parent = node.getParent();\n    // If a node has zero degree and its parent is not to be tiled if exists add that node to zeroDegres list\n    if (this.getNodeDegreeWithChildren(node) === 0 && (parent.id == undefined || !this.getToBeTiled(parent))) {\n      zeroDegree.push(node);\n    }\n  }\n\n  // Create a map of parent node and its zero degree members\n  for (var i = 0; i < zeroDegree.length; i++) {\n    var node = zeroDegree[i]; // Zero degree node itself\n    var p_id = node.getParent().id; // Parent id\n\n    if (typeof tempMemberGroups[p_id] === \"undefined\") tempMemberGroups[p_id] = [];\n\n    tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node); // Push node to the list belongs to its parent in tempMemberGroups\n  }\n\n  // If there are at least two nodes at a level, create a dummy compound for them\n  Object.keys(tempMemberGroups).forEach(function (p_id) {\n    if (tempMemberGroups[p_id].length > 1) {\n      var dummyCompoundId = \"DummyCompound_\" + p_id; // The id of dummy compound which will be created soon\n      self.memberGroups[dummyCompoundId] = tempMemberGroups[p_id]; // Add dummy compound to memberGroups\n\n      var parent = tempMemberGroups[p_id][0].getParent(); // The parent of zero degree nodes will be the parent of new dummy compound\n\n      // Create a dummy compound with calculated id\n      var dummyCompound = new CoSENode(self.graphManager);\n      dummyCompound.id = dummyCompoundId;\n      dummyCompound.paddingLeft = parent.paddingLeft || 0;\n      dummyCompound.paddingRight = parent.paddingRight || 0;\n      dummyCompound.paddingBottom = parent.paddingBottom || 0;\n      dummyCompound.paddingTop = parent.paddingTop || 0;\n\n      self.idToDummyNode[dummyCompoundId] = dummyCompound;\n\n      var dummyParentGraph = self.getGraphManager().add(self.newGraph(), dummyCompound);\n      var parentGraph = parent.getChild();\n\n      // Add dummy compound to parent the graph\n      parentGraph.add(dummyCompound);\n\n      // For each zero degree node in this level remove it from its parent graph and add it to the graph of dummy parent\n      for (var i = 0; i < tempMemberGroups[p_id].length; i++) {\n        var node = tempMemberGroups[p_id][i];\n\n        parentGraph.remove(node);\n        dummyParentGraph.add(node);\n      }\n    }\n  });\n};\n\nCoSELayout.prototype.clearCompounds = function () {\n  var childGraphMap = {};\n  var idToNode = {};\n\n  // Get compound ordering by finding the inner one first\n  this.performDFSOnCompounds();\n\n  for (var i = 0; i < this.compoundOrder.length; i++) {\n\n    idToNode[this.compoundOrder[i].id] = this.compoundOrder[i];\n    childGraphMap[this.compoundOrder[i].id] = [].concat(this.compoundOrder[i].getChild().getNodes());\n\n    // Remove children of compounds\n    this.graphManager.remove(this.compoundOrder[i].getChild());\n    this.compoundOrder[i].child = null;\n  }\n\n  this.graphManager.resetAllNodes();\n\n  // Tile the removed children\n  this.tileCompoundMembers(childGraphMap, idToNode);\n};\n\nCoSELayout.prototype.clearZeroDegreeMembers = function () {\n  var self = this;\n  var tiledZeroDegreePack = this.tiledZeroDegreePack = [];\n\n  Object.keys(this.memberGroups).forEach(function (id) {\n    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound\n\n    tiledZeroDegreePack[id] = self.tileNodes(self.memberGroups[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n    // Set the width and height of the dummy compound as calculated\n    compoundNode.rect.width = tiledZeroDegreePack[id].width;\n    compoundNode.rect.height = tiledZeroDegreePack[id].height;\n    compoundNode.setCenter(tiledZeroDegreePack[id].centerX, tiledZeroDegreePack[id].centerY);\n\n    // compound left and top margings for labels\n    // when node labels are included, these values may be set to different values below and are used in tilingPostLayout,\n    // otherwise they stay as zero\n    compoundNode.labelMarginLeft = 0;\n    compoundNode.labelMarginTop = 0;\n\n    // Update compound bounds considering its label properties and set label margins for left and top\n    if (CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n\n      var width = compoundNode.rect.width;\n      var height = compoundNode.rect.height;\n\n      if (compoundNode.labelWidth) {\n        if (compoundNode.labelPosHorizontal == \"left\") {\n          compoundNode.rect.x -= compoundNode.labelWidth;\n          compoundNode.setWidth(width + compoundNode.labelWidth);\n          compoundNode.labelMarginLeft = compoundNode.labelWidth;\n        } else if (compoundNode.labelPosHorizontal == \"center\" && compoundNode.labelWidth > width) {\n          compoundNode.rect.x -= (compoundNode.labelWidth - width) / 2;\n          compoundNode.setWidth(compoundNode.labelWidth);\n          compoundNode.labelMarginLeft = (compoundNode.labelWidth - width) / 2;\n        } else if (compoundNode.labelPosHorizontal == \"right\") {\n          compoundNode.setWidth(width + compoundNode.labelWidth);\n        }\n      }\n\n      if (compoundNode.labelHeight) {\n        if (compoundNode.labelPosVertical == \"top\") {\n          compoundNode.rect.y -= compoundNode.labelHeight;\n          compoundNode.setHeight(height + compoundNode.labelHeight);\n          compoundNode.labelMarginTop = compoundNode.labelHeight;\n        } else if (compoundNode.labelPosVertical == \"center\" && compoundNode.labelHeight > height) {\n          compoundNode.rect.y -= (compoundNode.labelHeight - height) / 2;\n          compoundNode.setHeight(compoundNode.labelHeight);\n          compoundNode.labelMarginTop = (compoundNode.labelHeight - height) / 2;\n        } else if (compoundNode.labelPosVertical == \"bottom\") {\n          compoundNode.setHeight(height + compoundNode.labelHeight);\n        }\n      }\n    }\n  });\n};\n\nCoSELayout.prototype.repopulateCompounds = function () {\n  for (var i = this.compoundOrder.length - 1; i >= 0; i--) {\n    var lCompoundNode = this.compoundOrder[i];\n    var id = lCompoundNode.id;\n    var horizontalMargin = lCompoundNode.paddingLeft;\n    var verticalMargin = lCompoundNode.paddingTop;\n    var labelMarginLeft = lCompoundNode.labelMarginLeft;\n    var labelMarginTop = lCompoundNode.labelMarginTop;\n\n    this.adjustLocations(this.tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin, labelMarginLeft, labelMarginTop);\n  }\n};\n\nCoSELayout.prototype.repopulateZeroDegreeMembers = function () {\n  var self = this;\n  var tiledPack = this.tiledZeroDegreePack;\n\n  Object.keys(tiledPack).forEach(function (id) {\n    var compoundNode = self.idToDummyNode[id]; // Get the dummy compound by its id\n    var horizontalMargin = compoundNode.paddingLeft;\n    var verticalMargin = compoundNode.paddingTop;\n    var labelMarginLeft = compoundNode.labelMarginLeft;\n    var labelMarginTop = compoundNode.labelMarginTop;\n\n    // Adjust the positions of nodes wrt its compound\n    self.adjustLocations(tiledPack[id], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin, labelMarginLeft, labelMarginTop);\n  });\n};\n\nCoSELayout.prototype.getToBeTiled = function (node) {\n  var id = node.id;\n  //firstly check the previous results\n  if (this.toBeTiled[id] != null) {\n    return this.toBeTiled[id];\n  }\n\n  //only compound nodes are to be tiled\n  var childGraph = node.getChild();\n  if (childGraph == null) {\n    this.toBeTiled[id] = false;\n    return false;\n  }\n\n  var children = childGraph.getNodes(); // Get the children nodes\n\n  //a compound node is not to be tiled if all of its compound children are not to be tiled\n  for (var i = 0; i < children.length; i++) {\n    var theChild = children[i];\n\n    if (this.getNodeDegree(theChild) > 0) {\n      this.toBeTiled[id] = false;\n      return false;\n    }\n\n    //pass the children not having the compound structure\n    if (theChild.getChild() == null) {\n      this.toBeTiled[theChild.id] = false;\n      continue;\n    }\n\n    if (!this.getToBeTiled(theChild)) {\n      this.toBeTiled[id] = false;\n      return false;\n    }\n  }\n  this.toBeTiled[id] = true;\n  return true;\n};\n\n// Get degree of a node depending of its edges and independent of its children\nCoSELayout.prototype.getNodeDegree = function (node) {\n  var id = node.id;\n  var edges = node.getEdges();\n  var degree = 0;\n\n  // For the edges connected\n  for (var i = 0; i < edges.length; i++) {\n    var edge = edges[i];\n    if (edge.getSource().id !== edge.getTarget().id) {\n      degree = degree + 1;\n    }\n  }\n  return degree;\n};\n\n// Get degree of a node with its children\nCoSELayout.prototype.getNodeDegreeWithChildren = function (node) {\n  var degree = this.getNodeDegree(node);\n  if (node.getChild() == null) {\n    return degree;\n  }\n  var children = node.getChild().getNodes();\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    degree += this.getNodeDegreeWithChildren(child);\n  }\n  return degree;\n};\n\nCoSELayout.prototype.performDFSOnCompounds = function () {\n  this.compoundOrder = [];\n  this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());\n};\n\nCoSELayout.prototype.fillCompexOrderByDFS = function (children) {\n  for (var i = 0; i < children.length; i++) {\n    var child = children[i];\n    if (child.getChild() != null) {\n      this.fillCompexOrderByDFS(child.getChild().getNodes());\n    }\n    if (this.getToBeTiled(child)) {\n      this.compoundOrder.push(child);\n    }\n  }\n};\n\n/**\n* This method places each zero degree member wrt given (x,y) coordinates (top left).\n*/\nCoSELayout.prototype.adjustLocations = function (organization, x, y, compoundHorizontalMargin, compoundVerticalMargin, compoundLabelMarginLeft, compoundLabelMarginTop) {\n  x += compoundHorizontalMargin + compoundLabelMarginLeft;\n  y += compoundVerticalMargin + compoundLabelMarginTop;\n\n  var left = x;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n    var row = organization.rows[i];\n    x = left;\n    var maxHeight = 0;\n\n    for (var j = 0; j < row.length; j++) {\n      var lnode = row[j];\n\n      lnode.rect.x = x; // + lnode.rect.width / 2;\n      lnode.rect.y = y; // + lnode.rect.height / 2;\n\n      x += lnode.rect.width + organization.horizontalPadding;\n\n      if (lnode.rect.height > maxHeight) maxHeight = lnode.rect.height;\n    }\n\n    y += maxHeight + organization.verticalPadding;\n  }\n};\n\nCoSELayout.prototype.tileCompoundMembers = function (childGraphMap, idToNode) {\n  var self = this;\n  this.tiledMemberPack = [];\n\n  Object.keys(childGraphMap).forEach(function (id) {\n    // Get the compound node\n    var compoundNode = idToNode[id];\n\n    self.tiledMemberPack[id] = self.tileNodes(childGraphMap[id], compoundNode.paddingLeft + compoundNode.paddingRight);\n\n    compoundNode.rect.width = self.tiledMemberPack[id].width;\n    compoundNode.rect.height = self.tiledMemberPack[id].height;\n    compoundNode.setCenter(self.tiledMemberPack[id].centerX, self.tiledMemberPack[id].centerY);\n\n    // compound left and top margings for labels\n    // when node labels are included, these values may be set to different values below and are used in tilingPostLayout,\n    // otherwise they stay as zero\n    compoundNode.labelMarginLeft = 0;\n    compoundNode.labelMarginTop = 0;\n\n    // Update compound bounds considering its label properties and set label margins for left and top\n    if (CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n\n      var width = compoundNode.rect.width;\n      var height = compoundNode.rect.height;\n\n      if (compoundNode.labelWidth) {\n        if (compoundNode.labelPosHorizontal == \"left\") {\n          compoundNode.rect.x -= compoundNode.labelWidth;\n          compoundNode.setWidth(width + compoundNode.labelWidth);\n          compoundNode.labelMarginLeft = compoundNode.labelWidth;\n        } else if (compoundNode.labelPosHorizontal == \"center\" && compoundNode.labelWidth > width) {\n          compoundNode.rect.x -= (compoundNode.labelWidth - width) / 2;\n          compoundNode.setWidth(compoundNode.labelWidth);\n          compoundNode.labelMarginLeft = (compoundNode.labelWidth - width) / 2;\n        } else if (compoundNode.labelPosHorizontal == \"right\") {\n          compoundNode.setWidth(width + compoundNode.labelWidth);\n        }\n      }\n\n      if (compoundNode.labelHeight) {\n        if (compoundNode.labelPosVertical == \"top\") {\n          compoundNode.rect.y -= compoundNode.labelHeight;\n          compoundNode.setHeight(height + compoundNode.labelHeight);\n          compoundNode.labelMarginTop = compoundNode.labelHeight;\n        } else if (compoundNode.labelPosVertical == \"center\" && compoundNode.labelHeight > height) {\n          compoundNode.rect.y -= (compoundNode.labelHeight - height) / 2;\n          compoundNode.setHeight(compoundNode.labelHeight);\n          compoundNode.labelMarginTop = (compoundNode.labelHeight - height) / 2;\n        } else if (compoundNode.labelPosVertical == \"bottom\") {\n          compoundNode.setHeight(height + compoundNode.labelHeight);\n        }\n      }\n    }\n  });\n};\n\nCoSELayout.prototype.tileNodes = function (nodes, minWidth) {\n  var horizontalOrg = this.tileNodesByFavoringDim(nodes, minWidth, true);\n  var verticalOrg = this.tileNodesByFavoringDim(nodes, minWidth, false);\n\n  var horizontalRatio = this.getOrgRatio(horizontalOrg);\n  var verticalRatio = this.getOrgRatio(verticalOrg);\n  var bestOrg;\n\n  // the best ratio is the one that is closer to 1 since the ratios are already normalized\n  // and the best organization is the one that has the best ratio\n  if (verticalRatio < horizontalRatio) {\n    bestOrg = verticalOrg;\n  } else {\n    bestOrg = horizontalOrg;\n  }\n\n  return bestOrg;\n};\n\n// get the width/height ratio of the organization that is normalized so that it will not be less than 1\nCoSELayout.prototype.getOrgRatio = function (organization) {\n  // get dimensions and calculate the initial ratio\n  var width = organization.width;\n  var height = organization.height;\n  var ratio = width / height;\n\n  // if the initial ratio is less then 1 then inverse it\n  if (ratio < 1) {\n    ratio = 1 / ratio;\n  }\n\n  // return the normalized ratio\n  return ratio;\n};\n\n/*\n * Calculates the ideal width for the rows. This method assumes that\n * each node has the same sizes and calculates the ideal row width that\n * approximates a square shaped complex accordingly. However, since nodes would\n * have different sizes some rows would have different sizes and the resulting\n * shape would not be an exact square.\n */\nCoSELayout.prototype.calcIdealRowWidth = function (members, favorHorizontalDim) {\n  // To approximate a square shaped complex we need to make complex width equal to complex height.\n  // To achieve this we need to solve the following equation system for hc:\n  // (x + bx) * hc - bx = (y + by) * vc - by, hc * vc = n\n  // where x is the avarage width of the nodes, y is the avarage height of nodes\n  // bx and by are the buffer sizes in horizontal and vertical dimensions accordingly,\n  // hc and vc are the number of rows in horizontal and vertical dimensions\n  // n is number of members.\n\n  var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n  var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n\n  // number of members\n  var membersSize = members.length;\n\n  // sum of the width of all members\n  var totalWidth = 0;\n\n  // sum of the height of all members\n  var totalHeight = 0;\n\n  var maxWidth = 0;\n\n  // traverse all members to calculate total width and total height and get the maximum members width\n  members.forEach(function (node) {\n    totalWidth += node.getWidth();\n    totalHeight += node.getHeight();\n\n    if (node.getWidth() > maxWidth) {\n      maxWidth = node.getWidth();\n    }\n  });\n\n  // average width of the members\n  var averageWidth = totalWidth / membersSize;\n\n  // average height of the members\n  var averageHeight = totalHeight / membersSize;\n\n  // solving the initial equation system for the hc yields the following second degree equation:\n  // hc^2 * (x+bx) + hc * (by - bx) - n * (y + by) = 0\n\n  // the delta value to solve the equation above for hc\n  var delta = Math.pow(verticalPadding - horizontalPadding, 2) + 4 * (averageWidth + horizontalPadding) * (averageHeight + verticalPadding) * membersSize;\n\n  // solve the equation using delta value to calculate the horizontal count\n  // that represents the number of nodes in an ideal row\n  var horizontalCountDouble = (horizontalPadding - verticalPadding + Math.sqrt(delta)) / (2 * (averageWidth + horizontalPadding));\n  // round the calculated horizontal count up or down according to the favored dimension\n  var horizontalCount;\n\n  if (favorHorizontalDim) {\n    horizontalCount = Math.ceil(horizontalCountDouble);\n    // if horizontalCount count is not a float value then both of rounding to floor and ceil\n    // will yield the same values. Instead of repeating the same calculation try going up\n    // while favoring horizontal dimension in such cases\n    if (horizontalCount == horizontalCountDouble) {\n      horizontalCount++;\n    }\n  } else {\n    horizontalCount = Math.floor(horizontalCountDouble);\n  }\n\n  // ideal width to be calculated\n  var idealWidth = horizontalCount * (averageWidth + horizontalPadding) - horizontalPadding;\n\n  // if max width is bigger than calculated ideal width reset ideal width to it\n  if (maxWidth > idealWidth) {\n    idealWidth = maxWidth;\n  }\n\n  // add the left-right margins to the ideal row width\n  idealWidth += horizontalPadding * 2;\n\n  // return the ideal row width1\n  return idealWidth;\n};\n\nCoSELayout.prototype.tileNodesByFavoringDim = function (nodes, minWidth, favorHorizontalDim) {\n  var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;\n  var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;\n  var tilingCompareBy = CoSEConstants.TILING_COMPARE_BY;\n  var organization = {\n    rows: [],\n    rowWidth: [],\n    rowHeight: [],\n    width: 0,\n    height: minWidth, // assume minHeight equals to minWidth\n    verticalPadding: verticalPadding,\n    horizontalPadding: horizontalPadding,\n    centerX: 0,\n    centerY: 0\n  };\n\n  if (tilingCompareBy) {\n    organization.idealRowWidth = this.calcIdealRowWidth(nodes, favorHorizontalDim);\n  }\n\n  var getNodeArea = function getNodeArea(n) {\n    return n.rect.width * n.rect.height;\n  };\n\n  var areaCompareFcn = function areaCompareFcn(n1, n2) {\n    return getNodeArea(n2) - getNodeArea(n1);\n  };\n\n  // Sort the nodes in descending order of their areas\n  nodes.sort(function (n1, n2) {\n    var cmpBy = areaCompareFcn;\n    if (organization.idealRowWidth) {\n      cmpBy = tilingCompareBy;\n      return cmpBy(n1.id, n2.id);\n    }\n    return cmpBy(n1, n2);\n  });\n\n  // Create the organization -> calculate compound center\n  var sumCenterX = 0;\n  var sumCenterY = 0;\n  for (var i = 0; i < nodes.length; i++) {\n    var lNode = nodes[i];\n\n    sumCenterX += lNode.getCenterX();\n    sumCenterY += lNode.getCenterY();\n  }\n\n  organization.centerX = sumCenterX / nodes.length;\n  organization.centerY = sumCenterY / nodes.length;\n\n  // Create the organization -> tile members\n  for (var i = 0; i < nodes.length; i++) {\n    var lNode = nodes[i];\n\n    if (organization.rows.length == 0) {\n      this.insertNodeToRow(organization, lNode, 0, minWidth);\n    } else if (this.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) {\n      var rowIndex = organization.rows.length - 1;\n      if (!organization.idealRowWidth) {\n        rowIndex = this.getShortestRowIndex(organization);\n      }\n      this.insertNodeToRow(organization, lNode, rowIndex, minWidth);\n    } else {\n      this.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);\n    }\n\n    this.shiftToLastRow(organization);\n  }\n\n  return organization;\n};\n\nCoSELayout.prototype.insertNodeToRow = function (organization, node, rowIndex, minWidth) {\n  var minCompoundSize = minWidth;\n\n  // Add new row if needed\n  if (rowIndex == organization.rows.length) {\n    var secondDimension = [];\n\n    organization.rows.push(secondDimension);\n    organization.rowWidth.push(minCompoundSize);\n    organization.rowHeight.push(0);\n  }\n\n  // Update row width\n  var w = organization.rowWidth[rowIndex] + node.rect.width;\n\n  if (organization.rows[rowIndex].length > 0) {\n    w += organization.horizontalPadding;\n  }\n\n  organization.rowWidth[rowIndex] = w;\n  // Update compound width\n  if (organization.width < w) {\n    organization.width = w;\n  }\n\n  // Update height\n  var h = node.rect.height;\n  if (rowIndex > 0) h += organization.verticalPadding;\n\n  var extraHeight = 0;\n  if (h > organization.rowHeight[rowIndex]) {\n    extraHeight = organization.rowHeight[rowIndex];\n    organization.rowHeight[rowIndex] = h;\n    extraHeight = organization.rowHeight[rowIndex] - extraHeight;\n  }\n\n  organization.height += extraHeight;\n\n  // Insert node\n  organization.rows[rowIndex].push(node);\n};\n\n//Scans the rows of an organization and returns the one with the min width\nCoSELayout.prototype.getShortestRowIndex = function (organization) {\n  var r = -1;\n  var min = Number.MAX_VALUE;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n    if (organization.rowWidth[i] < min) {\n      r = i;\n      min = organization.rowWidth[i];\n    }\n  }\n  return r;\n};\n\n//Scans the rows of an organization and returns the one with the max width\nCoSELayout.prototype.getLongestRowIndex = function (organization) {\n  var r = -1;\n  var max = Number.MIN_VALUE;\n\n  for (var i = 0; i < organization.rows.length; i++) {\n\n    if (organization.rowWidth[i] > max) {\n      r = i;\n      max = organization.rowWidth[i];\n    }\n  }\n\n  return r;\n};\n\n/**\n* This method checks whether adding extra width to the organization violates\n* the aspect ratio(1) or not.\n*/\nCoSELayout.prototype.canAddHorizontal = function (organization, extraWidth, extraHeight) {\n\n  // if there is an ideal row width specified use it instead of checking the aspect ratio\n  if (organization.idealRowWidth) {\n    var lastRowIndex = organization.rows.length - 1;\n    var lastRowWidth = organization.rowWidth[lastRowIndex];\n\n    // check and return if ideal row width will be exceed if the node is added to the row\n    return lastRowWidth + extraWidth + organization.horizontalPadding <= organization.idealRowWidth;\n  }\n\n  var sri = this.getShortestRowIndex(organization);\n\n  if (sri < 0) {\n    return true;\n  }\n\n  var min = organization.rowWidth[sri];\n\n  if (min + organization.horizontalPadding + extraWidth <= organization.width) return true;\n\n  var hDiff = 0;\n\n  // Adding to an existing row\n  if (organization.rowHeight[sri] < extraHeight) {\n    if (sri > 0) hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];\n  }\n\n  var add_to_row_ratio;\n  if (organization.width - min >= extraWidth + organization.horizontalPadding) {\n    add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);\n  } else {\n    add_to_row_ratio = (organization.height + hDiff) / organization.width;\n  }\n\n  // Adding a new row for this node\n  hDiff = extraHeight + organization.verticalPadding;\n  var add_new_row_ratio;\n  if (organization.width < extraWidth) {\n    add_new_row_ratio = (organization.height + hDiff) / extraWidth;\n  } else {\n    add_new_row_ratio = (organization.height + hDiff) / organization.width;\n  }\n\n  if (add_new_row_ratio < 1) add_new_row_ratio = 1 / add_new_row_ratio;\n\n  if (add_to_row_ratio < 1) add_to_row_ratio = 1 / add_to_row_ratio;\n\n  return add_to_row_ratio < add_new_row_ratio;\n};\n\n//If moving the last node from the longest row and adding it to the last\n//row makes the bounding box smaller, do it.\nCoSELayout.prototype.shiftToLastRow = function (organization) {\n  var longest = this.getLongestRowIndex(organization);\n  var last = organization.rowWidth.length - 1;\n  var row = organization.rows[longest];\n  var node = row[row.length - 1];\n\n  var diff = node.width + organization.horizontalPadding;\n\n  // Check if there is enough space on the last row\n  if (organization.width - organization.rowWidth[last] > diff && longest != last) {\n    // Remove the last element of the longest row\n    row.splice(-1, 1);\n\n    // Push it to the last row\n    organization.rows[last].push(node);\n\n    organization.rowWidth[longest] = organization.rowWidth[longest] - diff;\n    organization.rowWidth[last] = organization.rowWidth[last] + diff;\n    organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)];\n\n    // Update heights of the organization\n    var maxHeight = Number.MIN_VALUE;\n    for (var i = 0; i < row.length; i++) {\n      if (row[i].height > maxHeight) maxHeight = row[i].height;\n    }\n    if (longest > 0) maxHeight += organization.verticalPadding;\n\n    var prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n\n    organization.rowHeight[longest] = maxHeight;\n    if (organization.rowHeight[last] < node.height + organization.verticalPadding) organization.rowHeight[last] = node.height + organization.verticalPadding;\n\n    var finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];\n    organization.height += finalTotal - prevTotal;\n\n    this.shiftToLastRow(organization);\n  }\n};\n\nCoSELayout.prototype.tilingPreLayout = function () {\n  if (CoSEConstants.TILE) {\n    // Find zero degree nodes and create a compound for each level\n    this.groupZeroDegreeMembers();\n    // Tile and clear children of each compound\n    this.clearCompounds();\n    // Separately tile and clear zero degree nodes for each level\n    this.clearZeroDegreeMembers();\n  }\n};\n\nCoSELayout.prototype.tilingPostLayout = function () {\n  if (CoSEConstants.TILE) {\n    this.repopulateZeroDegreeMembers();\n    this.repopulateCompounds();\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: Tree Reduction methods\n// -----------------------------------------------------------------------------\n// Reduce trees \nCoSELayout.prototype.reduceTrees = function () {\n  var prunedNodesAll = [];\n  var containsLeaf = true;\n  var node;\n\n  while (containsLeaf) {\n    var allNodes = this.graphManager.getAllNodes();\n    var prunedNodesInStepTemp = [];\n    containsLeaf = false;\n\n    for (var i = 0; i < allNodes.length; i++) {\n      node = allNodes[i];\n      if (node.getEdges().length == 1 && !node.getEdges()[0].isInterGraph && node.getChild() == null) {\n        if (CoSEConstants.PURE_INCREMENTAL) {\n          var otherEnd = node.getEdges()[0].getOtherEnd(node);\n          var relativePosition = new DimensionD(node.getCenterX() - otherEnd.getCenterX(), node.getCenterY() - otherEnd.getCenterY());\n          prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner(), relativePosition]);\n        } else {\n          prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner()]);\n        }\n        containsLeaf = true;\n      }\n    }\n    if (containsLeaf == true) {\n      var prunedNodesInStep = [];\n      for (var j = 0; j < prunedNodesInStepTemp.length; j++) {\n        if (prunedNodesInStepTemp[j][0].getEdges().length == 1) {\n          prunedNodesInStep.push(prunedNodesInStepTemp[j]);\n          prunedNodesInStepTemp[j][0].getOwner().remove(prunedNodesInStepTemp[j][0]);\n        }\n      }\n      prunedNodesAll.push(prunedNodesInStep);\n      this.graphManager.resetAllNodes();\n      this.graphManager.resetAllEdges();\n    }\n  }\n  this.prunedNodesAll = prunedNodesAll;\n};\n\n// Grow tree one step \nCoSELayout.prototype.growTree = function (prunedNodesAll) {\n  var lengthOfPrunedNodesInStep = prunedNodesAll.length;\n  var prunedNodesInStep = prunedNodesAll[lengthOfPrunedNodesInStep - 1];\n\n  var nodeData;\n  for (var i = 0; i < prunedNodesInStep.length; i++) {\n    nodeData = prunedNodesInStep[i];\n\n    this.findPlaceforPrunedNode(nodeData);\n\n    nodeData[2].add(nodeData[0]);\n    nodeData[2].add(nodeData[1], nodeData[1].source, nodeData[1].target);\n  }\n\n  prunedNodesAll.splice(prunedNodesAll.length - 1, 1);\n  this.graphManager.resetAllNodes();\n  this.graphManager.resetAllEdges();\n};\n\n// Find an appropriate position to replace pruned node, this method can be improved\nCoSELayout.prototype.findPlaceforPrunedNode = function (nodeData) {\n\n  var gridForPrunedNode;\n  var nodeToConnect;\n  var prunedNode = nodeData[0];\n  if (prunedNode == nodeData[1].source) {\n    nodeToConnect = nodeData[1].target;\n  } else {\n    nodeToConnect = nodeData[1].source;\n  }\n\n  if (CoSEConstants.PURE_INCREMENTAL) {\n    prunedNode.setCenter(nodeToConnect.getCenterX() + nodeData[3].getWidth(), nodeToConnect.getCenterY() + nodeData[3].getHeight());\n  } else {\n    var startGridX = nodeToConnect.startX;\n    var finishGridX = nodeToConnect.finishX;\n    var startGridY = nodeToConnect.startY;\n    var finishGridY = nodeToConnect.finishY;\n\n    var upNodeCount = 0;\n    var downNodeCount = 0;\n    var rightNodeCount = 0;\n    var leftNodeCount = 0;\n    var controlRegions = [upNodeCount, rightNodeCount, downNodeCount, leftNodeCount];\n\n    if (startGridY > 0) {\n      for (var i = startGridX; i <= finishGridX; i++) {\n        controlRegions[0] += this.grid[i][startGridY - 1].length + this.grid[i][startGridY].length - 1;\n      }\n    }\n    if (finishGridX < this.grid.length - 1) {\n      for (var i = startGridY; i <= finishGridY; i++) {\n        controlRegions[1] += this.grid[finishGridX + 1][i].length + this.grid[finishGridX][i].length - 1;\n      }\n    }\n    if (finishGridY < this.grid[0].length - 1) {\n      for (var i = startGridX; i <= finishGridX; i++) {\n        controlRegions[2] += this.grid[i][finishGridY + 1].length + this.grid[i][finishGridY].length - 1;\n      }\n    }\n    if (startGridX > 0) {\n      for (var i = startGridY; i <= finishGridY; i++) {\n        controlRegions[3] += this.grid[startGridX - 1][i].length + this.grid[startGridX][i].length - 1;\n      }\n    }\n    var min = Integer.MAX_VALUE;\n    var minCount;\n    var minIndex;\n    for (var j = 0; j < controlRegions.length; j++) {\n      if (controlRegions[j] < min) {\n        min = controlRegions[j];\n        minCount = 1;\n        minIndex = j;\n      } else if (controlRegions[j] == min) {\n        minCount++;\n      }\n    }\n\n    if (minCount == 3 && min == 0) {\n      if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[2] == 0) {\n        gridForPrunedNode = 1;\n      } else if (controlRegions[0] == 0 && controlRegions[1] == 0 && controlRegions[3] == 0) {\n        gridForPrunedNode = 0;\n      } else if (controlRegions[0] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n        gridForPrunedNode = 3;\n      } else if (controlRegions[1] == 0 && controlRegions[2] == 0 && controlRegions[3] == 0) {\n        gridForPrunedNode = 2;\n      }\n    } else if (minCount == 2 && min == 0) {\n      var random = Math.floor(Math.random() * 2);\n      if (controlRegions[0] == 0 && controlRegions[1] == 0) {\n        ;\n        if (random == 0) {\n          gridForPrunedNode = 0;\n        } else {\n          gridForPrunedNode = 1;\n        }\n      } else if (controlRegions[0] == 0 && controlRegions[2] == 0) {\n        if (random == 0) {\n          gridForPrunedNode = 0;\n        } else {\n          gridForPrunedNode = 2;\n        }\n      } else if (controlRegions[0] == 0 && controlRegions[3] == 0) {\n        if (random == 0) {\n          gridForPrunedNode = 0;\n        } else {\n          gridForPrunedNode = 3;\n        }\n      } else if (controlRegions[1] == 0 && controlRegions[2] == 0) {\n        if (random == 0) {\n          gridForPrunedNode = 1;\n        } else {\n          gridForPrunedNode = 2;\n        }\n      } else if (controlRegions[1] == 0 && controlRegions[3] == 0) {\n        if (random == 0) {\n          gridForPrunedNode = 1;\n        } else {\n          gridForPrunedNode = 3;\n        }\n      } else {\n        if (random == 0) {\n          gridForPrunedNode = 2;\n        } else {\n          gridForPrunedNode = 3;\n        }\n      }\n    } else if (minCount == 4 && min == 0) {\n      var random = Math.floor(Math.random() * 4);\n      gridForPrunedNode = random;\n    } else {\n      gridForPrunedNode = minIndex;\n    }\n\n    if (gridForPrunedNode == 0) {\n      prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() - nodeToConnect.getHeight() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getHeight() / 2);\n    } else if (gridForPrunedNode == 1) {\n      prunedNode.setCenter(nodeToConnect.getCenterX() + nodeToConnect.getWidth() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n    } else if (gridForPrunedNode == 2) {\n      prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() + nodeToConnect.getHeight() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getHeight() / 2);\n    } else {\n      prunedNode.setCenter(nodeToConnect.getCenterX() - nodeToConnect.getWidth() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getWidth() / 2, nodeToConnect.getCenterY());\n    }\n  }\n};\n\nmodule.exports = CoSELayout;\n\n/***/ }),\n\n/***/ 991:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_74190__) => {\n\n\n\nvar FDLayoutNode = __nested_webpack_require_74190__(551).FDLayoutNode;\nvar IMath = __nested_webpack_require_74190__(551).IMath;\n\nfunction CoSENode(gm, loc, size, vNode) {\n  FDLayoutNode.call(this, gm, loc, size, vNode);\n}\n\nCoSENode.prototype = Object.create(FDLayoutNode.prototype);\nfor (var prop in FDLayoutNode) {\n  CoSENode[prop] = FDLayoutNode[prop];\n}\n\nCoSENode.prototype.calculateDisplacement = function () {\n  var layout = this.graphManager.getLayout();\n  // this check is for compound nodes that contain fixed nodes\n  if (this.getChild() != null && this.fixedNodeWeight) {\n    this.displacementX += layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.fixedNodeWeight;\n    this.displacementY += layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.fixedNodeWeight;\n  } else {\n    this.displacementX += layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren;\n    this.displacementY += layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren;\n  }\n\n  if (Math.abs(this.displacementX) > layout.coolingFactor * layout.maxNodeDisplacement) {\n    this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementX);\n  }\n\n  if (Math.abs(this.displacementY) > layout.coolingFactor * layout.maxNodeDisplacement) {\n    this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementY);\n  }\n\n  // non-empty compound node, propogate movement to children as well\n  if (this.child && this.child.getNodes().length > 0) {\n    this.propogateDisplacementToChildren(this.displacementX, this.displacementY);\n  }\n};\n\nCoSENode.prototype.propogateDisplacementToChildren = function (dX, dY) {\n  var nodes = this.getChild().getNodes();\n  var node;\n  for (var i = 0; i < nodes.length; i++) {\n    node = nodes[i];\n    if (node.getChild() == null) {\n      node.displacementX += dX;\n      node.displacementY += dY;\n    } else {\n      node.propogateDisplacementToChildren(dX, dY);\n    }\n  }\n};\n\nCoSENode.prototype.move = function () {\n  var layout = this.graphManager.getLayout();\n\n  // a simple node or an empty compound node, move it\n  if (this.child == null || this.child.getNodes().length == 0) {\n    this.moveBy(this.displacementX, this.displacementY);\n\n    layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);\n  }\n\n  this.springForceX = 0;\n  this.springForceY = 0;\n  this.repulsionForceX = 0;\n  this.repulsionForceY = 0;\n  this.gravitationForceX = 0;\n  this.gravitationForceY = 0;\n  this.displacementX = 0;\n  this.displacementY = 0;\n};\n\nCoSENode.prototype.setPred1 = function (pred1) {\n  this.pred1 = pred1;\n};\n\nCoSENode.prototype.getPred1 = function () {\n  return pred1;\n};\n\nCoSENode.prototype.getPred2 = function () {\n  return pred2;\n};\n\nCoSENode.prototype.setNext = function (next) {\n  this.next = next;\n};\n\nCoSENode.prototype.getNext = function () {\n  return next;\n};\n\nCoSENode.prototype.setProcessed = function (processed) {\n  this.processed = processed;\n};\n\nCoSENode.prototype.isProcessed = function () {\n  return processed;\n};\n\nmodule.exports = CoSENode;\n\n/***/ }),\n\n/***/ 902:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_77514__) => {\n\n\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar CoSEConstants = __nested_webpack_require_77514__(806);\nvar LinkedList = __nested_webpack_require_77514__(551).LinkedList;\nvar Matrix = __nested_webpack_require_77514__(551).Matrix;\nvar SVD = __nested_webpack_require_77514__(551).SVD;\n\nfunction ConstraintHandler() {}\n\nConstraintHandler.handleConstraints = function (layout) {\n  //  let layout = this.graphManager.getLayout();\n\n  // get constraints from layout\n  var constraints = {};\n  constraints.fixedNodeConstraint = layout.constraints.fixedNodeConstraint;\n  constraints.alignmentConstraint = layout.constraints.alignmentConstraint;\n  constraints.relativePlacementConstraint = layout.constraints.relativePlacementConstraint;\n\n  var idToNodeMap = new Map();\n  var nodeIndexes = new Map();\n  var xCoords = [];\n  var yCoords = [];\n\n  var allNodes = layout.getAllNodes();\n  var index = 0;\n  // fill index map and coordinates\n  for (var i = 0; i < allNodes.length; i++) {\n    var node = allNodes[i];\n    if (node.getChild() == null) {\n      nodeIndexes.set(node.id, index++);\n      xCoords.push(node.getCenterX());\n      yCoords.push(node.getCenterY());\n      idToNodeMap.set(node.id, node);\n    }\n  }\n\n  // if there exists relative placement constraint without gap value, set it to default \n  if (constraints.relativePlacementConstraint) {\n    constraints.relativePlacementConstraint.forEach(function (constraint) {\n      if (!constraint.gap && constraint.gap != 0) {\n        if (constraint.left) {\n          constraint.gap = CoSEConstants.DEFAULT_EDGE_LENGTH + idToNodeMap.get(constraint.left).getWidth() / 2 + idToNodeMap.get(constraint.right).getWidth() / 2;\n        } else {\n          constraint.gap = CoSEConstants.DEFAULT_EDGE_LENGTH + idToNodeMap.get(constraint.top).getHeight() / 2 + idToNodeMap.get(constraint.bottom).getHeight() / 2;\n        }\n      }\n    });\n  }\n\n  /* auxiliary functions */\n\n  // calculate difference between two position objects\n  var calculatePositionDiff = function calculatePositionDiff(pos1, pos2) {\n    return { x: pos1.x - pos2.x, y: pos1.y - pos2.y };\n  };\n\n  // calculate average position of the nodes\n  var calculateAvgPosition = function calculateAvgPosition(nodeIdSet) {\n    var xPosSum = 0;\n    var yPosSum = 0;\n    nodeIdSet.forEach(function (nodeId) {\n      xPosSum += xCoords[nodeIndexes.get(nodeId)];\n      yPosSum += yCoords[nodeIndexes.get(nodeId)];\n    });\n\n    return { x: xPosSum / nodeIdSet.size, y: yPosSum / nodeIdSet.size };\n  };\n\n  // find an appropriate positioning for the nodes in a given graph according to relative placement constraints\n  // this function also takes the fixed nodes and alignment constraints into account\n  // graph: dag to be evaluated, direction: \"horizontal\" or \"vertical\", \n  // fixedNodes: set of fixed nodes to consider during evaluation, dummyPositions: appropriate coordinates of the dummy nodes  \n  var findAppropriatePositionForRelativePlacement = function findAppropriatePositionForRelativePlacement(graph, direction, fixedNodes, dummyPositions, componentSources) {\n\n    // find union of two sets\n    function setUnion(setA, setB) {\n      var union = new Set(setA);\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = setB[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var elem = _step.value;\n\n          union.add(elem);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return union;\n    }\n\n    // find indegree count for each node\n    var inDegrees = new Map();\n\n    graph.forEach(function (value, key) {\n      inDegrees.set(key, 0);\n    });\n    graph.forEach(function (value, key) {\n      value.forEach(function (adjacent) {\n        inDegrees.set(adjacent.id, inDegrees.get(adjacent.id) + 1);\n      });\n    });\n\n    var positionMap = new Map(); // keeps the position for each node\n    var pastMap = new Map(); // keeps the predecessors(past) of a node\n    var queue = new LinkedList();\n    inDegrees.forEach(function (value, key) {\n      if (value == 0) {\n        queue.push(key);\n        if (!fixedNodes) {\n          if (direction == \"horizontal\") {\n            positionMap.set(key, nodeIndexes.has(key) ? xCoords[nodeIndexes.get(key)] : dummyPositions.get(key));\n          } else {\n            positionMap.set(key, nodeIndexes.has(key) ? yCoords[nodeIndexes.get(key)] : dummyPositions.get(key));\n          }\n        }\n      } else {\n        positionMap.set(key, Number.NEGATIVE_INFINITY);\n      }\n      if (fixedNodes) {\n        pastMap.set(key, new Set([key]));\n      }\n    });\n\n    // align sources of each component in enforcement phase\n    if (fixedNodes) {\n      componentSources.forEach(function (component) {\n        var fixedIds = [];\n        component.forEach(function (nodeId) {\n          if (fixedNodes.has(nodeId)) {\n            fixedIds.push(nodeId);\n          }\n        });\n        if (fixedIds.length > 0) {\n          var position = 0;\n          fixedIds.forEach(function (fixedId) {\n            if (direction == \"horizontal\") {\n              positionMap.set(fixedId, nodeIndexes.has(fixedId) ? xCoords[nodeIndexes.get(fixedId)] : dummyPositions.get(fixedId));\n              position += positionMap.get(fixedId);\n            } else {\n              positionMap.set(fixedId, nodeIndexes.has(fixedId) ? yCoords[nodeIndexes.get(fixedId)] : dummyPositions.get(fixedId));\n              position += positionMap.get(fixedId);\n            }\n          });\n          position = position / fixedIds.length;\n          component.forEach(function (nodeId) {\n            if (!fixedNodes.has(nodeId)) {\n              positionMap.set(nodeId, position);\n            }\n          });\n        } else {\n          var _position = 0;\n          component.forEach(function (nodeId) {\n            if (direction == \"horizontal\") {\n              _position += nodeIndexes.has(nodeId) ? xCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n            } else {\n              _position += nodeIndexes.has(nodeId) ? yCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n            }\n          });\n          _position = _position / component.length;\n          component.forEach(function (nodeId) {\n            positionMap.set(nodeId, _position);\n          });\n        }\n      });\n    }\n\n    // calculate positions of the nodes\n\n    var _loop = function _loop() {\n      var currentNode = queue.shift();\n      var neighbors = graph.get(currentNode);\n      neighbors.forEach(function (neighbor) {\n        if (positionMap.get(neighbor.id) < positionMap.get(currentNode) + neighbor.gap) {\n          if (fixedNodes && fixedNodes.has(neighbor.id)) {\n            var fixedPosition = void 0;\n            if (direction == \"horizontal\") {\n              fixedPosition = nodeIndexes.has(neighbor.id) ? xCoords[nodeIndexes.get(neighbor.id)] : dummyPositions.get(neighbor.id);\n            } else {\n              fixedPosition = nodeIndexes.has(neighbor.id) ? yCoords[nodeIndexes.get(neighbor.id)] : dummyPositions.get(neighbor.id);\n            }\n            positionMap.set(neighbor.id, fixedPosition); // TODO: may do unnecessary work\n            if (fixedPosition < positionMap.get(currentNode) + neighbor.gap) {\n              var diff = positionMap.get(currentNode) + neighbor.gap - fixedPosition;\n              pastMap.get(currentNode).forEach(function (nodeId) {\n                positionMap.set(nodeId, positionMap.get(nodeId) - diff);\n              });\n            }\n          } else {\n            positionMap.set(neighbor.id, positionMap.get(currentNode) + neighbor.gap);\n          }\n        }\n        inDegrees.set(neighbor.id, inDegrees.get(neighbor.id) - 1);\n        if (inDegrees.get(neighbor.id) == 0) {\n          queue.push(neighbor.id);\n        }\n        if (fixedNodes) {\n          pastMap.set(neighbor.id, setUnion(pastMap.get(currentNode), pastMap.get(neighbor.id)));\n        }\n      });\n    };\n\n    while (queue.length != 0) {\n      _loop();\n    }\n\n    // readjust position of the nodes after enforcement\n    if (fixedNodes) {\n      // find indegree count for each node\n      var sinkNodes = new Set();\n\n      graph.forEach(function (value, key) {\n        if (value.length == 0) {\n          sinkNodes.add(key);\n        }\n      });\n\n      var _components = [];\n      pastMap.forEach(function (value, key) {\n        if (sinkNodes.has(key)) {\n          var isFixedComponent = false;\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = value[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var nodeId = _step2.value;\n\n              if (fixedNodes.has(nodeId)) {\n                isFixedComponent = true;\n              }\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n\n          if (!isFixedComponent) {\n            var isExist = false;\n            var existAt = void 0;\n            _components.forEach(function (component, index) {\n              if (component.has([].concat(_toConsumableArray(value))[0])) {\n                isExist = true;\n                existAt = index;\n              }\n            });\n            if (!isExist) {\n              _components.push(new Set(value));\n            } else {\n              value.forEach(function (ele) {\n                _components[existAt].add(ele);\n              });\n            }\n          }\n        }\n      });\n\n      _components.forEach(function (component, index) {\n        var minBefore = Number.POSITIVE_INFINITY;\n        var minAfter = Number.POSITIVE_INFINITY;\n        var maxBefore = Number.NEGATIVE_INFINITY;\n        var maxAfter = Number.NEGATIVE_INFINITY;\n\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = component[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var nodeId = _step3.value;\n\n            var posBefore = void 0;\n            if (direction == \"horizontal\") {\n              posBefore = nodeIndexes.has(nodeId) ? xCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n            } else {\n              posBefore = nodeIndexes.has(nodeId) ? yCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);\n            }\n            var posAfter = positionMap.get(nodeId);\n            if (posBefore < minBefore) {\n              minBefore = posBefore;\n            }\n            if (posBefore > maxBefore) {\n              maxBefore = posBefore;\n            }\n            if (posAfter < minAfter) {\n              minAfter = posAfter;\n            }\n            if (posAfter > maxAfter) {\n              maxAfter = posAfter;\n            }\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n\n        var diff = (minBefore + maxBefore) / 2 - (minAfter + maxAfter) / 2;\n\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = component[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var _nodeId = _step4.value;\n\n            positionMap.set(_nodeId, positionMap.get(_nodeId) + diff);\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      });\n    }\n\n    return positionMap;\n  };\n\n  // find transformation based on rel. placement constraints if there are both alignment and rel. placement constraints\n  // or if there are only rel. placement contraints where the largest component isn't sufficiently large\n  var applyReflectionForRelativePlacement = function applyReflectionForRelativePlacement(relativePlacementConstraints) {\n    // variables to count votes\n    var reflectOnY = 0,\n        notReflectOnY = 0;\n    var reflectOnX = 0,\n        notReflectOnX = 0;\n\n    relativePlacementConstraints.forEach(function (constraint) {\n      if (constraint.left) {\n        xCoords[nodeIndexes.get(constraint.left)] - xCoords[nodeIndexes.get(constraint.right)] >= 0 ? reflectOnY++ : notReflectOnY++;\n      } else {\n        yCoords[nodeIndexes.get(constraint.top)] - yCoords[nodeIndexes.get(constraint.bottom)] >= 0 ? reflectOnX++ : notReflectOnX++;\n      }\n    });\n\n    if (reflectOnY > notReflectOnY && reflectOnX > notReflectOnX) {\n      for (var _i = 0; _i < nodeIndexes.size; _i++) {\n        xCoords[_i] = -1 * xCoords[_i];\n        yCoords[_i] = -1 * yCoords[_i];\n      }\n    } else if (reflectOnY > notReflectOnY) {\n      for (var _i2 = 0; _i2 < nodeIndexes.size; _i2++) {\n        xCoords[_i2] = -1 * xCoords[_i2];\n      }\n    } else if (reflectOnX > notReflectOnX) {\n      for (var _i3 = 0; _i3 < nodeIndexes.size; _i3++) {\n        yCoords[_i3] = -1 * yCoords[_i3];\n      }\n    }\n  };\n\n  // find weakly connected components in undirected graph\n  var findComponents = function findComponents(graph) {\n    // find weakly connected components in dag\n    var components = [];\n    var queue = new LinkedList();\n    var visited = new Set();\n    var count = 0;\n\n    graph.forEach(function (value, key) {\n      if (!visited.has(key)) {\n        components[count] = [];\n        var _currentNode = key;\n        queue.push(_currentNode);\n        visited.add(_currentNode);\n        components[count].push(_currentNode);\n\n        while (queue.length != 0) {\n          _currentNode = queue.shift();\n          var neighbors = graph.get(_currentNode);\n          neighbors.forEach(function (neighbor) {\n            if (!visited.has(neighbor.id)) {\n              queue.push(neighbor.id);\n              visited.add(neighbor.id);\n              components[count].push(neighbor.id);\n            }\n          });\n        }\n        count++;\n      }\n    });\n    return components;\n  };\n\n  // return undirected version of given dag\n  var dagToUndirected = function dagToUndirected(dag) {\n    var undirected = new Map();\n\n    dag.forEach(function (value, key) {\n      undirected.set(key, []);\n    });\n\n    dag.forEach(function (value, key) {\n      value.forEach(function (adjacent) {\n        undirected.get(key).push(adjacent);\n        undirected.get(adjacent.id).push({ id: key, gap: adjacent.gap, direction: adjacent.direction });\n      });\n    });\n\n    return undirected;\n  };\n\n  // return reversed (directions inverted) version of given dag\n  var dagToReversed = function dagToReversed(dag) {\n    var reversed = new Map();\n\n    dag.forEach(function (value, key) {\n      reversed.set(key, []);\n    });\n\n    dag.forEach(function (value, key) {\n      value.forEach(function (adjacent) {\n        reversed.get(adjacent.id).push({ id: key, gap: adjacent.gap, direction: adjacent.direction });\n      });\n    });\n\n    return reversed;\n  };\n\n  /****  apply transformation to the initial draft layout to better align with constrained nodes ****/\n  // solve the Orthogonal Procrustean Problem to rotate and/or reflect initial draft layout\n  // here we follow the solution in Chapter 20.2 of Borg, I. & Groenen, P. (2005) Modern Multidimensional Scaling: Theory and Applications \n\n  /* construct source and target configurations */\n\n  var targetMatrix = []; // A - target configuration\n  var sourceMatrix = []; // B - source configuration \n  var standardTransformation = false; // false for no transformation, true for standart (Procrustes) transformation (rotation and/or reflection)\n  var reflectionType = false; // false/true for reflection check, 'reflectOnX', 'reflectOnY' or 'reflectOnBoth' for reflection type if necessary\n  var fixedNodes = new Set();\n  var dag = new Map(); // adjacency list to keep directed acyclic graph (dag) that consists of relative placement constraints\n  var dagUndirected = new Map(); // undirected version of the dag\n  var components = []; // weakly connected components\n\n  // fill fixedNodes collection to use later\n  if (constraints.fixedNodeConstraint) {\n    constraints.fixedNodeConstraint.forEach(function (nodeData) {\n      fixedNodes.add(nodeData.nodeId);\n    });\n  }\n\n  // construct dag from relative placement constraints \n  if (constraints.relativePlacementConstraint) {\n    // construct both directed and undirected version of the dag\n    constraints.relativePlacementConstraint.forEach(function (constraint) {\n      if (constraint.left) {\n        if (dag.has(constraint.left)) {\n          dag.get(constraint.left).push({ id: constraint.right, gap: constraint.gap, direction: \"horizontal\" });\n        } else {\n          dag.set(constraint.left, [{ id: constraint.right, gap: constraint.gap, direction: \"horizontal\" }]);\n        }\n        if (!dag.has(constraint.right)) {\n          dag.set(constraint.right, []);\n        }\n      } else {\n        if (dag.has(constraint.top)) {\n          dag.get(constraint.top).push({ id: constraint.bottom, gap: constraint.gap, direction: \"vertical\" });\n        } else {\n          dag.set(constraint.top, [{ id: constraint.bottom, gap: constraint.gap, direction: \"vertical\" }]);\n        }\n        if (!dag.has(constraint.bottom)) {\n          dag.set(constraint.bottom, []);\n        }\n      }\n    });\n\n    dagUndirected = dagToUndirected(dag);\n    components = findComponents(dagUndirected);\n  }\n\n  if (CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING) {\n    // first check fixed node constraint\n    if (constraints.fixedNodeConstraint && constraints.fixedNodeConstraint.length > 1) {\n      constraints.fixedNodeConstraint.forEach(function (nodeData, i) {\n        targetMatrix[i] = [nodeData.position.x, nodeData.position.y];\n        sourceMatrix[i] = [xCoords[nodeIndexes.get(nodeData.nodeId)], yCoords[nodeIndexes.get(nodeData.nodeId)]];\n      });\n      standardTransformation = true;\n    } else if (constraints.alignmentConstraint) {\n      (function () {\n        // then check alignment constraint\n        var count = 0;\n        if (constraints.alignmentConstraint.vertical) {\n          var verticalAlign = constraints.alignmentConstraint.vertical;\n\n          var _loop2 = function _loop2(_i4) {\n            var alignmentSet = new Set();\n            verticalAlign[_i4].forEach(function (nodeId) {\n              alignmentSet.add(nodeId);\n            });\n            var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n              return fixedNodes.has(x);\n            }));\n            var xPos = void 0;\n            if (intersection.size > 0) xPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else xPos = calculateAvgPosition(alignmentSet).x;\n\n            verticalAlign[_i4].forEach(function (nodeId) {\n              targetMatrix[count] = [xPos, yCoords[nodeIndexes.get(nodeId)]];\n              sourceMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n              count++;\n            });\n          };\n\n          for (var _i4 = 0; _i4 < verticalAlign.length; _i4++) {\n            _loop2(_i4);\n          }\n          standardTransformation = true;\n        }\n        if (constraints.alignmentConstraint.horizontal) {\n          var horizontalAlign = constraints.alignmentConstraint.horizontal;\n\n          var _loop3 = function _loop3(_i5) {\n            var alignmentSet = new Set();\n            horizontalAlign[_i5].forEach(function (nodeId) {\n              alignmentSet.add(nodeId);\n            });\n            var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n              return fixedNodes.has(x);\n            }));\n            var yPos = void 0;\n            if (intersection.size > 0) yPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else yPos = calculateAvgPosition(alignmentSet).y;\n\n            horizontalAlign[_i5].forEach(function (nodeId) {\n              targetMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yPos];\n              sourceMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n              count++;\n            });\n          };\n\n          for (var _i5 = 0; _i5 < horizontalAlign.length; _i5++) {\n            _loop3(_i5);\n          }\n          standardTransformation = true;\n        }\n        if (constraints.relativePlacementConstraint) {\n          reflectionType = true;\n        }\n      })();\n    } else if (constraints.relativePlacementConstraint) {\n      // finally check relative placement constraint\n      // find largest component in dag\n      var largestComponentSize = 0;\n      var largestComponentIndex = 0;\n      for (var _i6 = 0; _i6 < components.length; _i6++) {\n        if (components[_i6].length > largestComponentSize) {\n          largestComponentSize = components[_i6].length;\n          largestComponentIndex = _i6;\n        }\n      }\n      // if largest component isn't dominant, then take the votes for reflection\n      if (largestComponentSize < dagUndirected.size / 2) {\n        applyReflectionForRelativePlacement(constraints.relativePlacementConstraint);\n        standardTransformation = false;\n        reflectionType = false;\n      } else {\n        // use largest component for transformation\n        // construct horizontal and vertical subgraphs in the largest component\n        var subGraphOnHorizontal = new Map();\n        var subGraphOnVertical = new Map();\n        var constraintsInlargestComponent = [];\n\n        components[largestComponentIndex].forEach(function (nodeId) {\n          dag.get(nodeId).forEach(function (adjacent) {\n            if (adjacent.direction == \"horizontal\") {\n              if (subGraphOnHorizontal.has(nodeId)) {\n                subGraphOnHorizontal.get(nodeId).push(adjacent);\n              } else {\n                subGraphOnHorizontal.set(nodeId, [adjacent]);\n              }\n              if (!subGraphOnHorizontal.has(adjacent.id)) {\n                subGraphOnHorizontal.set(adjacent.id, []);\n              }\n              constraintsInlargestComponent.push({ left: nodeId, right: adjacent.id });\n            } else {\n              if (subGraphOnVertical.has(nodeId)) {\n                subGraphOnVertical.get(nodeId).push(adjacent);\n              } else {\n                subGraphOnVertical.set(nodeId, [adjacent]);\n              }\n              if (!subGraphOnVertical.has(adjacent.id)) {\n                subGraphOnVertical.set(adjacent.id, []);\n              }\n              constraintsInlargestComponent.push({ top: nodeId, bottom: adjacent.id });\n            }\n          });\n        });\n\n        applyReflectionForRelativePlacement(constraintsInlargestComponent);\n        reflectionType = false;\n\n        // calculate appropriate positioning for subgraphs\n        var positionMapHorizontal = findAppropriatePositionForRelativePlacement(subGraphOnHorizontal, \"horizontal\");\n        var positionMapVertical = findAppropriatePositionForRelativePlacement(subGraphOnVertical, \"vertical\");\n\n        // construct source and target configuration\n        components[largestComponentIndex].forEach(function (nodeId, i) {\n          sourceMatrix[i] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];\n          targetMatrix[i] = [];\n          if (positionMapHorizontal.has(nodeId)) {\n            targetMatrix[i][0] = positionMapHorizontal.get(nodeId);\n          } else {\n            targetMatrix[i][0] = xCoords[nodeIndexes.get(nodeId)];\n          }\n          if (positionMapVertical.has(nodeId)) {\n            targetMatrix[i][1] = positionMapVertical.get(nodeId);\n          } else {\n            targetMatrix[i][1] = yCoords[nodeIndexes.get(nodeId)];\n          }\n        });\n\n        standardTransformation = true;\n      }\n    }\n\n    // if transformation is required, then calculate and apply transformation matrix\n    if (standardTransformation) {\n      /* calculate transformation matrix */\n      var transformationMatrix = void 0;\n      var targetMatrixTranspose = Matrix.transpose(targetMatrix); // A'\n      var sourceMatrixTranspose = Matrix.transpose(sourceMatrix); // B'\n\n      // centralize transpose matrices\n      for (var _i7 = 0; _i7 < targetMatrixTranspose.length; _i7++) {\n        targetMatrixTranspose[_i7] = Matrix.multGamma(targetMatrixTranspose[_i7]);\n        sourceMatrixTranspose[_i7] = Matrix.multGamma(sourceMatrixTranspose[_i7]);\n      }\n\n      // do actual calculation for transformation matrix\n      var tempMatrix = Matrix.multMat(targetMatrixTranspose, Matrix.transpose(sourceMatrixTranspose)); // tempMatrix = A'B\n      var SVDResult = SVD.svd(tempMatrix); // SVD(A'B) = USV', svd function returns U, S and V \n      transformationMatrix = Matrix.multMat(SVDResult.V, Matrix.transpose(SVDResult.U)); // transformationMatrix = T = VU'\n\n      /* apply found transformation matrix to obtain final draft layout */\n      for (var _i8 = 0; _i8 < nodeIndexes.size; _i8++) {\n        var temp1 = [xCoords[_i8], yCoords[_i8]];\n        var temp2 = [transformationMatrix[0][0], transformationMatrix[1][0]];\n        var temp3 = [transformationMatrix[0][1], transformationMatrix[1][1]];\n        xCoords[_i8] = Matrix.dotProduct(temp1, temp2);\n        yCoords[_i8] = Matrix.dotProduct(temp1, temp3);\n      }\n\n      // applied only both alignment and rel. placement constraints exist\n      if (reflectionType) {\n        applyReflectionForRelativePlacement(constraints.relativePlacementConstraint);\n      }\n    }\n  }\n\n  if (CoSEConstants.ENFORCE_CONSTRAINTS) {\n    /****  enforce constraints on the transformed draft layout ****/\n\n    /* first enforce fixed node constraint */\n\n    if (constraints.fixedNodeConstraint && constraints.fixedNodeConstraint.length > 0) {\n      var translationAmount = { x: 0, y: 0 };\n      constraints.fixedNodeConstraint.forEach(function (nodeData, i) {\n        var posInTheory = { x: xCoords[nodeIndexes.get(nodeData.nodeId)], y: yCoords[nodeIndexes.get(nodeData.nodeId)] };\n        var posDesired = nodeData.position;\n        var posDiff = calculatePositionDiff(posDesired, posInTheory);\n        translationAmount.x += posDiff.x;\n        translationAmount.y += posDiff.y;\n      });\n      translationAmount.x /= constraints.fixedNodeConstraint.length;\n      translationAmount.y /= constraints.fixedNodeConstraint.length;\n\n      xCoords.forEach(function (value, i) {\n        xCoords[i] += translationAmount.x;\n      });\n\n      yCoords.forEach(function (value, i) {\n        yCoords[i] += translationAmount.y;\n      });\n\n      constraints.fixedNodeConstraint.forEach(function (nodeData) {\n        xCoords[nodeIndexes.get(nodeData.nodeId)] = nodeData.position.x;\n        yCoords[nodeIndexes.get(nodeData.nodeId)] = nodeData.position.y;\n      });\n    }\n\n    /* then enforce alignment constraint */\n\n    if (constraints.alignmentConstraint) {\n      if (constraints.alignmentConstraint.vertical) {\n        var xAlign = constraints.alignmentConstraint.vertical;\n\n        var _loop4 = function _loop4(_i9) {\n          var alignmentSet = new Set();\n          xAlign[_i9].forEach(function (nodeId) {\n            alignmentSet.add(nodeId);\n          });\n          var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n            return fixedNodes.has(x);\n          }));\n          var xPos = void 0;\n          if (intersection.size > 0) xPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else xPos = calculateAvgPosition(alignmentSet).x;\n\n          alignmentSet.forEach(function (nodeId) {\n            if (!fixedNodes.has(nodeId)) xCoords[nodeIndexes.get(nodeId)] = xPos;\n          });\n        };\n\n        for (var _i9 = 0; _i9 < xAlign.length; _i9++) {\n          _loop4(_i9);\n        }\n      }\n      if (constraints.alignmentConstraint.horizontal) {\n        var yAlign = constraints.alignmentConstraint.horizontal;\n\n        var _loop5 = function _loop5(_i10) {\n          var alignmentSet = new Set();\n          yAlign[_i10].forEach(function (nodeId) {\n            alignmentSet.add(nodeId);\n          });\n          var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {\n            return fixedNodes.has(x);\n          }));\n          var yPos = void 0;\n          if (intersection.size > 0) yPos = yCoords[nodeIndexes.get(intersection.values().next().value)];else yPos = calculateAvgPosition(alignmentSet).y;\n\n          alignmentSet.forEach(function (nodeId) {\n            if (!fixedNodes.has(nodeId)) yCoords[nodeIndexes.get(nodeId)] = yPos;\n          });\n        };\n\n        for (var _i10 = 0; _i10 < yAlign.length; _i10++) {\n          _loop5(_i10);\n        }\n      }\n    }\n\n    /* finally enforce relative placement constraint */\n\n    if (constraints.relativePlacementConstraint) {\n      (function () {\n        var nodeToDummyForVerticalAlignment = new Map();\n        var nodeToDummyForHorizontalAlignment = new Map();\n        var dummyToNodeForVerticalAlignment = new Map();\n        var dummyToNodeForHorizontalAlignment = new Map();\n        var dummyPositionsForVerticalAlignment = new Map();\n        var dummyPositionsForHorizontalAlignment = new Map();\n        var fixedNodesOnHorizontal = new Set();\n        var fixedNodesOnVertical = new Set();\n\n        // fill maps and sets      \n        fixedNodes.forEach(function (nodeId) {\n          fixedNodesOnHorizontal.add(nodeId);\n          fixedNodesOnVertical.add(nodeId);\n        });\n\n        if (constraints.alignmentConstraint) {\n          if (constraints.alignmentConstraint.vertical) {\n            var verticalAlignment = constraints.alignmentConstraint.vertical;\n\n            var _loop6 = function _loop6(_i11) {\n              dummyToNodeForVerticalAlignment.set(\"dummy\" + _i11, []);\n              verticalAlignment[_i11].forEach(function (nodeId) {\n                nodeToDummyForVerticalAlignment.set(nodeId, \"dummy\" + _i11);\n                dummyToNodeForVerticalAlignment.get(\"dummy\" + _i11).push(nodeId);\n                if (fixedNodes.has(nodeId)) {\n                  fixedNodesOnHorizontal.add(\"dummy\" + _i11);\n                }\n              });\n              dummyPositionsForVerticalAlignment.set(\"dummy\" + _i11, xCoords[nodeIndexes.get(verticalAlignment[_i11][0])]);\n            };\n\n            for (var _i11 = 0; _i11 < verticalAlignment.length; _i11++) {\n              _loop6(_i11);\n            }\n          }\n          if (constraints.alignmentConstraint.horizontal) {\n            var horizontalAlignment = constraints.alignmentConstraint.horizontal;\n\n            var _loop7 = function _loop7(_i12) {\n              dummyToNodeForHorizontalAlignment.set(\"dummy\" + _i12, []);\n              horizontalAlignment[_i12].forEach(function (nodeId) {\n                nodeToDummyForHorizontalAlignment.set(nodeId, \"dummy\" + _i12);\n                dummyToNodeForHorizontalAlignment.get(\"dummy\" + _i12).push(nodeId);\n                if (fixedNodes.has(nodeId)) {\n                  fixedNodesOnVertical.add(\"dummy\" + _i12);\n                }\n              });\n              dummyPositionsForHorizontalAlignment.set(\"dummy\" + _i12, yCoords[nodeIndexes.get(horizontalAlignment[_i12][0])]);\n            };\n\n            for (var _i12 = 0; _i12 < horizontalAlignment.length; _i12++) {\n              _loop7(_i12);\n            }\n          }\n        }\n\n        // construct horizontal and vertical dags (subgraphs) from overall dag\n        var dagOnHorizontal = new Map();\n        var dagOnVertical = new Map();\n\n        var _loop8 = function _loop8(nodeId) {\n          dag.get(nodeId).forEach(function (adjacent) {\n            var sourceId = void 0;\n            var targetNode = void 0;\n            if (adjacent[\"direction\"] == \"horizontal\") {\n              sourceId = nodeToDummyForVerticalAlignment.get(nodeId) ? nodeToDummyForVerticalAlignment.get(nodeId) : nodeId;\n              if (nodeToDummyForVerticalAlignment.get(adjacent.id)) {\n                targetNode = { id: nodeToDummyForVerticalAlignment.get(adjacent.id), gap: adjacent.gap, direction: adjacent.direction };\n              } else {\n                targetNode = adjacent;\n              }\n              if (dagOnHorizontal.has(sourceId)) {\n                dagOnHorizontal.get(sourceId).push(targetNode);\n              } else {\n                dagOnHorizontal.set(sourceId, [targetNode]);\n              }\n              if (!dagOnHorizontal.has(targetNode.id)) {\n                dagOnHorizontal.set(targetNode.id, []);\n              }\n            } else {\n              sourceId = nodeToDummyForHorizontalAlignment.get(nodeId) ? nodeToDummyForHorizontalAlignment.get(nodeId) : nodeId;\n              if (nodeToDummyForHorizontalAlignment.get(adjacent.id)) {\n                targetNode = { id: nodeToDummyForHorizontalAlignment.get(adjacent.id), gap: adjacent.gap, direction: adjacent.direction };\n              } else {\n                targetNode = adjacent;\n              }\n              if (dagOnVertical.has(sourceId)) {\n                dagOnVertical.get(sourceId).push(targetNode);\n              } else {\n                dagOnVertical.set(sourceId, [targetNode]);\n              }\n              if (!dagOnVertical.has(targetNode.id)) {\n                dagOnVertical.set(targetNode.id, []);\n              }\n            }\n          });\n        };\n\n        var _iteratorNormalCompletion5 = true;\n        var _didIteratorError5 = false;\n        var _iteratorError5 = undefined;\n\n        try {\n          for (var _iterator5 = dag.keys()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n            var nodeId = _step5.value;\n\n            _loop8(nodeId);\n          }\n\n          // find source nodes of each component in horizontal and vertical dags\n        } catch (err) {\n          _didIteratorError5 = true;\n          _iteratorError5 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion5 && _iterator5.return) {\n              _iterator5.return();\n            }\n          } finally {\n            if (_didIteratorError5) {\n              throw _iteratorError5;\n            }\n          }\n        }\n\n        var undirectedOnHorizontal = dagToUndirected(dagOnHorizontal);\n        var undirectedOnVertical = dagToUndirected(dagOnVertical);\n        var componentsOnHorizontal = findComponents(undirectedOnHorizontal);\n        var componentsOnVertical = findComponents(undirectedOnVertical);\n        var reversedDagOnHorizontal = dagToReversed(dagOnHorizontal);\n        var reversedDagOnVertical = dagToReversed(dagOnVertical);\n        var componentSourcesOnHorizontal = [];\n        var componentSourcesOnVertical = [];\n\n        componentsOnHorizontal.forEach(function (component, index) {\n          componentSourcesOnHorizontal[index] = [];\n          component.forEach(function (nodeId) {\n            if (reversedDagOnHorizontal.get(nodeId).length == 0) {\n              componentSourcesOnHorizontal[index].push(nodeId);\n            }\n          });\n        });\n\n        componentsOnVertical.forEach(function (component, index) {\n          componentSourcesOnVertical[index] = [];\n          component.forEach(function (nodeId) {\n            if (reversedDagOnVertical.get(nodeId).length == 0) {\n              componentSourcesOnVertical[index].push(nodeId);\n            }\n          });\n        });\n\n        // calculate appropriate positioning for subgraphs\n        var positionMapHorizontal = findAppropriatePositionForRelativePlacement(dagOnHorizontal, \"horizontal\", fixedNodesOnHorizontal, dummyPositionsForVerticalAlignment, componentSourcesOnHorizontal);\n        var positionMapVertical = findAppropriatePositionForRelativePlacement(dagOnVertical, \"vertical\", fixedNodesOnVertical, dummyPositionsForHorizontalAlignment, componentSourcesOnVertical);\n\n        // update positions of the nodes based on relative placement constraints\n\n        var _loop9 = function _loop9(key) {\n          if (dummyToNodeForVerticalAlignment.get(key)) {\n            dummyToNodeForVerticalAlignment.get(key).forEach(function (nodeId) {\n              xCoords[nodeIndexes.get(nodeId)] = positionMapHorizontal.get(key);\n            });\n          } else {\n            xCoords[nodeIndexes.get(key)] = positionMapHorizontal.get(key);\n          }\n        };\n\n        var _iteratorNormalCompletion6 = true;\n        var _didIteratorError6 = false;\n        var _iteratorError6 = undefined;\n\n        try {\n          for (var _iterator6 = positionMapHorizontal.keys()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n            var key = _step6.value;\n\n            _loop9(key);\n          }\n        } catch (err) {\n          _didIteratorError6 = true;\n          _iteratorError6 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion6 && _iterator6.return) {\n              _iterator6.return();\n            }\n          } finally {\n            if (_didIteratorError6) {\n              throw _iteratorError6;\n            }\n          }\n        }\n\n        var _loop10 = function _loop10(key) {\n          if (dummyToNodeForHorizontalAlignment.get(key)) {\n            dummyToNodeForHorizontalAlignment.get(key).forEach(function (nodeId) {\n              yCoords[nodeIndexes.get(nodeId)] = positionMapVertical.get(key);\n            });\n          } else {\n            yCoords[nodeIndexes.get(key)] = positionMapVertical.get(key);\n          }\n        };\n\n        var _iteratorNormalCompletion7 = true;\n        var _didIteratorError7 = false;\n        var _iteratorError7 = undefined;\n\n        try {\n          for (var _iterator7 = positionMapVertical.keys()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n            var key = _step7.value;\n\n            _loop10(key);\n          }\n        } catch (err) {\n          _didIteratorError7 = true;\n          _iteratorError7 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion7 && _iterator7.return) {\n              _iterator7.return();\n            }\n          } finally {\n            if (_didIteratorError7) {\n              throw _iteratorError7;\n            }\n          }\n        }\n      })();\n    }\n  }\n\n  // assign new coordinates to nodes after constraint handling\n  for (var _i13 = 0; _i13 < allNodes.length; _i13++) {\n    var _node = allNodes[_i13];\n    if (_node.getChild() == null) {\n      _node.setCenter(xCoords[nodeIndexes.get(_node.id)], yCoords[nodeIndexes.get(_node.id)]);\n    }\n  }\n};\n\nmodule.exports = ConstraintHandler;\n\n/***/ }),\n\n/***/ 551:\n/***/ ((module) => {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__551__;\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_117795__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_117795__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \tvar __nested_webpack_exports__ = __nested_webpack_require_117795__(45);\n/******/ \t\n/******/ \treturn __nested_webpack_exports__;\n/******/ })()\n;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlLWZjb3NlL25vZGVfbW9kdWxlcy9jb3NlLWJhc2UvY29zZS1iYXNlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsSUFBSSxJQUF5RDtBQUM3RCwyQkFBMkIsbUJBQU8sQ0FBQywyRkFBYTtBQUNoRCxNQUFNLEVBSzJDO0FBQ2pELENBQUM7QUFDRCx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyw4QkFBbUI7Ozs7QUFJN0Q7O0FBRUEsc0JBQXNCLDhCQUFtQjtBQUN6Qyx5QkFBeUIsOEJBQW1CO0FBQzVDLG9CQUFvQiw4QkFBbUI7QUFDdkMscUJBQXFCLDhCQUFtQjtBQUN4Qyw0QkFBNEIsOEJBQW1CO0FBQy9DLHNCQUFzQiw4QkFBbUI7QUFDekMsb0JBQW9CLDhCQUFtQjtBQUN2Qyw2QkFBNkIsOEJBQW1COztBQUVoRDs7QUFFQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLCtCQUFtQjs7OztBQUk3RCx3QkFBd0IsK0JBQW1COztBQUUzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQywrQkFBbUI7Ozs7QUFJN0QsbUJBQW1CLCtCQUFtQjs7QUFFdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsK0JBQW1COzs7O0FBSTdELGFBQWEsK0JBQW1COztBQUVoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQywrQkFBbUI7Ozs7QUFJN0Qsb0JBQW9CLCtCQUFtQjs7QUFFdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsK0JBQW1COzs7O0FBSTdELGVBQWUsK0JBQW1CO0FBQ2xDLHVCQUF1QiwrQkFBbUI7QUFDMUMsZ0JBQWdCLCtCQUFtQjtBQUNuQyxlQUFlLCtCQUFtQjtBQUNsQyxlQUFlLCtCQUFtQjtBQUNsQyxvQkFBb0IsK0JBQW1CO0FBQ3ZDLHdCQUF3QiwrQkFBbUI7QUFDM0Msd0JBQXdCLCtCQUFtQjtBQUMzQyxzQkFBc0IsK0JBQW1CO0FBQ3pDLFlBQVksK0JBQW1CO0FBQy9CLGFBQWEsK0JBQW1CO0FBQ2hDLGlCQUFpQiwrQkFBbUI7QUFDcEMsYUFBYSwrQkFBbUI7QUFDaEMsY0FBYywrQkFBbUI7QUFDakMsZ0JBQWdCLCtCQUFtQjtBQUNuQyxhQUFhLCtCQUFtQjtBQUNoQyxnQkFBZ0IsK0JBQW1CO0FBQ25DLGlCQUFpQiwrQkFBbUI7O0FBRXBDO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCLHlCQUF5QjtBQUN6Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsMEhBQTBIO0FBQzFILFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtS0FBbUs7QUFDbks7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOEJBQThCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdDQUFnQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQywyQkFBMkI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQSw0RUFBNEUseUNBQXlDO0FBQ3JILDZFQUE2RSx1Q0FBdUM7QUFDcEgsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSwyQ0FBMkM7QUFDcEgsNEVBQTRFLHFDQUFxQztBQUNqSDtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ04sNENBQTRDO0FBQzVDLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtDQUFrQztBQUN4RDtBQUNBLHdCQUF3QixxQ0FBcUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUNBQXFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQ0FBb0M7QUFDMUQ7QUFDQSx3QkFBd0IsdUNBQXVDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVDQUF1QztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTixzQkFBc0Isd0NBQXdDO0FBQzlEO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0Isc0NBQXNDO0FBQzVEO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFB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ZGVfbW9kdWxlcy9jb3NlLWJhc2UvY29zZS1iYXNlLmpzP2YxMDkiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwibGF5b3V0LWJhc2VcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wibGF5b3V0LWJhc2VcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiY29zZUJhc2VcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJsYXlvdXQtYmFzZVwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiY29zZUJhc2VcIl0gPSBmYWN0b3J5KHJvb3RbXCJsYXlvdXRCYXNlXCJdKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzU1MV9fKSB7XG5yZXR1cm4gLyoqKioqKi8gKCgpID0+IHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHRcInVzZSBzdHJpY3RcIjtcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyA0NTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG5cbnZhciBjb3NlQmFzZSA9IHt9O1xuXG5jb3NlQmFzZS5sYXlvdXRCYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpO1xuY29zZUJhc2UuQ29TRUNvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oODA2KTtcbmNvc2VCYXNlLkNvU0VFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NjcpO1xuY29zZUJhc2UuQ29TRUdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4ODApO1xuY29zZUJhc2UuQ29TRUdyYXBoTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNTc4KTtcbmNvc2VCYXNlLkNvU0VMYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2NSk7XG5jb3NlQmFzZS5Db1NFTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oOTkxKTtcbmNvc2VCYXNlLkNvbnN0cmFpbnRIYW5kbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MDIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvc2VCYXNlO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gODA2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxudmFyIEZETGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLkZETGF5b3V0Q29uc3RhbnRzO1xuXG5mdW5jdGlvbiBDb1NFQ29uc3RhbnRzKCkge31cblxuLy9Db1NFQ29uc3RhbnRzIGluaGVyaXRzIHN0YXRpYyBwcm9wcyBpbiBGRExheW91dENvbnN0YW50c1xuZm9yICh2YXIgcHJvcCBpbiBGRExheW91dENvbnN0YW50cykge1xuICBDb1NFQ29uc3RhbnRzW3Byb3BdID0gRkRMYXlvdXRDb25zdGFudHNbcHJvcF07XG59XG5cbkNvU0VDb25zdGFudHMuREVGQVVMVF9VU0VfTVVMVElfTEVWRUxfU0NBTElORyA9IGZhbHNlO1xuQ29TRUNvbnN0YW50cy5ERUZBVUxUX1JBRElBTF9TRVBBUkFUSU9OID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSDtcbkNvU0VDb25zdGFudHMuREVGQVVMVF9DT01QT05FTlRfU0VQRVJBVElPTiA9IDYwO1xuQ29TRUNvbnN0YW50cy5USUxFID0gdHJ1ZTtcbkNvU0VDb25zdGFudHMuVElMSU5HX1BBRERJTkdfVkVSVElDQUwgPSAxMDtcbkNvU0VDb25zdGFudHMuVElMSU5HX1BBRERJTkdfSE9SSVpPTlRBTCA9IDEwO1xuQ29TRUNvbnN0YW50cy5UUkFOU0ZPUk1fT05fQ09OU1RSQUlOVF9IQU5ETElORyA9IHRydWU7XG5Db1NFQ29uc3RhbnRzLkVORk9SQ0VfQ09OU1RSQUlOVFMgPSB0cnVlO1xuQ29TRUNvbnN0YW50cy5BUFBMWV9MQVlPVVQgPSB0cnVlO1xuQ29TRUNvbnN0YW50cy5SRUxBWF9NT1ZFTUVOVF9PTl9DT05TVFJBSU5UUyA9IHRydWU7XG5Db1NFQ29uc3RhbnRzLlRSRUVfUkVEVUNUSU9OX09OX0lOQ1JFTUVOVEFMID0gdHJ1ZTsgLy8gdGhpcyBzaG91bGQgYmUgc2V0IHRvIGZhbHNlIGlmIHRoZXJlIHdpbGwgYmUgYSBjb25zdHJhaW50XG4vLyBUaGlzIGNvbnN0YW50IGlzIGZvciBkaWZmZXJlbnRpYXRpbmcgd2hldGhlciBhY3R1YWwgbGF5b3V0IGFsZ29yaXRobSB0aGF0IHVzZXMgY29zZS1iYXNlIHdhbnRzIHRvIGFwcGx5IG9ubHkgaW5jcmVtZW50YWwgbGF5b3V0IG9yIFxuLy8gYW4gaW5jcmVtZW50YWwgbGF5b3V0IG9uIHRvcCBvZiBhIHJhbmRvbWl6ZWQgbGF5b3V0LiBJZiBpdCBpcyBvbmx5IGluY3JlbWVudGFsIGxheW91dCwgdGhlbiB0aGlzIGNvbnN0YW50IHNob3VsZCBiZSB0cnVlLlxuQ29TRUNvbnN0YW50cy5QVVJFX0lOQ1JFTUVOVEFMID0gQ29TRUNvbnN0YW50cy5ERUZBVUxUX0lOQ1JFTUVOVEFMO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvU0VDb25zdGFudHM7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA3Njc6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG52YXIgRkRMYXlvdXRFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLkZETGF5b3V0RWRnZTtcblxuZnVuY3Rpb24gQ29TRUVkZ2Uoc291cmNlLCB0YXJnZXQsIHZFZGdlKSB7XG4gIEZETGF5b3V0RWRnZS5jYWxsKHRoaXMsIHNvdXJjZSwgdGFyZ2V0LCB2RWRnZSk7XG59XG5cbkNvU0VFZGdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRkRMYXlvdXRFZGdlLnByb3RvdHlwZSk7XG5mb3IgKHZhciBwcm9wIGluIEZETGF5b3V0RWRnZSkge1xuICBDb1NFRWRnZVtwcm9wXSA9IEZETGF5b3V0RWRnZVtwcm9wXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb1NFRWRnZTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDg4MDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG5cbnZhciBMR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuTEdyYXBoO1xuXG5mdW5jdGlvbiBDb1NFR3JhcGgocGFyZW50LCBncmFwaE1nciwgdkdyYXBoKSB7XG4gIExHcmFwaC5jYWxsKHRoaXMsIHBhcmVudCwgZ3JhcGhNZ3IsIHZHcmFwaCk7XG59XG5cbkNvU0VHcmFwaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExHcmFwaC5wcm90b3R5cGUpO1xuZm9yICh2YXIgcHJvcCBpbiBMR3JhcGgpIHtcbiAgQ29TRUdyYXBoW3Byb3BdID0gTEdyYXBoW3Byb3BdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvU0VHcmFwaDtcblxuLyoqKi8gfSksXG5cbi8qKiovIDU3ODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG5cbnZhciBMR3JhcGhNYW5hZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLkxHcmFwaE1hbmFnZXI7XG5cbmZ1bmN0aW9uIENvU0VHcmFwaE1hbmFnZXIobGF5b3V0KSB7XG4gIExHcmFwaE1hbmFnZXIuY2FsbCh0aGlzLCBsYXlvdXQpO1xufVxuXG5Db1NFR3JhcGhNYW5hZ2VyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTEdyYXBoTWFuYWdlci5wcm90b3R5cGUpO1xuZm9yICh2YXIgcHJvcCBpbiBMR3JhcGhNYW5hZ2VyKSB7XG4gIENvU0VHcmFwaE1hbmFnZXJbcHJvcF0gPSBMR3JhcGhNYW5hZ2VyW3Byb3BdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvU0VHcmFwaE1hbmFnZXI7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NjU6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG52YXIgRkRMYXlvdXQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuRkRMYXlvdXQ7XG52YXIgQ29TRUdyYXBoTWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNTc4KTtcbnZhciBDb1NFR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg4MCk7XG52YXIgQ29TRU5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk5MSk7XG52YXIgQ29TRUVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc2Nyk7XG52YXIgQ29TRUNvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oODA2KTtcbnZhciBDb25zdHJhaW50SGFuZGxlciA9IF9fd2VicGFja19yZXF1aXJlX18oOTAyKTtcbnZhciBGRExheW91dENvbnN0YW50cyA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5GRExheW91dENvbnN0YW50cztcbnZhciBMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuTGF5b3V0Q29uc3RhbnRzO1xudmFyIFBvaW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLlBvaW50O1xudmFyIFBvaW50RCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5Qb2ludEQ7XG52YXIgRGltZW5zaW9uRCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5EaW1lbnNpb25EO1xudmFyIExheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5MYXlvdXQ7XG52YXIgSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5JbnRlZ2VyO1xudmFyIElHZW9tZXRyeSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5JR2VvbWV0cnk7XG52YXIgTEdyYXBoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLkxHcmFwaDtcbnZhciBUcmFuc2Zvcm0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuVHJhbnNmb3JtO1xudmFyIExpbmtlZExpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MSkuTGlua2VkTGlzdDtcblxuZnVuY3Rpb24gQ29TRUxheW91dCgpIHtcbiAgRkRMYXlvdXQuY2FsbCh0aGlzKTtcblxuICB0aGlzLnRvQmVUaWxlZCA9IHt9OyAvLyBNZW1vcml6ZSBpZiBhIG5vZGUgaXMgdG8gYmUgdGlsZWQgb3IgaXMgdGlsZWRcbiAgdGhpcy5jb25zdHJhaW50cyA9IHt9OyAvLyBrZWVwIGxheW91dCBjb25zdHJhaW50c1xufVxuXG5Db1NFTGF5b3V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRkRMYXlvdXQucHJvdG90eXBlKTtcblxuZm9yICh2YXIgcHJvcCBpbiBGRExheW91dCkge1xuICBDb1NFTGF5b3V0W3Byb3BdID0gRkRMYXlvdXRbcHJvcF07XG59XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLm5ld0dyYXBoTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGdtID0gbmV3IENvU0VHcmFwaE1hbmFnZXIodGhpcyk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyID0gZ207XG4gIHJldHVybiBnbTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLm5ld0dyYXBoID0gZnVuY3Rpb24gKHZHcmFwaCkge1xuICByZXR1cm4gbmV3IENvU0VHcmFwaChudWxsLCB0aGlzLmdyYXBoTWFuYWdlciwgdkdyYXBoKTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLm5ld05vZGUgPSBmdW5jdGlvbiAodk5vZGUpIHtcbiAgcmV0dXJuIG5ldyBDb1NFTm9kZSh0aGlzLmdyYXBoTWFuYWdlciwgdk5vZGUpO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUubmV3RWRnZSA9IGZ1bmN0aW9uICh2RWRnZSkge1xuICByZXR1cm4gbmV3IENvU0VFZGdlKG51bGwsIG51bGwsIHZFZGdlKTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmluaXRQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkge1xuICBGRExheW91dC5wcm90b3R5cGUuaW5pdFBhcmFtZXRlcnMuY2FsbCh0aGlzLCBhcmd1bWVudHMpO1xuICBpZiAoIXRoaXMuaXNTdWJMYXlvdXQpIHtcbiAgICBpZiAoQ29TRUNvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIIDwgMTApIHtcbiAgICAgIHRoaXMuaWRlYWxFZGdlTGVuZ3RoID0gMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaWRlYWxFZGdlTGVuZ3RoID0gQ29TRUNvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIO1xuICAgIH1cblxuICAgIHRoaXMudXNlU21hcnRJZGVhbEVkZ2VMZW5ndGhDYWxjdWxhdGlvbiA9IENvU0VDb25zdGFudHMuREVGQVVMVF9VU0VfU01BUlRfSURFQUxfRURHRV9MRU5HVEhfQ0FMQ1VMQVRJT047XG4gICAgdGhpcy5ncmF2aXR5Q29uc3RhbnQgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVZJVFlfU1RSRU5HVEg7XG4gICAgdGhpcy5jb21wb3VuZEdyYXZpdHlDb25zdGFudCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9TVFJFTkdUSDtcbiAgICB0aGlzLmdyYXZpdHlSYW5nZUZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9SQU5HRV9GQUNUT1I7XG4gICAgdGhpcy5jb21wb3VuZEdyYXZpdHlSYW5nZUZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9SQU5HRV9GQUNUT1I7XG5cbiAgICAvLyB2YXJpYWJsZXMgZm9yIHRyZWUgcmVkdWN0aW9uIHN1cHBvcnRcbiAgICB0aGlzLnBydW5lZE5vZGVzQWxsID0gW107XG4gICAgdGhpcy5ncm93VHJlZUl0ZXJhdGlvbnMgPSAwO1xuICAgIHRoaXMuYWZ0ZXJHcm93dGhJdGVyYXRpb25zID0gMDtcbiAgICB0aGlzLmlzVHJlZUdyb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmlzR3Jvd3RoRmluaXNoZWQgPSBmYWxzZTtcbiAgfVxufTtcblxuLy8gVGhpcyBtZXRob2QgaXMgdXNlZCB0byBzZXQgQ29TRSByZWxhdGVkIHBhcmFtZXRlcnMgdXNlZCBieSBzcHJpbmcgZW1iZWRkZXIuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5pbml0U3ByaW5nRW1iZWRkZXIgPSBmdW5jdGlvbiAoKSB7XG4gIEZETGF5b3V0LnByb3RvdHlwZS5pbml0U3ByaW5nRW1iZWRkZXIuY2FsbCh0aGlzKTtcblxuICAvLyB2YXJpYWJsZXMgZm9yIGNvb2xpbmdcbiAgdGhpcy5jb29saW5nQ3ljbGUgPSAwO1xuICB0aGlzLm1heENvb2xpbmdDeWNsZSA9IHRoaXMubWF4SXRlcmF0aW9ucyAvIEZETGF5b3V0Q29uc3RhbnRzLkNPTlZFUkdFTkNFX0NIRUNLX1BFUklPRDtcbiAgdGhpcy5maW5hbFRlbXBlcmF0dXJlID0gMC4wNDtcbiAgdGhpcy5jb29saW5nQWRqdXN0ZXIgPSAxO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUubGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY3JlYXRlQmVuZHNBc05lZWRlZCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0NSRUFURV9CRU5EU19BU19ORUVERUQ7XG4gIGlmIChjcmVhdGVCZW5kc0FzTmVlZGVkKSB7XG4gICAgdGhpcy5jcmVhdGVCZW5kcG9pbnRzKCk7XG4gICAgdGhpcy5ncmFwaE1hbmFnZXIucmVzZXRBbGxFZGdlcygpO1xuICB9XG5cbiAgdGhpcy5sZXZlbCA9IDA7XG4gIHJldHVybiB0aGlzLmNsYXNzaWNMYXlvdXQoKTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmNsYXNzaWNMYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubm9kZXNXaXRoR3Jhdml0eSA9IHRoaXMuY2FsY3VsYXRlTm9kZXNUb0FwcGx5R3Jhdml0YXRpb25UbygpO1xuICB0aGlzLmdyYXBoTWFuYWdlci5zZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbih0aGlzLm5vZGVzV2l0aEdyYXZpdHkpO1xuICB0aGlzLmNhbGNOb09mQ2hpbGRyZW5Gb3JBbGxOb2RlcygpO1xuICB0aGlzLmdyYXBoTWFuYWdlci5jYWxjTG93ZXN0Q29tbW9uQW5jZXN0b3JzKCk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLmNhbGNJbmNsdXNpb25UcmVlRGVwdGhzKCk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKS5jYWxjRXN0aW1hdGVkU2l6ZSgpO1xuICB0aGlzLmNhbGNJZGVhbEVkZ2VMZW5ndGhzKCk7XG5cbiAgaWYgKCF0aGlzLmluY3JlbWVudGFsKSB7XG4gICAgdmFyIGZvcmVzdCA9IHRoaXMuZ2V0RmxhdEZvcmVzdCgpO1xuXG4gICAgLy8gVGhlIGdyYXBoIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxheW91dCBpcyBmbGF0IGFuZCBhIGZvcmVzdFxuICAgIGlmIChmb3Jlc3QubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5wb3NpdGlvbk5vZGVzUmFkaWFsbHkoZm9yZXN0KTtcbiAgICB9XG4gICAgLy8gVGhlIGdyYXBoIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxheW91dCBpcyBub3QgZmxhdCBvciBhIGZvcmVzdFxuICAgIGVsc2Uge1xuICAgICAgICAvLyBSZWR1Y2UgdGhlIHRyZWVzIHdoZW4gaW5jcmVtZW50YWwgbW9kZSBpcyBub3QgZW5hYmxlZCBhbmQgZ3JhcGggaXMgbm90IGEgZm9yZXN0IFxuICAgICAgICB0aGlzLnJlZHVjZVRyZWVzKCk7XG4gICAgICAgIC8vIFVwZGF0ZSBub2RlcyB0aGF0IGdyYXZpdHkgd2lsbCBiZSBhcHBsaWVkXG4gICAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oKTtcbiAgICAgICAgdmFyIGFsbE5vZGVzID0gbmV3IFNldCh0aGlzLmdldEFsbE5vZGVzKCkpO1xuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gdGhpcy5ub2Rlc1dpdGhHcmF2aXR5LmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIHJldHVybiBhbGxOb2Rlcy5oYXMoeCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmdyYXBoTWFuYWdlci5zZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbihpbnRlcnNlY3Rpb24pO1xuXG4gICAgICAgIHRoaXMucG9zaXRpb25Ob2Rlc1JhbmRvbWx5KCk7XG4gICAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKENvU0VDb25zdGFudHMuVFJFRV9SRURVQ1RJT05fT05fSU5DUkVNRU5UQUwpIHtcbiAgICAgIC8vIFJlZHVjZSB0aGUgdHJlZXMgaW4gaW5jcmVtZW50YWwgbW9kZSBpZiBvbmx5IHRoaXMgY29uc3RhbnQgaXMgc2V0IHRvIHRydWUgXG4gICAgICB0aGlzLnJlZHVjZVRyZWVzKCk7XG4gICAgICAvLyBVcGRhdGUgbm9kZXMgdGhhdCBncmF2aXR5IHdpbGwgYmUgYXBwbGllZFxuICAgICAgdGhpcy5ncmFwaE1hbmFnZXIucmVzZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbigpO1xuICAgICAgdmFyIGFsbE5vZGVzID0gbmV3IFNldCh0aGlzLmdldEFsbE5vZGVzKCkpO1xuICAgICAgdmFyIGludGVyc2VjdGlvbiA9IHRoaXMubm9kZXNXaXRoR3Jhdml0eS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIGFsbE5vZGVzLmhhcyh4KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ncmFwaE1hbmFnZXIuc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24oaW50ZXJzZWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXModGhpcy5jb25zdHJhaW50cykubGVuZ3RoID4gMCkge1xuICAgIENvbnN0cmFpbnRIYW5kbGVyLmhhbmRsZUNvbnN0cmFpbnRzKHRoaXMpO1xuICAgIHRoaXMuaW5pdENvbnN0cmFpbnRWYXJpYWJsZXMoKTtcbiAgfVxuXG4gIHRoaXMuaW5pdFNwcmluZ0VtYmVkZGVyKCk7XG4gIGlmIChDb1NFQ29uc3RhbnRzLkFQUExZX0xBWU9VVCkge1xuICAgIHRoaXMucnVuU3ByaW5nRW1iZWRkZXIoKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy50b3RhbEl0ZXJhdGlvbnMrKztcblxuICBpZiAodGhpcy50b3RhbEl0ZXJhdGlvbnMgPT09IHRoaXMubWF4SXRlcmF0aW9ucyAmJiAhdGhpcy5pc1RyZWVHcm93aW5nICYmICF0aGlzLmlzR3Jvd3RoRmluaXNoZWQpIHtcbiAgICBpZiAodGhpcy5wcnVuZWROb2Rlc0FsbC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmlzVHJlZUdyb3dpbmcgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy50b3RhbEl0ZXJhdGlvbnMgJSBGRExheW91dENvbnN0YW50cy5DT05WRVJHRU5DRV9DSEVDS19QRVJJT0QgPT0gMCAmJiAhdGhpcy5pc1RyZWVHcm93aW5nICYmICF0aGlzLmlzR3Jvd3RoRmluaXNoZWQpIHtcbiAgICBpZiAodGhpcy5pc0NvbnZlcmdlZCgpKSB7XG4gICAgICBpZiAodGhpcy5wcnVuZWROb2Rlc0FsbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuaXNUcmVlR3Jvd2luZyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNvb2xpbmdDeWNsZSsrO1xuXG4gICAgaWYgKHRoaXMubGF5b3V0UXVhbGl0eSA9PSAwKSB7XG4gICAgICAvLyBxdWFsaXR5IC0gXCJkcmFmdFwiXG4gICAgICB0aGlzLmNvb2xpbmdBZGp1c3RlciA9IHRoaXMuY29vbGluZ0N5Y2xlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sYXlvdXRRdWFsaXR5ID09IDEpIHtcbiAgICAgIC8vIHF1YWxpdHkgLSBcImRlZmF1bHRcIlxuICAgICAgdGhpcy5jb29saW5nQWRqdXN0ZXIgPSB0aGlzLmNvb2xpbmdDeWNsZSAvIDM7XG4gICAgfVxuXG4gICAgLy8gY29vbGluZyBzY2hlZHVsZSBpcyBiYXNlZCBvbiBodHRwOi8vd3d3LmJ0bHVrZS5jb20vc2ltYW5mMS5odG1sIC0+IGNvb2xpbmcgc2NoZWR1bGUgM1xuICAgIHRoaXMuY29vbGluZ0ZhY3RvciA9IE1hdGgubWF4KHRoaXMuaW5pdGlhbENvb2xpbmdGYWN0b3IgLSBNYXRoLnBvdyh0aGlzLmNvb2xpbmdDeWNsZSwgTWF0aC5sb2coMTAwICogKHRoaXMuaW5pdGlhbENvb2xpbmdGYWN0b3IgLSB0aGlzLmZpbmFsVGVtcGVyYXR1cmUpKSAvIE1hdGgubG9nKHRoaXMubWF4Q29vbGluZ0N5Y2xlKSkgLyAxMDAgKiB0aGlzLmNvb2xpbmdBZGp1c3RlciwgdGhpcy5maW5hbFRlbXBlcmF0dXJlKTtcbiAgICB0aGlzLmFuaW1hdGlvblBlcmlvZCA9IE1hdGguY2VpbCh0aGlzLmluaXRpYWxBbmltYXRpb25QZXJpb2QgKiBNYXRoLnNxcnQodGhpcy5jb29saW5nRmFjdG9yKSk7XG4gIH1cbiAgLy8gT3BlcmF0aW9ucyB3aGlsZSB0cmVlIGlzIGdyb3dpbmcgYWdhaW4gXG4gIGlmICh0aGlzLmlzVHJlZUdyb3dpbmcpIHtcbiAgICBpZiAodGhpcy5ncm93VHJlZUl0ZXJhdGlvbnMgJSAxMCA9PSAwKSB7XG4gICAgICBpZiAodGhpcy5wcnVuZWROb2Rlc0FsbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnVwZGF0ZUJvdW5kcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZUdyaWQoKTtcbiAgICAgICAgdGhpcy5ncm93VHJlZSh0aGlzLnBydW5lZE5vZGVzQWxsKTtcbiAgICAgICAgLy8gVXBkYXRlIG5vZGVzIHRoYXQgZ3Jhdml0eSB3aWxsIGJlIGFwcGxpZWRcbiAgICAgICAgdGhpcy5ncmFwaE1hbmFnZXIucmVzZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbigpO1xuICAgICAgICB2YXIgYWxsTm9kZXMgPSBuZXcgU2V0KHRoaXMuZ2V0QWxsTm9kZXMoKSk7XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSB0aGlzLm5vZGVzV2l0aEdyYXZpdHkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgcmV0dXJuIGFsbE5vZGVzLmhhcyh4KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uKGludGVyc2VjdGlvbik7XG5cbiAgICAgICAgdGhpcy5ncmFwaE1hbmFnZXIudXBkYXRlQm91bmRzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlR3JpZCgpO1xuICAgICAgICBpZiAoQ29TRUNvbnN0YW50cy5QVVJFX0lOQ1JFTUVOVEFMKSB0aGlzLmNvb2xpbmdGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMIC8gMjtlbHNlIHRoaXMuY29vbGluZ0ZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09PTElOR19GQUNUT1JfSU5DUkVNRU5UQUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmlzVHJlZUdyb3dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0dyb3d0aEZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5ncm93VHJlZUl0ZXJhdGlvbnMrKztcbiAgfVxuICAvLyBPcGVyYXRpb25zIGFmdGVyIGdyb3d0aCBpcyBmaW5pc2hlZFxuICBpZiAodGhpcy5pc0dyb3d0aEZpbmlzaGVkKSB7XG4gICAgaWYgKHRoaXMuaXNDb252ZXJnZWQoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmFmdGVyR3Jvd3RoSXRlcmF0aW9ucyAlIDEwID09IDApIHtcbiAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnVwZGF0ZUJvdW5kcygpO1xuICAgICAgdGhpcy51cGRhdGVHcmlkKCk7XG4gICAgfVxuICAgIGlmIChDb1NFQ29uc3RhbnRzLlBVUkVfSU5DUkVNRU5UQUwpIHRoaXMuY29vbGluZ0ZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09PTElOR19GQUNUT1JfSU5DUkVNRU5UQUwgLyAyICogKCgxMDAgLSB0aGlzLmFmdGVyR3Jvd3RoSXRlcmF0aW9ucykgLyAxMDApO2Vsc2UgdGhpcy5jb29saW5nRmFjdG9yID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT09MSU5HX0ZBQ1RPUl9JTkNSRU1FTlRBTCAqICgoMTAwIC0gdGhpcy5hZnRlckdyb3d0aEl0ZXJhdGlvbnMpIC8gMTAwKTtcbiAgICB0aGlzLmFmdGVyR3Jvd3RoSXRlcmF0aW9ucysrO1xuICB9XG5cbiAgdmFyIGdyaWRVcGRhdGVBbGxvd2VkID0gIXRoaXMuaXNUcmVlR3Jvd2luZyAmJiAhdGhpcy5pc0dyb3d0aEZpbmlzaGVkO1xuICB2YXIgZm9yY2VUb05vZGVTdXJyb3VuZGluZ1VwZGF0ZSA9IHRoaXMuZ3Jvd1RyZWVJdGVyYXRpb25zICUgMTAgPT0gMSAmJiB0aGlzLmlzVHJlZUdyb3dpbmcgfHwgdGhpcy5hZnRlckdyb3d0aEl0ZXJhdGlvbnMgJSAxMCA9PSAxICYmIHRoaXMuaXNHcm93dGhGaW5pc2hlZDtcblxuICB0aGlzLnRvdGFsRGlzcGxhY2VtZW50ID0gMDtcbiAgdGhpcy5ncmFwaE1hbmFnZXIudXBkYXRlQm91bmRzKCk7XG4gIHRoaXMuY2FsY1NwcmluZ0ZvcmNlcygpO1xuICB0aGlzLmNhbGNSZXB1bHNpb25Gb3JjZXMoZ3JpZFVwZGF0ZUFsbG93ZWQsIGZvcmNlVG9Ob2RlU3Vycm91bmRpbmdVcGRhdGUpO1xuICB0aGlzLmNhbGNHcmF2aXRhdGlvbmFsRm9yY2VzKCk7XG4gIHRoaXMubW92ZU5vZGVzKCk7XG4gIHRoaXMuYW5pbWF0ZSgpO1xuXG4gIHJldHVybiBmYWxzZTsgLy8gTGF5b3V0IGlzIG5vdCBlbmRlZCB5ZXQgcmV0dXJuIGZhbHNlXG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5nZXRQb3NpdGlvbnNEYXRhID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYWxsTm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxOb2RlcygpO1xuICB2YXIgcERhdGEgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciByZWN0ID0gYWxsTm9kZXNbaV0ucmVjdDtcbiAgICB2YXIgaWQgPSBhbGxOb2Rlc1tpXS5pZDtcbiAgICBwRGF0YVtpZF0gPSB7XG4gICAgICBpZDogaWQsXG4gICAgICB4OiByZWN0LmdldENlbnRlclgoKSxcbiAgICAgIHk6IHJlY3QuZ2V0Q2VudGVyWSgpLFxuICAgICAgdzogcmVjdC53aWR0aCxcbiAgICAgIGg6IHJlY3QuaGVpZ2h0XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBwRGF0YTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnJ1blNwcmluZ0VtYmVkZGVyID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmluaXRpYWxBbmltYXRpb25QZXJpb2QgPSAyNTtcbiAgdGhpcy5hbmltYXRpb25QZXJpb2QgPSB0aGlzLmluaXRpYWxBbmltYXRpb25QZXJpb2Q7XG4gIHZhciBsYXlvdXRFbmRlZCA9IGZhbHNlO1xuXG4gIC8vIElmIGFtaW5hdGUgb3B0aW9uIGlzICdkdXJpbmcnIHNpZ25hbCB0aGF0IGxheW91dCBpcyBzdXBwb3NlZCB0byBzdGFydCBpdGVyYXRpbmdcbiAgaWYgKEZETGF5b3V0Q29uc3RhbnRzLkFOSU1BVEUgPT09ICdkdXJpbmcnKSB7XG4gICAgdGhpcy5lbWl0KCdsYXlvdXRzdGFydGVkJyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgYW1pbmF0ZSBvcHRpb24gaXMgJ2R1cmluZycgdGljaygpIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIG9uIGluZGV4LmpzXG4gICAgd2hpbGUgKCFsYXlvdXRFbmRlZCkge1xuICAgICAgbGF5b3V0RW5kZWQgPSB0aGlzLnRpY2soKTtcbiAgICB9XG5cbiAgICB0aGlzLmdyYXBoTWFuYWdlci51cGRhdGVCb3VuZHMoKTtcbiAgfVxufTtcblxuLy8gb3ZlcnJpZGVzIG1vdmVOb2RlcyBtZXRob2QgaW4gRkRMYXlvdXRcbkNvU0VMYXlvdXQucHJvdG90eXBlLm1vdmVOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxOb2RlcyA9IHRoaXMuZ2V0QWxsTm9kZXMoKTtcbiAgdmFyIG5vZGU7XG5cbiAgLy8gY2FsY3VsYXRlIGRpc3BsYWNlbWVudCBmb3IgZWFjaCBub2RlIFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIG5vZGUgPSBsTm9kZXNbaV07XG4gICAgbm9kZS5jYWxjdWxhdGVEaXNwbGFjZW1lbnQoKTtcbiAgfVxuXG4gIGlmIChPYmplY3Qua2V5cyh0aGlzLmNvbnN0cmFpbnRzKS5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy51cGRhdGVEaXNwbGFjZW1lbnRzKCk7XG4gIH1cblxuICAvLyBtb3ZlIGVhY2ggbm9kZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIG5vZGUgPSBsTm9kZXNbaV07XG4gICAgbm9kZS5tb3ZlKCk7XG4gIH1cbn07XG5cbi8vIGNvbnN0cmFpbnQgcmVsYXRlZCBtZXRob2RzOiBpbml0Q29uc3RyYWludFZhcmlhYmxlcyBhbmQgdXBkYXRlRGlzcGxhY2VtZW50c1xuXG4vLyBpbml0aWFsaXplIGNvbnN0cmFpbnQgcmVsYXRlZCB2YXJpYWJsZXNcbkNvU0VMYXlvdXQucHJvdG90eXBlLmluaXRDb25zdHJhaW50VmFyaWFibGVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuaWRUb05vZGVNYXAgPSBuZXcgTWFwKCk7XG4gIHRoaXMuZml4ZWROb2RlU2V0ID0gbmV3IFNldCgpO1xuXG4gIHZhciBhbGxOb2RlcyA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbE5vZGVzKCk7XG5cbiAgLy8gZmlsbCBpZFRvTm9kZU1hcFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBhbGxOb2Rlc1tpXTtcbiAgICB0aGlzLmlkVG9Ob2RlTWFwLnNldChub2RlLmlkLCBub2RlKTtcbiAgfVxuXG4gIC8vIGNhbGN1bGF0ZSBmaXhlZCBub2RlIHdlaWdodCBmb3IgZ2l2ZW4gY29tcG91bmQgbm9kZVxuICB2YXIgY2FsY3VsYXRlQ29tcG91bmRXZWlnaHQgPSBmdW5jdGlvbiBjYWxjdWxhdGVDb21wb3VuZFdlaWdodChjb21wb3VuZE5vZGUpIHtcbiAgICB2YXIgbm9kZXMgPSBjb21wb3VuZE5vZGUuZ2V0Q2hpbGQoKS5nZXROb2RlcygpO1xuICAgIHZhciBub2RlO1xuICAgIHZhciBmaXhlZE5vZGVXZWlnaHQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGlmIChub2RlLmdldENoaWxkKCkgPT0gbnVsbCkge1xuICAgICAgICBpZiAoc2VsZi5maXhlZE5vZGVTZXQuaGFzKG5vZGUuaWQpKSB7XG4gICAgICAgICAgZml4ZWROb2RlV2VpZ2h0ICs9IDEwMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZml4ZWROb2RlV2VpZ2h0ICs9IGNhbGN1bGF0ZUNvbXBvdW5kV2VpZ2h0KG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZml4ZWROb2RlV2VpZ2h0O1xuICB9O1xuXG4gIGlmICh0aGlzLmNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQpIHtcbiAgICAvLyBmaWxsIGZpeGVkTm9kZVNldFxuICAgIHRoaXMuY29uc3RyYWludHMuZml4ZWROb2RlQ29uc3RyYWludC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlRGF0YSkge1xuICAgICAgc2VsZi5maXhlZE5vZGVTZXQuYWRkKG5vZGVEYXRhLm5vZGVJZCk7XG4gICAgfSk7XG5cbiAgICAvLyBhc3NpZ24gZml4ZWQgbm9kZSB3ZWlnaHRzIHRvIGNvbXBvdW5kcyBpZiB0aGV5IGNvbnRhaW4gZml4ZWQgbm9kZXNcbiAgICB2YXIgYWxsTm9kZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxOb2RlcygpO1xuICAgIHZhciBub2RlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbm9kZSA9IGFsbE5vZGVzW2ldO1xuICAgICAgaWYgKG5vZGUuZ2V0Q2hpbGQoKSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBmaXhlZE5vZGVXZWlnaHQgPSBjYWxjdWxhdGVDb21wb3VuZFdlaWdodChub2RlKTtcbiAgICAgICAgaWYgKGZpeGVkTm9kZVdlaWdodCA+IDApIHtcbiAgICAgICAgICBub2RlLmZpeGVkTm9kZVdlaWdodCA9IGZpeGVkTm9kZVdlaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLmNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCkge1xuICAgIHZhciBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50ID0gbmV3IE1hcCgpO1xuICAgIHZhciBub2RlVG9EdW1teUZvckhvcml6b250YWxBbGlnbm1lbnQgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50ID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50ID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZml4ZWROb2Rlc09uSG9yaXpvbnRhbCA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLmZpeGVkTm9kZXNPblZlcnRpY2FsID0gbmV3IFNldCgpO1xuXG4gICAgLy8gZmlsbCBtYXBzIGFuZCBzZXRzXG4gICAgdGhpcy5maXhlZE5vZGVTZXQuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICBzZWxmLmZpeGVkTm9kZXNPbkhvcml6b250YWwuYWRkKG5vZGVJZCk7XG4gICAgICBzZWxmLmZpeGVkTm9kZXNPblZlcnRpY2FsLmFkZChub2RlSWQpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludCkge1xuICAgICAgaWYgKHRoaXMuY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC52ZXJ0aWNhbCkge1xuICAgICAgICB2YXIgdmVydGljYWxBbGlnbm1lbnQgPSB0aGlzLmNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljYWxBbGlnbm1lbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuc2V0KFwiZHVtbXlcIiArIGksIFtdKTtcbiAgICAgICAgICB2ZXJ0aWNhbEFsaWdubWVudFtpXS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIG5vZGVUb0R1bW15Rm9yVmVydGljYWxBbGlnbm1lbnQuc2V0KG5vZGVJZCwgXCJkdW1teVwiICsgaSk7XG4gICAgICAgICAgICBzZWxmLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KFwiZHVtbXlcIiArIGkpLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmZpeGVkTm9kZVNldC5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgICBzZWxmLmZpeGVkTm9kZXNPbkhvcml6b250YWwuYWRkKFwiZHVtbXlcIiArIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50Lmhvcml6b250YWwpIHtcbiAgICAgICAgdmFyIGhvcml6b250YWxBbGlnbm1lbnQgPSB0aGlzLmNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQuaG9yaXpvbnRhbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3Jpem9udGFsQWxpZ25tZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5kdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuc2V0KFwiZHVtbXlcIiArIGksIFtdKTtcbiAgICAgICAgICBob3Jpem9udGFsQWxpZ25tZW50W2ldLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50LnNldChub2RlSWQsIFwiZHVtbXlcIiArIGkpO1xuICAgICAgICAgICAgc2VsZi5kdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KFwiZHVtbXlcIiArIGkpLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmZpeGVkTm9kZVNldC5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgICBzZWxmLmZpeGVkTm9kZXNPblZlcnRpY2FsLmFkZChcImR1bW15XCIgKyBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChDb1NFQ29uc3RhbnRzLlJFTEFYX01PVkVNRU5UX09OX0NPTlNUUkFJTlRTKSB7XG5cbiAgICAgIHRoaXMuc2h1ZmZsZSA9IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICB2YXIgaiwgeCwgaTtcbiAgICAgICAgZm9yIChpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAyICogYXJyYXkubGVuZ3RoIC8gMzsgaS0tKSB7XG4gICAgICAgICAgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xuICAgICAgICAgIHggPSBhcnJheVtpXTtcbiAgICAgICAgICBhcnJheVtpXSA9IGFycmF5W2pdO1xuICAgICAgICAgIGFycmF5W2pdID0geDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLm5vZGVzSW5SZWxhdGl2ZUhvcml6b250YWwgPSBbXTtcbiAgICAgIHRoaXMubm9kZXNJblJlbGF0aXZlVmVydGljYWwgPSBbXTtcbiAgICAgIHRoaXMubm9kZVRvUmVsYXRpdmVDb25zdHJhaW50TWFwSG9yaXpvbnRhbCA9IG5ldyBNYXAoKTtcbiAgICAgIHRoaXMubm9kZVRvUmVsYXRpdmVDb25zdHJhaW50TWFwVmVydGljYWwgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLm5vZGVUb1RlbXBQb3NpdGlvbk1hcEhvcml6b250YWwgPSBuZXcgTWFwKCk7XG4gICAgICB0aGlzLm5vZGVUb1RlbXBQb3NpdGlvbk1hcFZlcnRpY2FsID0gbmV3IE1hcCgpO1xuXG4gICAgICAvLyBmaWxsIGFycmF5cyBhbmQgbWFwc1xuICAgICAgdGhpcy5jb25zdHJhaW50cy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQuZm9yRWFjaChmdW5jdGlvbiAoY29uc3RyYWludCkge1xuICAgICAgICBpZiAoY29uc3RyYWludC5sZWZ0KSB7XG4gICAgICAgICAgdmFyIG5vZGVJZExlZnQgPSBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50Lmhhcyhjb25zdHJhaW50LmxlZnQpID8gbm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudC5nZXQoY29uc3RyYWludC5sZWZ0KSA6IGNvbnN0cmFpbnQubGVmdDtcbiAgICAgICAgICB2YXIgbm9kZUlkUmlnaHQgPSBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50Lmhhcyhjb25zdHJhaW50LnJpZ2h0KSA/IG5vZGVUb0R1bW15Rm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KGNvbnN0cmFpbnQucmlnaHQpIDogY29uc3RyYWludC5yaWdodDtcblxuICAgICAgICAgIGlmICghc2VsZi5ub2Rlc0luUmVsYXRpdmVIb3Jpem9udGFsLmluY2x1ZGVzKG5vZGVJZExlZnQpKSB7XG4gICAgICAgICAgICBzZWxmLm5vZGVzSW5SZWxhdGl2ZUhvcml6b250YWwucHVzaChub2RlSWRMZWZ0KTtcbiAgICAgICAgICAgIHNlbGYubm9kZVRvUmVsYXRpdmVDb25zdHJhaW50TWFwSG9yaXpvbnRhbC5zZXQobm9kZUlkTGVmdCwgW10pO1xuICAgICAgICAgICAgaWYgKHNlbGYuZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudC5oYXMobm9kZUlkTGVmdCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBIb3Jpem9udGFsLnNldChub2RlSWRMZWZ0LCBzZWxmLmlkVG9Ob2RlTWFwLmdldChzZWxmLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KG5vZGVJZExlZnQpWzBdKS5nZXRDZW50ZXJYKCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBIb3Jpem9udGFsLnNldChub2RlSWRMZWZ0LCBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWRMZWZ0KS5nZXRDZW50ZXJYKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXNlbGYubm9kZXNJblJlbGF0aXZlSG9yaXpvbnRhbC5pbmNsdWRlcyhub2RlSWRSaWdodCkpIHtcbiAgICAgICAgICAgIHNlbGYubm9kZXNJblJlbGF0aXZlSG9yaXpvbnRhbC5wdXNoKG5vZGVJZFJpZ2h0KTtcbiAgICAgICAgICAgIHNlbGYubm9kZVRvUmVsYXRpdmVDb25zdHJhaW50TWFwSG9yaXpvbnRhbC5zZXQobm9kZUlkUmlnaHQsIFtdKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuaGFzKG5vZGVJZFJpZ2h0KSkge1xuICAgICAgICAgICAgICBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcEhvcml6b250YWwuc2V0KG5vZGVJZFJpZ2h0LCBzZWxmLmlkVG9Ob2RlTWFwLmdldChzZWxmLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KG5vZGVJZFJpZ2h0KVswXSkuZ2V0Q2VudGVyWCgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwSG9yaXpvbnRhbC5zZXQobm9kZUlkUmlnaHQsIHNlbGYuaWRUb05vZGVNYXAuZ2V0KG5vZGVJZFJpZ2h0KS5nZXRDZW50ZXJYKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYubm9kZVRvUmVsYXRpdmVDb25zdHJhaW50TWFwSG9yaXpvbnRhbC5nZXQobm9kZUlkTGVmdCkucHVzaCh7IHJpZ2h0OiBub2RlSWRSaWdodCwgZ2FwOiBjb25zdHJhaW50LmdhcCB9KTtcbiAgICAgICAgICBzZWxmLm5vZGVUb1JlbGF0aXZlQ29uc3RyYWludE1hcEhvcml6b250YWwuZ2V0KG5vZGVJZFJpZ2h0KS5wdXNoKHsgbGVmdDogbm9kZUlkTGVmdCwgZ2FwOiBjb25zdHJhaW50LmdhcCB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbm9kZUlkVG9wID0gbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50Lmhhcyhjb25zdHJhaW50LnRvcCkgPyBub2RlVG9EdW1teUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KGNvbnN0cmFpbnQudG9wKSA6IGNvbnN0cmFpbnQudG9wO1xuICAgICAgICAgIHZhciBub2RlSWRCb3R0b20gPSBub2RlVG9EdW1teUZvckhvcml6b250YWxBbGlnbm1lbnQuaGFzKGNvbnN0cmFpbnQuYm90dG9tKSA/IG5vZGVUb0R1bW15Rm9ySG9yaXpvbnRhbEFsaWdubWVudC5nZXQoY29uc3RyYWludC5ib3R0b20pIDogY29uc3RyYWludC5ib3R0b207XG5cbiAgICAgICAgICBpZiAoIXNlbGYubm9kZXNJblJlbGF0aXZlVmVydGljYWwuaW5jbHVkZXMobm9kZUlkVG9wKSkge1xuICAgICAgICAgICAgc2VsZi5ub2Rlc0luUmVsYXRpdmVWZXJ0aWNhbC5wdXNoKG5vZGVJZFRvcCk7XG4gICAgICAgICAgICBzZWxmLm5vZGVUb1JlbGF0aXZlQ29uc3RyYWludE1hcFZlcnRpY2FsLnNldChub2RlSWRUb3AsIFtdKTtcbiAgICAgICAgICAgIGlmIChzZWxmLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5oYXMobm9kZUlkVG9wKSkge1xuICAgICAgICAgICAgICBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcFZlcnRpY2FsLnNldChub2RlSWRUb3AsIHNlbGYuaWRUb05vZGVNYXAuZ2V0KHNlbGYuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChub2RlSWRUb3ApWzBdKS5nZXRDZW50ZXJZKCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBWZXJ0aWNhbC5zZXQobm9kZUlkVG9wLCBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWRUb3ApLmdldENlbnRlclkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc2VsZi5ub2Rlc0luUmVsYXRpdmVWZXJ0aWNhbC5pbmNsdWRlcyhub2RlSWRCb3R0b20pKSB7XG4gICAgICAgICAgICBzZWxmLm5vZGVzSW5SZWxhdGl2ZVZlcnRpY2FsLnB1c2gobm9kZUlkQm90dG9tKTtcbiAgICAgICAgICAgIHNlbGYubm9kZVRvUmVsYXRpdmVDb25zdHJhaW50TWFwVmVydGljYWwuc2V0KG5vZGVJZEJvdHRvbSwgW10pO1xuICAgICAgICAgICAgaWYgKHNlbGYuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50Lmhhcyhub2RlSWRCb3R0b20pKSB7XG4gICAgICAgICAgICAgIHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwVmVydGljYWwuc2V0KG5vZGVJZEJvdHRvbSwgc2VsZi5pZFRvTm9kZU1hcC5nZXQoc2VsZi5kdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KG5vZGVJZEJvdHRvbSlbMF0pLmdldENlbnRlclkoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcFZlcnRpY2FsLnNldChub2RlSWRCb3R0b20sIHNlbGYuaWRUb05vZGVNYXAuZ2V0KG5vZGVJZEJvdHRvbSkuZ2V0Q2VudGVyWSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5ub2RlVG9SZWxhdGl2ZUNvbnN0cmFpbnRNYXBWZXJ0aWNhbC5nZXQobm9kZUlkVG9wKS5wdXNoKHsgYm90dG9tOiBub2RlSWRCb3R0b20sIGdhcDogY29uc3RyYWludC5nYXAgfSk7XG4gICAgICAgICAgc2VsZi5ub2RlVG9SZWxhdGl2ZUNvbnN0cmFpbnRNYXBWZXJ0aWNhbC5nZXQobm9kZUlkQm90dG9tKS5wdXNoKHsgdG9wOiBub2RlSWRUb3AsIGdhcDogY29uc3RyYWludC5nYXAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3ViR3JhcGhPbkhvcml6b250YWwgPSBuZXcgTWFwKCk7IC8vIHN1YmdyYXBoIGZyb20gdmVydGljYWwgUlAgY29uc3RyYWludHNcbiAgICAgIHZhciBzdWJHcmFwaE9uVmVydGljYWwgPSBuZXcgTWFwKCk7IC8vIHN1YmdyYXBoIGZyb20gdmVydGljYWwgUlAgY29uc3RyYWludHNcblxuICAgICAgLy8gY29uc3RydWN0IHN1YmdyYXBocyBmcm9tIHJlbGF0aXZlIHBsYWNlbWVudCBjb25zdHJhaW50cyBcbiAgICAgIHRoaXMuY29uc3RyYWludHMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50LmZvckVhY2goZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgICAgaWYgKGNvbnN0cmFpbnQubGVmdCkge1xuICAgICAgICAgIHZhciBsZWZ0ID0gbm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudC5oYXMoY29uc3RyYWludC5sZWZ0KSA/IG5vZGVUb0R1bW15Rm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KGNvbnN0cmFpbnQubGVmdCkgOiBjb25zdHJhaW50LmxlZnQ7XG4gICAgICAgICAgdmFyIHJpZ2h0ID0gbm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudC5oYXMoY29uc3RyYWludC5yaWdodCkgPyBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChjb25zdHJhaW50LnJpZ2h0KSA6IGNvbnN0cmFpbnQucmlnaHQ7XG4gICAgICAgICAgaWYgKHN1YkdyYXBoT25Ib3Jpem9udGFsLmhhcyhsZWZ0KSkge1xuICAgICAgICAgICAgc3ViR3JhcGhPbkhvcml6b250YWwuZ2V0KGxlZnQpLnB1c2gocmlnaHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJHcmFwaE9uSG9yaXpvbnRhbC5zZXQobGVmdCwgW3JpZ2h0XSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdWJHcmFwaE9uSG9yaXpvbnRhbC5oYXMocmlnaHQpKSB7XG4gICAgICAgICAgICBzdWJHcmFwaE9uSG9yaXpvbnRhbC5nZXQocmlnaHQpLnB1c2gobGVmdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1YkdyYXBoT25Ib3Jpem9udGFsLnNldChyaWdodCwgW2xlZnRdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHRvcCA9IG5vZGVUb0R1bW15Rm9ySG9yaXpvbnRhbEFsaWdubWVudC5oYXMoY29uc3RyYWludC50b3ApID8gbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChjb25zdHJhaW50LnRvcCkgOiBjb25zdHJhaW50LnRvcDtcbiAgICAgICAgICB2YXIgYm90dG9tID0gbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50Lmhhcyhjb25zdHJhaW50LmJvdHRvbSkgPyBub2RlVG9EdW1teUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KGNvbnN0cmFpbnQuYm90dG9tKSA6IGNvbnN0cmFpbnQuYm90dG9tO1xuICAgICAgICAgIGlmIChzdWJHcmFwaE9uVmVydGljYWwuaGFzKHRvcCkpIHtcbiAgICAgICAgICAgIHN1YkdyYXBoT25WZXJ0aWNhbC5nZXQodG9wKS5wdXNoKGJvdHRvbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1YkdyYXBoT25WZXJ0aWNhbC5zZXQodG9wLCBbYm90dG9tXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdWJHcmFwaE9uVmVydGljYWwuaGFzKGJvdHRvbSkpIHtcbiAgICAgICAgICAgIHN1YkdyYXBoT25WZXJ0aWNhbC5nZXQoYm90dG9tKS5wdXNoKHRvcCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1YkdyYXBoT25WZXJ0aWNhbC5zZXQoYm90dG9tLCBbdG9wXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gZnVuY3Rpb24gdG8gY29uc3RydWN0IGNvbXBvbmVudHMgZnJvbSBhIGdpdmVuIGdyYXBoIFxuICAgICAgLy8gYWxzbyByZXR1cm5zIGFuIGFycmF5IHRoYXQga2VlcHMgd2hldGhlciBlYWNoIGNvbXBvbmVudCBjb250YWlucyBmaXhlZCBub2RlXG4gICAgICB2YXIgY29uc3RydWN0Q29tcG9uZW50cyA9IGZ1bmN0aW9uIGNvbnN0cnVjdENvbXBvbmVudHMoZ3JhcGgsIGZpeGVkTm9kZXMpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgdmFyIGlzRml4ZWQgPSBbXTtcbiAgICAgICAgdmFyIHF1ZXVlID0gbmV3IExpbmtlZExpc3QoKTtcbiAgICAgICAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICAgICAgZ3JhcGguZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgIGlmICghdmlzaXRlZC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgY29tcG9uZW50c1tjb3VudF0gPSBbXTtcbiAgICAgICAgICAgIGlzRml4ZWRbY291bnRdID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgY3VycmVudE5vZGUgPSBrZXk7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgIHZpc2l0ZWQuYWRkKGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgIGNvbXBvbmVudHNbY291bnRdLnB1c2goY3VycmVudE5vZGUpO1xuXG4gICAgICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoICE9IDApIHtcbiAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICBpZiAoZml4ZWROb2Rlcy5oYXMoY3VycmVudE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgaXNGaXhlZFtjb3VudF0gPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBuZWlnaGJvcnMgPSBncmFwaC5nZXQoY3VycmVudE5vZGUpO1xuICAgICAgICAgICAgICBuZWlnaGJvcnMuZm9yRWFjaChmdW5jdGlvbiAobmVpZ2hib3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZpc2l0ZWQuaGFzKG5laWdoYm9yKSkge1xuICAgICAgICAgICAgICAgICAgcXVldWUucHVzaChuZWlnaGJvcik7XG4gICAgICAgICAgICAgICAgICB2aXNpdGVkLmFkZChuZWlnaGJvcik7XG4gICAgICAgICAgICAgICAgICBjb21wb25lbnRzW2NvdW50XS5wdXNoKG5laWdoYm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7IGNvbXBvbmVudHM6IGNvbXBvbmVudHMsIGlzRml4ZWQ6IGlzRml4ZWQgfTtcbiAgICAgIH07XG5cbiAgICAgIHZhciByZXN1bHRPbkhvcml6b250YWwgPSBjb25zdHJ1Y3RDb21wb25lbnRzKHN1YkdyYXBoT25Ib3Jpem9udGFsLCBzZWxmLmZpeGVkTm9kZXNPbkhvcml6b250YWwpO1xuICAgICAgdGhpcy5jb21wb25lbnRzT25Ib3Jpem9udGFsID0gcmVzdWx0T25Ib3Jpem9udGFsLmNvbXBvbmVudHM7XG4gICAgICB0aGlzLmZpeGVkQ29tcG9uZW50c09uSG9yaXpvbnRhbCA9IHJlc3VsdE9uSG9yaXpvbnRhbC5pc0ZpeGVkO1xuICAgICAgdmFyIHJlc3VsdE9uVmVydGljYWwgPSBjb25zdHJ1Y3RDb21wb25lbnRzKHN1YkdyYXBoT25WZXJ0aWNhbCwgc2VsZi5maXhlZE5vZGVzT25WZXJ0aWNhbCk7XG4gICAgICB0aGlzLmNvbXBvbmVudHNPblZlcnRpY2FsID0gcmVzdWx0T25WZXJ0aWNhbC5jb21wb25lbnRzO1xuICAgICAgdGhpcy5maXhlZENvbXBvbmVudHNPblZlcnRpY2FsID0gcmVzdWx0T25WZXJ0aWNhbC5pc0ZpeGVkO1xuICAgIH1cbiAgfVxufTtcblxuLy8gdXBkYXRlcyBub2RlIGRpc3BsYWNlbWVudHMgYmFzZWQgb24gY29uc3RyYWludHNcbkNvU0VMYXlvdXQucHJvdG90eXBlLnVwZGF0ZURpc3BsYWNlbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHRoaXMuY29uc3RyYWludHMuZml4ZWROb2RlQ29uc3RyYWludCkge1xuICAgIHRoaXMuY29uc3RyYWludHMuZml4ZWROb2RlQ29uc3RyYWludC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlRGF0YSkge1xuICAgICAgdmFyIGZpeGVkTm9kZSA9IHNlbGYuaWRUb05vZGVNYXAuZ2V0KG5vZGVEYXRhLm5vZGVJZCk7XG4gICAgICBmaXhlZE5vZGUuZGlzcGxhY2VtZW50WCA9IDA7XG4gICAgICBmaXhlZE5vZGUuZGlzcGxhY2VtZW50WSA9IDA7XG4gICAgfSk7XG4gIH1cblxuICBpZiAodGhpcy5jb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50KSB7XG4gICAgaWYgKHRoaXMuY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC52ZXJ0aWNhbCkge1xuICAgICAgdmFyIGFsbFZlcnRpY2FsQWxpZ25tZW50cyA9IHRoaXMuY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC52ZXJ0aWNhbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsVmVydGljYWxBbGlnbm1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0b3RhbERpc3BsYWNlbWVudFggPSAwO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFsbFZlcnRpY2FsQWxpZ25tZW50c1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmICh0aGlzLmZpeGVkTm9kZVNldC5oYXMoYWxsVmVydGljYWxBbGlnbm1lbnRzW2ldW2pdKSkge1xuICAgICAgICAgICAgdG90YWxEaXNwbGFjZW1lbnRYID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b3RhbERpc3BsYWNlbWVudFggKz0gdGhpcy5pZFRvTm9kZU1hcC5nZXQoYWxsVmVydGljYWxBbGlnbm1lbnRzW2ldW2pdKS5kaXNwbGFjZW1lbnRYO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdmVyYWdlRGlzcGxhY2VtZW50WCA9IHRvdGFsRGlzcGxhY2VtZW50WCAvIGFsbFZlcnRpY2FsQWxpZ25tZW50c1tpXS5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYWxsVmVydGljYWxBbGlnbm1lbnRzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdGhpcy5pZFRvTm9kZU1hcC5nZXQoYWxsVmVydGljYWxBbGlnbm1lbnRzW2ldW2pdKS5kaXNwbGFjZW1lbnRYID0gYXZlcmFnZURpc3BsYWNlbWVudFg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC5ob3Jpem9udGFsKSB7XG4gICAgICB2YXIgYWxsSG9yaXpvbnRhbEFsaWdubWVudHMgPSB0aGlzLmNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQuaG9yaXpvbnRhbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsSG9yaXpvbnRhbEFsaWdubWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRvdGFsRGlzcGxhY2VtZW50WSA9IDA7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYWxsSG9yaXpvbnRhbEFsaWdubWVudHNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5maXhlZE5vZGVTZXQuaGFzKGFsbEhvcml6b250YWxBbGlnbm1lbnRzW2ldW2pdKSkge1xuICAgICAgICAgICAgdG90YWxEaXNwbGFjZW1lbnRZID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b3RhbERpc3BsYWNlbWVudFkgKz0gdGhpcy5pZFRvTm9kZU1hcC5nZXQoYWxsSG9yaXpvbnRhbEFsaWdubWVudHNbaV1bal0pLmRpc3BsYWNlbWVudFk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF2ZXJhZ2VEaXNwbGFjZW1lbnRZID0gdG90YWxEaXNwbGFjZW1lbnRZIC8gYWxsSG9yaXpvbnRhbEFsaWdubWVudHNbaV0ubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFsbEhvcml6b250YWxBbGlnbm1lbnRzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdGhpcy5pZFRvTm9kZU1hcC5nZXQoYWxsSG9yaXpvbnRhbEFsaWdubWVudHNbaV1bal0pLmRpc3BsYWNlbWVudFkgPSBhdmVyYWdlRGlzcGxhY2VtZW50WTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLmNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCkge1xuXG4gICAgaWYgKENvU0VDb25zdGFudHMuUkVMQVhfTU9WRU1FTlRfT05fQ09OU1RSQUlOVFMpIHtcbiAgICAgIC8vIHNodWZmbGUgYXJyYXkgdG8gcmFuZG9taXplIG5vZGUgcHJvY2Vzc2luZyBvcmRlclxuICAgICAgaWYgKHRoaXMudG90YWxJdGVyYXRpb25zICUgMTAgPT0gMCkge1xuICAgICAgICB0aGlzLnNodWZmbGUodGhpcy5ub2Rlc0luUmVsYXRpdmVIb3Jpem9udGFsKTtcbiAgICAgICAgdGhpcy5zaHVmZmxlKHRoaXMubm9kZXNJblJlbGF0aXZlVmVydGljYWwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5vZGVzSW5SZWxhdGl2ZUhvcml6b250YWwuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgIGlmICghc2VsZi5maXhlZE5vZGVzT25Ib3Jpem9udGFsLmhhcyhub2RlSWQpKSB7XG4gICAgICAgICAgdmFyIGRpc3BsYWNlbWVudCA9IDA7XG4gICAgICAgICAgaWYgKHNlbGYuZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudC5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgZGlzcGxhY2VtZW50ID0gc2VsZi5pZFRvTm9kZU1hcC5nZXQoc2VsZi5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChub2RlSWQpWzBdKS5kaXNwbGFjZW1lbnRYO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXNwbGFjZW1lbnQgPSBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWQpLmRpc3BsYWNlbWVudFg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYubm9kZVRvUmVsYXRpdmVDb25zdHJhaW50TWFwSG9yaXpvbnRhbC5nZXQobm9kZUlkKS5mb3JFYWNoKGZ1bmN0aW9uIChjb25zdHJhaW50KSB7XG4gICAgICAgICAgICBpZiAoY29uc3RyYWludC5yaWdodCkge1xuICAgICAgICAgICAgICB2YXIgZGlmZiA9IHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwSG9yaXpvbnRhbC5nZXQoY29uc3RyYWludC5yaWdodCkgLSBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcEhvcml6b250YWwuZ2V0KG5vZGVJZCkgLSBkaXNwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgIGlmIChkaWZmIDwgY29uc3RyYWludC5nYXApIHtcbiAgICAgICAgICAgICAgICBkaXNwbGFjZW1lbnQgLT0gY29uc3RyYWludC5nYXAgLSBkaWZmO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgZGlmZiA9IHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwSG9yaXpvbnRhbC5nZXQobm9kZUlkKSAtIHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwSG9yaXpvbnRhbC5nZXQoY29uc3RyYWludC5sZWZ0KSArIGRpc3BsYWNlbWVudDtcbiAgICAgICAgICAgICAgaWYgKGRpZmYgPCBjb25zdHJhaW50LmdhcCkge1xuICAgICAgICAgICAgICAgIGRpc3BsYWNlbWVudCArPSBjb25zdHJhaW50LmdhcCAtIGRpZmY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcEhvcml6b250YWwuc2V0KG5vZGVJZCwgc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBIb3Jpem9udGFsLmdldChub2RlSWQpICsgZGlzcGxhY2VtZW50KTtcbiAgICAgICAgICBpZiAoc2VsZi5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50Lmhhcyhub2RlSWQpKSB7XG4gICAgICAgICAgICBzZWxmLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KG5vZGVJZCkuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICAgIHNlbGYuaWRUb05vZGVNYXAuZ2V0KG5vZGVJZCkuZGlzcGxhY2VtZW50WCA9IGRpc3BsYWNlbWVudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWQpLmRpc3BsYWNlbWVudFggPSBkaXNwbGFjZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5ub2Rlc0luUmVsYXRpdmVWZXJ0aWNhbC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgaWYgKCFzZWxmLmZpeGVkTm9kZXNPbkhvcml6b250YWwuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICB2YXIgZGlzcGxhY2VtZW50ID0gMDtcbiAgICAgICAgICBpZiAoc2VsZi5kdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICAgIGRpc3BsYWNlbWVudCA9IHNlbGYuaWRUb05vZGVNYXAuZ2V0KHNlbGYuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChub2RlSWQpWzBdKS5kaXNwbGFjZW1lbnRZO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXNwbGFjZW1lbnQgPSBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWQpLmRpc3BsYWNlbWVudFk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYubm9kZVRvUmVsYXRpdmVDb25zdHJhaW50TWFwVmVydGljYWwuZ2V0KG5vZGVJZCkuZm9yRWFjaChmdW5jdGlvbiAoY29uc3RyYWludCkge1xuICAgICAgICAgICAgaWYgKGNvbnN0cmFpbnQuYm90dG9tKSB7XG4gICAgICAgICAgICAgIHZhciBkaWZmID0gc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBWZXJ0aWNhbC5nZXQoY29uc3RyYWludC5ib3R0b20pIC0gc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBWZXJ0aWNhbC5nZXQobm9kZUlkKSAtIGRpc3BsYWNlbWVudDtcbiAgICAgICAgICAgICAgaWYgKGRpZmYgPCBjb25zdHJhaW50LmdhcCkge1xuICAgICAgICAgICAgICAgIGRpc3BsYWNlbWVudCAtPSBjb25zdHJhaW50LmdhcCAtIGRpZmY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBkaWZmID0gc2VsZi5ub2RlVG9UZW1wUG9zaXRpb25NYXBWZXJ0aWNhbC5nZXQobm9kZUlkKSAtIHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwVmVydGljYWwuZ2V0KGNvbnN0cmFpbnQudG9wKSArIGRpc3BsYWNlbWVudDtcbiAgICAgICAgICAgICAgaWYgKGRpZmYgPCBjb25zdHJhaW50LmdhcCkge1xuICAgICAgICAgICAgICAgIGRpc3BsYWNlbWVudCArPSBjb25zdHJhaW50LmdhcCAtIGRpZmY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZWxmLm5vZGVUb1RlbXBQb3NpdGlvbk1hcFZlcnRpY2FsLnNldChub2RlSWQsIHNlbGYubm9kZVRvVGVtcFBvc2l0aW9uTWFwVmVydGljYWwuZ2V0KG5vZGVJZCkgKyBkaXNwbGFjZW1lbnQpO1xuICAgICAgICAgIGlmIChzZWxmLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgc2VsZi5kdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KG5vZGVJZCkuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICAgIHNlbGYuaWRUb05vZGVNYXAuZ2V0KG5vZGVJZCkuZGlzcGxhY2VtZW50WSA9IGRpc3BsYWNlbWVudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWQpLmRpc3BsYWNlbWVudFkgPSBkaXNwbGFjZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbXBvbmVudHNPbkhvcml6b250YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50c09uSG9yaXpvbnRhbFtpXTtcbiAgICAgICAgaWYgKHRoaXMuZml4ZWRDb21wb25lbnRzT25Ib3Jpem9udGFsW2ldKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb21wb25lbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuaGFzKGNvbXBvbmVudFtqXSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5kdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChjb21wb25lbnRbal0pLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICAgIHNlbGYuaWRUb05vZGVNYXAuZ2V0KG5vZGVJZCkuZGlzcGxhY2VtZW50WCA9IDA7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5pZFRvTm9kZU1hcC5nZXQoY29tcG9uZW50W2pdKS5kaXNwbGFjZW1lbnRYID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbXBvbmVudC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudC5oYXMoY29tcG9uZW50W2pdKSkge1xuICAgICAgICAgICAgICB2YXIgYWN0dWFsTm9kZXMgPSB0aGlzLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KGNvbXBvbmVudFtqXSk7XG4gICAgICAgICAgICAgIHN1bSArPSBhY3R1YWxOb2Rlcy5sZW5ndGggKiB0aGlzLmlkVG9Ob2RlTWFwLmdldChhY3R1YWxOb2Rlc1swXSkuZGlzcGxhY2VtZW50WDtcbiAgICAgICAgICAgICAgY291bnQgKz0gYWN0dWFsTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3VtICs9IHRoaXMuaWRUb05vZGVNYXAuZ2V0KGNvbXBvbmVudFtqXSkuZGlzcGxhY2VtZW50WDtcbiAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGF2ZXJhZ2VEaXNwbGFjZW1lbnQgPSBzdW0gLyBjb3VudDtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbXBvbmVudC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudC5oYXMoY29tcG9uZW50W2pdKSkge1xuICAgICAgICAgICAgICB0aGlzLmR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KGNvbXBvbmVudFtqXSkuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pZFRvTm9kZU1hcC5nZXQobm9kZUlkKS5kaXNwbGFjZW1lbnRYID0gYXZlcmFnZURpc3BsYWNlbWVudDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmlkVG9Ob2RlTWFwLmdldChjb21wb25lbnRbal0pLmRpc3BsYWNlbWVudFggPSBhdmVyYWdlRGlzcGxhY2VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29tcG9uZW50c09uVmVydGljYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50c09uVmVydGljYWxbaV07XG4gICAgICAgIGlmICh0aGlzLmZpeGVkQ29tcG9uZW50c09uVmVydGljYWxbaV0pIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbXBvbmVudC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50Lmhhcyhjb21wb25lbnRbal0pKSB7XG4gICAgICAgICAgICAgIHRoaXMuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChjb21wb25lbnRbal0pLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICAgIHNlbGYuaWRUb05vZGVNYXAuZ2V0KG5vZGVJZCkuZGlzcGxhY2VtZW50WSA9IDA7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5pZFRvTm9kZU1hcC5nZXQoY29tcG9uZW50W2pdKS5kaXNwbGFjZW1lbnRZID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvbXBvbmVudC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50Lmhhcyhjb21wb25lbnRbal0pKSB7XG4gICAgICAgICAgICAgIHZhciBhY3R1YWxOb2RlcyA9IHRoaXMuZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50LmdldChjb21wb25lbnRbal0pO1xuICAgICAgICAgICAgICBzdW0gKz0gYWN0dWFsTm9kZXMubGVuZ3RoICogdGhpcy5pZFRvTm9kZU1hcC5nZXQoYWN0dWFsTm9kZXNbMF0pLmRpc3BsYWNlbWVudFk7XG4gICAgICAgICAgICAgIGNvdW50ICs9IGFjdHVhbE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN1bSArPSB0aGlzLmlkVG9Ob2RlTWFwLmdldChjb21wb25lbnRbal0pLmRpc3BsYWNlbWVudFk7XG4gICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhdmVyYWdlRGlzcGxhY2VtZW50ID0gc3VtIC8gY291bnQ7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb21wb25lbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5oYXMoY29tcG9uZW50W2pdKSkge1xuICAgICAgICAgICAgICB0aGlzLmR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5nZXQoY29tcG9uZW50W2pdKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmlkVG9Ob2RlTWFwLmdldChub2RlSWQpLmRpc3BsYWNlbWVudFkgPSBhdmVyYWdlRGlzcGxhY2VtZW50O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuaWRUb05vZGVNYXAuZ2V0KGNvbXBvbmVudFtqXSkuZGlzcGxhY2VtZW50WSA9IGF2ZXJhZ2VEaXNwbGFjZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jYWxjdWxhdGVOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvblRvID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZUxpc3QgPSBbXTtcbiAgdmFyIGdyYXBoO1xuXG4gIHZhciBncmFwaHMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRHcmFwaHMoKTtcbiAgdmFyIHNpemUgPSBncmFwaHMubGVuZ3RoO1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIGdyYXBoID0gZ3JhcGhzW2ldO1xuXG4gICAgZ3JhcGgudXBkYXRlQ29ubmVjdGVkKCk7XG5cbiAgICBpZiAoIWdyYXBoLmlzQ29ubmVjdGVkKSB7XG4gICAgICBub2RlTGlzdCA9IG5vZGVMaXN0LmNvbmNhdChncmFwaC5nZXROb2RlcygpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZUxpc3Q7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jcmVhdGVCZW5kcG9pbnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWRnZXMgPSBbXTtcbiAgZWRnZXMgPSBlZGdlcy5jb25jYXQodGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsRWRnZXMoKSk7XG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcblxuICAgIGlmICghdmlzaXRlZC5oYXMoZWRnZSkpIHtcbiAgICAgIHZhciBzb3VyY2UgPSBlZGdlLmdldFNvdXJjZSgpO1xuICAgICAgdmFyIHRhcmdldCA9IGVkZ2UuZ2V0VGFyZ2V0KCk7XG5cbiAgICAgIGlmIChzb3VyY2UgPT0gdGFyZ2V0KSB7XG4gICAgICAgIGVkZ2UuZ2V0QmVuZHBvaW50cygpLnB1c2gobmV3IFBvaW50RCgpKTtcbiAgICAgICAgZWRnZS5nZXRCZW5kcG9pbnRzKCkucHVzaChuZXcgUG9pbnREKCkpO1xuICAgICAgICB0aGlzLmNyZWF0ZUR1bW15Tm9kZXNGb3JCZW5kcG9pbnRzKGVkZ2UpO1xuICAgICAgICB2aXNpdGVkLmFkZChlZGdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlZGdlTGlzdCA9IFtdO1xuXG4gICAgICAgIGVkZ2VMaXN0ID0gZWRnZUxpc3QuY29uY2F0KHNvdXJjZS5nZXRFZGdlTGlzdFRvTm9kZSh0YXJnZXQpKTtcbiAgICAgICAgZWRnZUxpc3QgPSBlZGdlTGlzdC5jb25jYXQodGFyZ2V0LmdldEVkZ2VMaXN0VG9Ob2RlKHNvdXJjZSkpO1xuXG4gICAgICAgIGlmICghdmlzaXRlZC5oYXMoZWRnZUxpc3RbMF0pKSB7XG4gICAgICAgICAgaWYgKGVkZ2VMaXN0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBrO1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGVkZ2VMaXN0Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgIHZhciBtdWx0aUVkZ2UgPSBlZGdlTGlzdFtrXTtcbiAgICAgICAgICAgICAgbXVsdGlFZGdlLmdldEJlbmRwb2ludHMoKS5wdXNoKG5ldyBQb2ludEQoKSk7XG4gICAgICAgICAgICAgIHRoaXMuY3JlYXRlRHVtbXlOb2Rlc0ZvckJlbmRwb2ludHMobXVsdGlFZGdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWRnZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgICAgdmlzaXRlZC5hZGQoZWRnZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmlzaXRlZC5zaXplID09IGVkZ2VzLmxlbmd0aCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5wb3NpdGlvbk5vZGVzUmFkaWFsbHkgPSBmdW5jdGlvbiAoZm9yZXN0KSB7XG4gIC8vIFdlIHRpbGUgdGhlIHRyZWVzIHRvIGEgZ3JpZCByb3cgYnkgcm93OyBmaXJzdCB0cmVlIHN0YXJ0cyBhdCAoMCwwKVxuICB2YXIgY3VycmVudFN0YXJ0aW5nUG9pbnQgPSBuZXcgUG9pbnQoMCwgMCk7XG4gIHZhciBudW1iZXJPZkNvbHVtbnMgPSBNYXRoLmNlaWwoTWF0aC5zcXJ0KGZvcmVzdC5sZW5ndGgpKTtcbiAgdmFyIGhlaWdodCA9IDA7XG4gIHZhciBjdXJyZW50WSA9IDA7XG4gIHZhciBjdXJyZW50WCA9IDA7XG4gIHZhciBwb2ludCA9IG5ldyBQb2ludEQoMCwgMCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3Jlc3QubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaSAlIG51bWJlck9mQ29sdW1ucyA9PSAwKSB7XG4gICAgICAvLyBTdGFydCBvZiBhIG5ldyByb3csIG1ha2UgdGhlIHggY29vcmRpbmF0ZSAwLCBpbmNyZW1lbnQgdGhlXG4gICAgICAvLyB5IGNvb3JkaW5hdGUgd2l0aCB0aGUgbWF4IGhlaWdodCBvZiB0aGUgcHJldmlvdXMgcm93XG4gICAgICBjdXJyZW50WCA9IDA7XG4gICAgICBjdXJyZW50WSA9IGhlaWdodDtcblxuICAgICAgaWYgKGkgIT0gMCkge1xuICAgICAgICBjdXJyZW50WSArPSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09NUE9ORU5UX1NFUEVSQVRJT047XG4gICAgICB9XG5cbiAgICAgIGhlaWdodCA9IDA7XG4gICAgfVxuXG4gICAgdmFyIHRyZWUgPSBmb3Jlc3RbaV07XG5cbiAgICAvLyBGaW5kIHRoZSBjZW50ZXIgb2YgdGhlIHRyZWVcbiAgICB2YXIgY2VudGVyTm9kZSA9IExheW91dC5maW5kQ2VudGVyT2ZUcmVlKHRyZWUpO1xuXG4gICAgLy8gU2V0IHRoZSBzdGFyaW5nIHBvaW50IG9mIHRoZSBuZXh0IHRyZWVcbiAgICBjdXJyZW50U3RhcnRpbmdQb2ludC54ID0gY3VycmVudFg7XG4gICAgY3VycmVudFN0YXJ0aW5nUG9pbnQueSA9IGN1cnJlbnRZO1xuXG4gICAgLy8gRG8gYSByYWRpYWwgbGF5b3V0IHN0YXJ0aW5nIHdpdGggdGhlIGNlbnRlclxuICAgIHBvaW50ID0gQ29TRUxheW91dC5yYWRpYWxMYXlvdXQodHJlZSwgY2VudGVyTm9kZSwgY3VycmVudFN0YXJ0aW5nUG9pbnQpO1xuXG4gICAgaWYgKHBvaW50LnkgPiBoZWlnaHQpIHtcbiAgICAgIGhlaWdodCA9IE1hdGguZmxvb3IocG9pbnQueSk7XG4gICAgfVxuXG4gICAgY3VycmVudFggPSBNYXRoLmZsb29yKHBvaW50LnggKyBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfQ09NUE9ORU5UX1NFUEVSQVRJT04pO1xuICB9XG5cbiAgdGhpcy50cmFuc2Zvcm0obmV3IFBvaW50RChMYXlvdXRDb25zdGFudHMuV09STERfQ0VOVEVSX1ggLSBwb2ludC54IC8gMiwgTGF5b3V0Q29uc3RhbnRzLldPUkxEX0NFTlRFUl9ZIC0gcG9pbnQueSAvIDIpKTtcbn07XG5cbkNvU0VMYXlvdXQucmFkaWFsTGF5b3V0ID0gZnVuY3Rpb24gKHRyZWUsIGNlbnRlck5vZGUsIHN0YXJ0aW5nUG9pbnQpIHtcbiAgdmFyIHJhZGlhbFNlcCA9IE1hdGgubWF4KHRoaXMubWF4RGlhZ29uYWxJblRyZWUodHJlZSksIENvU0VDb25zdGFudHMuREVGQVVMVF9SQURJQUxfU0VQQVJBVElPTik7XG4gIENvU0VMYXlvdXQuYnJhbmNoUmFkaWFsTGF5b3V0KGNlbnRlck5vZGUsIG51bGwsIDAsIDM1OSwgMCwgcmFkaWFsU2VwKTtcbiAgdmFyIGJvdW5kcyA9IExHcmFwaC5jYWxjdWxhdGVCb3VuZHModHJlZSk7XG5cbiAgdmFyIHRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0oKTtcbiAgdHJhbnNmb3JtLnNldERldmljZU9yZ1goYm91bmRzLmdldE1pblgoKSk7XG4gIHRyYW5zZm9ybS5zZXREZXZpY2VPcmdZKGJvdW5kcy5nZXRNaW5ZKCkpO1xuICB0cmFuc2Zvcm0uc2V0V29ybGRPcmdYKHN0YXJ0aW5nUG9pbnQueCk7XG4gIHRyYW5zZm9ybS5zZXRXb3JsZE9yZ1koc3RhcnRpbmdQb2ludC55KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IHRyZWVbaV07XG4gICAgbm9kZS50cmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgfVxuXG4gIHZhciBib3R0b21SaWdodCA9IG5ldyBQb2ludEQoYm91bmRzLmdldE1heFgoKSwgYm91bmRzLmdldE1heFkoKSk7XG5cbiAgcmV0dXJuIHRyYW5zZm9ybS5pbnZlcnNlVHJhbnNmb3JtUG9pbnQoYm90dG9tUmlnaHQpO1xufTtcblxuQ29TRUxheW91dC5icmFuY2hSYWRpYWxMYXlvdXQgPSBmdW5jdGlvbiAobm9kZSwgcGFyZW50T2ZOb2RlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgZGlzdGFuY2UsIHJhZGlhbFNlcGFyYXRpb24pIHtcbiAgLy8gRmlyc3QsIHBvc2l0aW9uIHRoaXMgbm9kZSBieSBmaW5kaW5nIGl0cyBhbmdsZS5cbiAgdmFyIGhhbGZJbnRlcnZhbCA9IChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUgKyAxKSAvIDI7XG5cbiAgaWYgKGhhbGZJbnRlcnZhbCA8IDApIHtcbiAgICBoYWxmSW50ZXJ2YWwgKz0gMTgwO1xuICB9XG5cbiAgdmFyIG5vZGVBbmdsZSA9IChoYWxmSW50ZXJ2YWwgKyBzdGFydEFuZ2xlKSAlIDM2MDtcbiAgdmFyIHRldGEgPSBub2RlQW5nbGUgKiBJR2VvbWV0cnkuVFdPX1BJIC8gMzYwO1xuXG4gIC8vIE1ha2UgcG9sYXIgdG8gamF2YSBjb3JkaW5hdGUgY29udmVyc2lvbi5cbiAgdmFyIGNvc190ZXRhID0gTWF0aC5jb3ModGV0YSk7XG4gIHZhciB4XyA9IGRpc3RhbmNlICogTWF0aC5jb3ModGV0YSk7XG4gIHZhciB5XyA9IGRpc3RhbmNlICogTWF0aC5zaW4odGV0YSk7XG5cbiAgbm9kZS5zZXRDZW50ZXIoeF8sIHlfKTtcblxuICAvLyBUcmF2ZXJzZSBhbGwgbmVpZ2hib3JzIG9mIHRoaXMgbm9kZSBhbmQgcmVjdXJzaXZlbHkgY2FsbCB0aGlzXG4gIC8vIGZ1bmN0aW9uLlxuICB2YXIgbmVpZ2hib3JFZGdlcyA9IFtdO1xuICBuZWlnaGJvckVkZ2VzID0gbmVpZ2hib3JFZGdlcy5jb25jYXQobm9kZS5nZXRFZGdlcygpKTtcbiAgdmFyIGNoaWxkQ291bnQgPSBuZWlnaGJvckVkZ2VzLmxlbmd0aDtcblxuICBpZiAocGFyZW50T2ZOb2RlICE9IG51bGwpIHtcbiAgICBjaGlsZENvdW50LS07XG4gIH1cblxuICB2YXIgYnJhbmNoQ291bnQgPSAwO1xuXG4gIHZhciBpbmNFZGdlc0NvdW50ID0gbmVpZ2hib3JFZGdlcy5sZW5ndGg7XG4gIHZhciBzdGFydEluZGV4O1xuXG4gIHZhciBlZGdlcyA9IG5vZGUuZ2V0RWRnZXNCZXR3ZWVuKHBhcmVudE9mTm9kZSk7XG5cbiAgLy8gSWYgdGhlcmUgYXJlIG11bHRpcGxlIGVkZ2VzLCBwcnVuZSB0aGVtIHVudGlsIHRoZXJlIHJlbWFpbnMgb25seSBvbmVcbiAgLy8gZWRnZS5cbiAgd2hpbGUgKGVkZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAvL25laWdoYm9yRWRnZXMucmVtb3ZlKGVkZ2VzLnJlbW92ZSgwKSk7XG4gICAgdmFyIHRlbXAgPSBlZGdlc1swXTtcbiAgICBlZGdlcy5zcGxpY2UoMCwgMSk7XG4gICAgdmFyIGluZGV4ID0gbmVpZ2hib3JFZGdlcy5pbmRleE9mKHRlbXApO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBuZWlnaGJvckVkZ2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIGluY0VkZ2VzQ291bnQtLTtcbiAgICBjaGlsZENvdW50LS07XG4gIH1cblxuICBpZiAocGFyZW50T2ZOb2RlICE9IG51bGwpIHtcbiAgICAvL2Fzc2VydCBlZGdlcy5sZW5ndGggPT0gMTtcbiAgICBzdGFydEluZGV4ID0gKG5laWdoYm9yRWRnZXMuaW5kZXhPZihlZGdlc1swXSkgKyAxKSAlIGluY0VkZ2VzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRJbmRleCA9IDA7XG4gIH1cblxuICB2YXIgc3RlcEFuZ2xlID0gTWF0aC5hYnMoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSAvIGNoaWxkQ291bnQ7XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGJyYW5jaENvdW50ICE9IGNoaWxkQ291bnQ7IGkgPSArK2kgJSBpbmNFZGdlc0NvdW50KSB7XG4gICAgdmFyIGN1cnJlbnROZWlnaGJvciA9IG5laWdoYm9yRWRnZXNbaV0uZ2V0T3RoZXJFbmQobm9kZSk7XG5cbiAgICAvLyBEb24ndCBiYWNrIHRyYXZlcnNlIHRvIHJvb3Qgbm9kZSBpbiBjdXJyZW50IHRyZWUuXG4gICAgaWYgKGN1cnJlbnROZWlnaGJvciA9PSBwYXJlbnRPZk5vZGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBjaGlsZFN0YXJ0QW5nbGUgPSAoc3RhcnRBbmdsZSArIGJyYW5jaENvdW50ICogc3RlcEFuZ2xlKSAlIDM2MDtcbiAgICB2YXIgY2hpbGRFbmRBbmdsZSA9IChjaGlsZFN0YXJ0QW5nbGUgKyBzdGVwQW5nbGUpICUgMzYwO1xuXG4gICAgQ29TRUxheW91dC5icmFuY2hSYWRpYWxMYXlvdXQoY3VycmVudE5laWdoYm9yLCBub2RlLCBjaGlsZFN0YXJ0QW5nbGUsIGNoaWxkRW5kQW5nbGUsIGRpc3RhbmNlICsgcmFkaWFsU2VwYXJhdGlvbiwgcmFkaWFsU2VwYXJhdGlvbik7XG5cbiAgICBicmFuY2hDb3VudCsrO1xuICB9XG59O1xuXG5Db1NFTGF5b3V0Lm1heERpYWdvbmFsSW5UcmVlID0gZnVuY3Rpb24gKHRyZWUpIHtcbiAgdmFyIG1heERpYWdvbmFsID0gSW50ZWdlci5NSU5fVkFMVUU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSB0cmVlW2ldO1xuICAgIHZhciBkaWFnb25hbCA9IG5vZGUuZ2V0RGlhZ29uYWwoKTtcblxuICAgIGlmIChkaWFnb25hbCA+IG1heERpYWdvbmFsKSB7XG4gICAgICBtYXhEaWFnb25hbCA9IGRpYWdvbmFsO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXhEaWFnb25hbDtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmNhbGNSZXB1bHNpb25SYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gZm9ybXVsYSBpcyAyIHggKGxldmVsICsgMSkgeCBpZGVhbEVkZ2VMZW5ndGhcbiAgcmV0dXJuIDIgKiAodGhpcy5sZXZlbCArIDEpICogdGhpcy5pZGVhbEVkZ2VMZW5ndGg7XG59O1xuXG4vLyBUaWxpbmcgbWV0aG9kc1xuXG4vLyBHcm91cCB6ZXJvIGRlZ3JlZSBtZW1iZXJzIHdob3NlIHBhcmVudHMgYXJlIG5vdCB0byBiZSB0aWxlZCwgY3JlYXRlIGR1bW15IHBhcmVudHMgd2hlcmUgbmVlZGVkIGFuZCBmaWxsIG1lbWJlckdyb3VwcyBieSB0aGVpciBkdW1tcCBwYXJlbnQgaWQnc1xuQ29TRUxheW91dC5wcm90b3R5cGUuZ3JvdXBaZXJvRGVncmVlTWVtYmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICAvLyBhcnJheSBvZiBbcGFyZW50X2lkIHggb25lRGVncmVlTm9kZV9pZF1cbiAgdmFyIHRlbXBNZW1iZXJHcm91cHMgPSB7fTsgLy8gQSB0ZW1wb3JhcnkgbWFwIG9mIHBhcmVudCBub2RlIGFuZCBpdHMgemVybyBkZWdyZWUgbWVtYmVyc1xuICB0aGlzLm1lbWJlckdyb3VwcyA9IHt9OyAvLyBBIG1hcCBvZiBkdW1teSBwYXJlbnQgbm9kZSBhbmQgaXRzIHplcm8gZGVncmVlIG1lbWJlcnMgd2hvc2UgcGFyZW50cyBhcmUgbm90IHRvIGJlIHRpbGVkXG4gIHRoaXMuaWRUb0R1bW15Tm9kZSA9IHt9OyAvLyBBIG1hcCBvZiBpZCB0byBkdW1teSBub2RlIFxuXG4gIHZhciB6ZXJvRGVncmVlID0gW107IC8vIExpc3Qgb2YgemVybyBkZWdyZWUgbm9kZXMgd2hvc2UgcGFyZW50cyBhcmUgbm90IHRvIGJlIHRpbGVkXG4gIHZhciBhbGxOb2RlcyA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbE5vZGVzKCk7XG5cbiAgLy8gRmlsbCB6ZXJvIGRlZ3JlZSBsaXN0XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IGFsbE5vZGVzW2ldO1xuICAgIHZhciBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICAgIC8vIElmIGEgbm9kZSBoYXMgemVybyBkZWdyZWUgYW5kIGl0cyBwYXJlbnQgaXMgbm90IHRvIGJlIHRpbGVkIGlmIGV4aXN0cyBhZGQgdGhhdCBub2RlIHRvIHplcm9EZWdyZXMgbGlzdFxuICAgIGlmICh0aGlzLmdldE5vZGVEZWdyZWVXaXRoQ2hpbGRyZW4obm9kZSkgPT09IDAgJiYgKHBhcmVudC5pZCA9PSB1bmRlZmluZWQgfHwgIXRoaXMuZ2V0VG9CZVRpbGVkKHBhcmVudCkpKSB7XG4gICAgICB6ZXJvRGVncmVlLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ3JlYXRlIGEgbWFwIG9mIHBhcmVudCBub2RlIGFuZCBpdHMgemVybyBkZWdyZWUgbWVtYmVyc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHplcm9EZWdyZWUubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbm9kZSA9IHplcm9EZWdyZWVbaV07IC8vIFplcm8gZGVncmVlIG5vZGUgaXRzZWxmXG4gICAgdmFyIHBfaWQgPSBub2RlLmdldFBhcmVudCgpLmlkOyAvLyBQYXJlbnQgaWRcblxuICAgIGlmICh0eXBlb2YgdGVtcE1lbWJlckdyb3Vwc1twX2lkXSA9PT0gXCJ1bmRlZmluZWRcIikgdGVtcE1lbWJlckdyb3Vwc1twX2lkXSA9IFtdO1xuXG4gICAgdGVtcE1lbWJlckdyb3Vwc1twX2lkXSA9IHRlbXBNZW1iZXJHcm91cHNbcF9pZF0uY29uY2F0KG5vZGUpOyAvLyBQdXNoIG5vZGUgdG8gdGhlIGxpc3QgYmVsb25ncyB0byBpdHMgcGFyZW50IGluIHRlbXBNZW1iZXJHcm91cHNcbiAgfVxuXG4gIC8vIElmIHRoZXJlIGFyZSBhdCBsZWFzdCB0d28gbm9kZXMgYXQgYSBsZXZlbCwgY3JlYXRlIGEgZHVtbXkgY29tcG91bmQgZm9yIHRoZW1cbiAgT2JqZWN0LmtleXModGVtcE1lbWJlckdyb3VwcykuZm9yRWFjaChmdW5jdGlvbiAocF9pZCkge1xuICAgIGlmICh0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdLmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBkdW1teUNvbXBvdW5kSWQgPSBcIkR1bW15Q29tcG91bmRfXCIgKyBwX2lkOyAvLyBUaGUgaWQgb2YgZHVtbXkgY29tcG91bmQgd2hpY2ggd2lsbCBiZSBjcmVhdGVkIHNvb25cbiAgICAgIHNlbGYubWVtYmVyR3JvdXBzW2R1bW15Q29tcG91bmRJZF0gPSB0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdOyAvLyBBZGQgZHVtbXkgY29tcG91bmQgdG8gbWVtYmVyR3JvdXBzXG5cbiAgICAgIHZhciBwYXJlbnQgPSB0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdWzBdLmdldFBhcmVudCgpOyAvLyBUaGUgcGFyZW50IG9mIHplcm8gZGVncmVlIG5vZGVzIHdpbGwgYmUgdGhlIHBhcmVudCBvZiBuZXcgZHVtbXkgY29tcG91bmRcblxuICAgICAgLy8gQ3JlYXRlIGEgZHVtbXkgY29tcG91bmQgd2l0aCBjYWxjdWxhdGVkIGlkXG4gICAgICB2YXIgZHVtbXlDb21wb3VuZCA9IG5ldyBDb1NFTm9kZShzZWxmLmdyYXBoTWFuYWdlcik7XG4gICAgICBkdW1teUNvbXBvdW5kLmlkID0gZHVtbXlDb21wb3VuZElkO1xuICAgICAgZHVtbXlDb21wb3VuZC5wYWRkaW5nTGVmdCA9IHBhcmVudC5wYWRkaW5nTGVmdCB8fCAwO1xuICAgICAgZHVtbXlDb21wb3VuZC5wYWRkaW5nUmlnaHQgPSBwYXJlbnQucGFkZGluZ1JpZ2h0IHx8IDA7XG4gICAgICBkdW1teUNvbXBvdW5kLnBhZGRpbmdCb3R0b20gPSBwYXJlbnQucGFkZGluZ0JvdHRvbSB8fCAwO1xuICAgICAgZHVtbXlDb21wb3VuZC5wYWRkaW5nVG9wID0gcGFyZW50LnBhZGRpbmdUb3AgfHwgMDtcblxuICAgICAgc2VsZi5pZFRvRHVtbXlOb2RlW2R1bW15Q29tcG91bmRJZF0gPSBkdW1teUNvbXBvdW5kO1xuXG4gICAgICB2YXIgZHVtbXlQYXJlbnRHcmFwaCA9IHNlbGYuZ2V0R3JhcGhNYW5hZ2VyKCkuYWRkKHNlbGYubmV3R3JhcGgoKSwgZHVtbXlDb21wb3VuZCk7XG4gICAgICB2YXIgcGFyZW50R3JhcGggPSBwYXJlbnQuZ2V0Q2hpbGQoKTtcblxuICAgICAgLy8gQWRkIGR1bW15IGNvbXBvdW5kIHRvIHBhcmVudCB0aGUgZ3JhcGhcbiAgICAgIHBhcmVudEdyYXBoLmFkZChkdW1teUNvbXBvdW5kKTtcblxuICAgICAgLy8gRm9yIGVhY2ggemVybyBkZWdyZWUgbm9kZSBpbiB0aGlzIGxldmVsIHJlbW92ZSBpdCBmcm9tIGl0cyBwYXJlbnQgZ3JhcGggYW5kIGFkZCBpdCB0byB0aGUgZ3JhcGggb2YgZHVtbXkgcGFyZW50XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRlbXBNZW1iZXJHcm91cHNbcF9pZF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0ZW1wTWVtYmVyR3JvdXBzW3BfaWRdW2ldO1xuXG4gICAgICAgIHBhcmVudEdyYXBoLnJlbW92ZShub2RlKTtcbiAgICAgICAgZHVtbXlQYXJlbnRHcmFwaC5hZGQobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmNsZWFyQ29tcG91bmRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2hpbGRHcmFwaE1hcCA9IHt9O1xuICB2YXIgaWRUb05vZGUgPSB7fTtcblxuICAvLyBHZXQgY29tcG91bmQgb3JkZXJpbmcgYnkgZmluZGluZyB0aGUgaW5uZXIgb25lIGZpcnN0XG4gIHRoaXMucGVyZm9ybURGU09uQ29tcG91bmRzKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbXBvdW5kT3JkZXIubGVuZ3RoOyBpKyspIHtcblxuICAgIGlkVG9Ob2RlW3RoaXMuY29tcG91bmRPcmRlcltpXS5pZF0gPSB0aGlzLmNvbXBvdW5kT3JkZXJbaV07XG4gICAgY2hpbGRHcmFwaE1hcFt0aGlzLmNvbXBvdW5kT3JkZXJbaV0uaWRdID0gW10uY29uY2F0KHRoaXMuY29tcG91bmRPcmRlcltpXS5nZXRDaGlsZCgpLmdldE5vZGVzKCkpO1xuXG4gICAgLy8gUmVtb3ZlIGNoaWxkcmVuIG9mIGNvbXBvdW5kc1xuICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlbW92ZSh0aGlzLmNvbXBvdW5kT3JkZXJbaV0uZ2V0Q2hpbGQoKSk7XG4gICAgdGhpcy5jb21wb3VuZE9yZGVyW2ldLmNoaWxkID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXMoKTtcblxuICAvLyBUaWxlIHRoZSByZW1vdmVkIGNoaWxkcmVuXG4gIHRoaXMudGlsZUNvbXBvdW5kTWVtYmVycyhjaGlsZEdyYXBoTWFwLCBpZFRvTm9kZSk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5jbGVhclplcm9EZWdyZWVNZW1iZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0aWxlZFplcm9EZWdyZWVQYWNrID0gdGhpcy50aWxlZFplcm9EZWdyZWVQYWNrID0gW107XG5cbiAgT2JqZWN0LmtleXModGhpcy5tZW1iZXJHcm91cHMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGNvbXBvdW5kTm9kZSA9IHNlbGYuaWRUb0R1bW15Tm9kZVtpZF07IC8vIEdldCB0aGUgZHVtbXkgY29tcG91bmRcblxuICAgIHRpbGVkWmVyb0RlZ3JlZVBhY2tbaWRdID0gc2VsZi50aWxlTm9kZXMoc2VsZi5tZW1iZXJHcm91cHNbaWRdLCBjb21wb3VuZE5vZGUucGFkZGluZ0xlZnQgKyBjb21wb3VuZE5vZGUucGFkZGluZ1JpZ2h0KTtcblxuICAgIC8vIFNldCB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgZHVtbXkgY29tcG91bmQgYXMgY2FsY3VsYXRlZFxuICAgIGNvbXBvdW5kTm9kZS5yZWN0LndpZHRoID0gdGlsZWRaZXJvRGVncmVlUGFja1tpZF0ud2lkdGg7XG4gICAgY29tcG91bmROb2RlLnJlY3QuaGVpZ2h0ID0gdGlsZWRaZXJvRGVncmVlUGFja1tpZF0uaGVpZ2h0O1xuICAgIGNvbXBvdW5kTm9kZS5zZXRDZW50ZXIodGlsZWRaZXJvRGVncmVlUGFja1tpZF0uY2VudGVyWCwgdGlsZWRaZXJvRGVncmVlUGFja1tpZF0uY2VudGVyWSk7XG5cbiAgICAvLyBjb21wb3VuZCBsZWZ0IGFuZCB0b3AgbWFyZ2luZ3MgZm9yIGxhYmVsc1xuICAgIC8vIHdoZW4gbm9kZSBsYWJlbHMgYXJlIGluY2x1ZGVkLCB0aGVzZSB2YWx1ZXMgbWF5IGJlIHNldCB0byBkaWZmZXJlbnQgdmFsdWVzIGJlbG93IGFuZCBhcmUgdXNlZCBpbiB0aWxpbmdQb3N0TGF5b3V0LFxuICAgIC8vIG90aGVyd2lzZSB0aGV5IHN0YXkgYXMgemVyb1xuICAgIGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpbkxlZnQgPSAwO1xuICAgIGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpblRvcCA9IDA7XG5cbiAgICAvLyBVcGRhdGUgY29tcG91bmQgYm91bmRzIGNvbnNpZGVyaW5nIGl0cyBsYWJlbCBwcm9wZXJ0aWVzIGFuZCBzZXQgbGFiZWwgbWFyZ2lucyBmb3IgbGVmdCBhbmQgdG9wXG4gICAgaWYgKENvU0VDb25zdGFudHMuTk9ERV9ESU1FTlNJT05TX0lOQ0xVREVfTEFCRUxTKSB7XG5cbiAgICAgIHZhciB3aWR0aCA9IGNvbXBvdW5kTm9kZS5yZWN0LndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IGNvbXBvdW5kTm9kZS5yZWN0LmhlaWdodDtcblxuICAgICAgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFdpZHRoKSB7XG4gICAgICAgIGlmIChjb21wb3VuZE5vZGUubGFiZWxQb3NIb3Jpem9udGFsID09IFwibGVmdFwiKSB7XG4gICAgICAgICAgY29tcG91bmROb2RlLnJlY3QueCAtPSBjb21wb3VuZE5vZGUubGFiZWxXaWR0aDtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0V2lkdGgod2lkdGggKyBjb21wb3VuZE5vZGUubGFiZWxXaWR0aCk7XG4gICAgICAgICAgY29tcG91bmROb2RlLmxhYmVsTWFyZ2luTGVmdCA9IGNvbXBvdW5kTm9kZS5sYWJlbFdpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFBvc0hvcml6b250YWwgPT0gXCJjZW50ZXJcIiAmJiBjb21wb3VuZE5vZGUubGFiZWxXaWR0aCA+IHdpZHRoKSB7XG4gICAgICAgICAgY29tcG91bmROb2RlLnJlY3QueCAtPSAoY29tcG91bmROb2RlLmxhYmVsV2lkdGggLSB3aWR0aCkgLyAyO1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5zZXRXaWR0aChjb21wb3VuZE5vZGUubGFiZWxXaWR0aCk7XG4gICAgICAgICAgY29tcG91bmROb2RlLmxhYmVsTWFyZ2luTGVmdCA9IChjb21wb3VuZE5vZGUubGFiZWxXaWR0aCAtIHdpZHRoKSAvIDI7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcG91bmROb2RlLmxhYmVsUG9zSG9yaXpvbnRhbCA9PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0V2lkdGgod2lkdGggKyBjb21wb3VuZE5vZGUubGFiZWxXaWR0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodCkge1xuICAgICAgICBpZiAoY29tcG91bmROb2RlLmxhYmVsUG9zVmVydGljYWwgPT0gXCJ0b3BcIikge1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5yZWN0LnkgLT0gY29tcG91bmROb2RlLmxhYmVsSGVpZ2h0O1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5zZXRIZWlnaHQoaGVpZ2h0ICsgY29tcG91bmROb2RlLmxhYmVsSGVpZ2h0KTtcbiAgICAgICAgICBjb21wb3VuZE5vZGUubGFiZWxNYXJnaW5Ub3AgPSBjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcG91bmROb2RlLmxhYmVsUG9zVmVydGljYWwgPT0gXCJjZW50ZXJcIiAmJiBjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQgPiBoZWlnaHQpIHtcbiAgICAgICAgICBjb21wb3VuZE5vZGUucmVjdC55IC09IChjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQgLSBoZWlnaHQpIC8gMjtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0SGVpZ2h0KGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodCk7XG4gICAgICAgICAgY29tcG91bmROb2RlLmxhYmVsTWFyZ2luVG9wID0gKGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodCAtIGhlaWdodCkgLyAyO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFBvc1ZlcnRpY2FsID09IFwiYm90dG9tXCIpIHtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0SGVpZ2h0KGhlaWdodCArIGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUucmVwb3B1bGF0ZUNvbXBvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IHRoaXMuY29tcG91bmRPcmRlci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsQ29tcG91bmROb2RlID0gdGhpcy5jb21wb3VuZE9yZGVyW2ldO1xuICAgIHZhciBpZCA9IGxDb21wb3VuZE5vZGUuaWQ7XG4gICAgdmFyIGhvcml6b250YWxNYXJnaW4gPSBsQ29tcG91bmROb2RlLnBhZGRpbmdMZWZ0O1xuICAgIHZhciB2ZXJ0aWNhbE1hcmdpbiA9IGxDb21wb3VuZE5vZGUucGFkZGluZ1RvcDtcbiAgICB2YXIgbGFiZWxNYXJnaW5MZWZ0ID0gbENvbXBvdW5kTm9kZS5sYWJlbE1hcmdpbkxlZnQ7XG4gICAgdmFyIGxhYmVsTWFyZ2luVG9wID0gbENvbXBvdW5kTm9kZS5sYWJlbE1hcmdpblRvcDtcblxuICAgIHRoaXMuYWRqdXN0TG9jYXRpb25zKHRoaXMudGlsZWRNZW1iZXJQYWNrW2lkXSwgbENvbXBvdW5kTm9kZS5yZWN0LngsIGxDb21wb3VuZE5vZGUucmVjdC55LCBob3Jpem9udGFsTWFyZ2luLCB2ZXJ0aWNhbE1hcmdpbiwgbGFiZWxNYXJnaW5MZWZ0LCBsYWJlbE1hcmdpblRvcCk7XG4gIH1cbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLnJlcG9wdWxhdGVaZXJvRGVncmVlTWVtYmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdGlsZWRQYWNrID0gdGhpcy50aWxlZFplcm9EZWdyZWVQYWNrO1xuXG4gIE9iamVjdC5rZXlzKHRpbGVkUGFjaykuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgY29tcG91bmROb2RlID0gc2VsZi5pZFRvRHVtbXlOb2RlW2lkXTsgLy8gR2V0IHRoZSBkdW1teSBjb21wb3VuZCBieSBpdHMgaWRcbiAgICB2YXIgaG9yaXpvbnRhbE1hcmdpbiA9IGNvbXBvdW5kTm9kZS5wYWRkaW5nTGVmdDtcbiAgICB2YXIgdmVydGljYWxNYXJnaW4gPSBjb21wb3VuZE5vZGUucGFkZGluZ1RvcDtcbiAgICB2YXIgbGFiZWxNYXJnaW5MZWZ0ID0gY29tcG91bmROb2RlLmxhYmVsTWFyZ2luTGVmdDtcbiAgICB2YXIgbGFiZWxNYXJnaW5Ub3AgPSBjb21wb3VuZE5vZGUubGFiZWxNYXJnaW5Ub3A7XG5cbiAgICAvLyBBZGp1c3QgdGhlIHBvc2l0aW9ucyBvZiBub2RlcyB3cnQgaXRzIGNvbXBvdW5kXG4gICAgc2VsZi5hZGp1c3RMb2NhdGlvbnModGlsZWRQYWNrW2lkXSwgY29tcG91bmROb2RlLnJlY3QueCwgY29tcG91bmROb2RlLnJlY3QueSwgaG9yaXpvbnRhbE1hcmdpbiwgdmVydGljYWxNYXJnaW4sIGxhYmVsTWFyZ2luTGVmdCwgbGFiZWxNYXJnaW5Ub3ApO1xuICB9KTtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmdldFRvQmVUaWxlZCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBpZCA9IG5vZGUuaWQ7XG4gIC8vZmlyc3RseSBjaGVjayB0aGUgcHJldmlvdXMgcmVzdWx0c1xuICBpZiAodGhpcy50b0JlVGlsZWRbaWRdICE9IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy50b0JlVGlsZWRbaWRdO1xuICB9XG5cbiAgLy9vbmx5IGNvbXBvdW5kIG5vZGVzIGFyZSB0byBiZSB0aWxlZFxuICB2YXIgY2hpbGRHcmFwaCA9IG5vZGUuZ2V0Q2hpbGQoKTtcbiAgaWYgKGNoaWxkR3JhcGggPT0gbnVsbCkge1xuICAgIHRoaXMudG9CZVRpbGVkW2lkXSA9IGZhbHNlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBjaGlsZHJlbiA9IGNoaWxkR3JhcGguZ2V0Tm9kZXMoKTsgLy8gR2V0IHRoZSBjaGlsZHJlbiBub2Rlc1xuXG4gIC8vYSBjb21wb3VuZCBub2RlIGlzIG5vdCB0byBiZSB0aWxlZCBpZiBhbGwgb2YgaXRzIGNvbXBvdW5kIGNoaWxkcmVuIGFyZSBub3QgdG8gYmUgdGlsZWRcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0aGVDaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgaWYgKHRoaXMuZ2V0Tm9kZURlZ3JlZSh0aGVDaGlsZCkgPiAwKSB7XG4gICAgICB0aGlzLnRvQmVUaWxlZFtpZF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvL3Bhc3MgdGhlIGNoaWxkcmVuIG5vdCBoYXZpbmcgdGhlIGNvbXBvdW5kIHN0cnVjdHVyZVxuICAgIGlmICh0aGVDaGlsZC5nZXRDaGlsZCgpID09IG51bGwpIHtcbiAgICAgIHRoaXMudG9CZVRpbGVkW3RoZUNoaWxkLmlkXSA9IGZhbHNlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmdldFRvQmVUaWxlZCh0aGVDaGlsZCkpIHtcbiAgICAgIHRoaXMudG9CZVRpbGVkW2lkXSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB0aGlzLnRvQmVUaWxlZFtpZF0gPSB0cnVlO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIEdldCBkZWdyZWUgb2YgYSBub2RlIGRlcGVuZGluZyBvZiBpdHMgZWRnZXMgYW5kIGluZGVwZW5kZW50IG9mIGl0cyBjaGlsZHJlblxuQ29TRUxheW91dC5wcm90b3R5cGUuZ2V0Tm9kZURlZ3JlZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBpZCA9IG5vZGUuaWQ7XG4gIHZhciBlZGdlcyA9IG5vZGUuZ2V0RWRnZXMoKTtcbiAgdmFyIGRlZ3JlZSA9IDA7XG5cbiAgLy8gRm9yIHRoZSBlZGdlcyBjb25uZWN0ZWRcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlZGdlID0gZWRnZXNbaV07XG4gICAgaWYgKGVkZ2UuZ2V0U291cmNlKCkuaWQgIT09IGVkZ2UuZ2V0VGFyZ2V0KCkuaWQpIHtcbiAgICAgIGRlZ3JlZSA9IGRlZ3JlZSArIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWdyZWU7XG59O1xuXG4vLyBHZXQgZGVncmVlIG9mIGEgbm9kZSB3aXRoIGl0cyBjaGlsZHJlblxuQ29TRUxheW91dC5wcm90b3R5cGUuZ2V0Tm9kZURlZ3JlZVdpdGhDaGlsZHJlbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHZhciBkZWdyZWUgPSB0aGlzLmdldE5vZGVEZWdyZWUobm9kZSk7XG4gIGlmIChub2RlLmdldENoaWxkKCkgPT0gbnVsbCkge1xuICAgIHJldHVybiBkZWdyZWU7XG4gIH1cbiAgdmFyIGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZCgpLmdldE5vZGVzKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICBkZWdyZWUgKz0gdGhpcy5nZXROb2RlRGVncmVlV2l0aENoaWxkcmVuKGNoaWxkKTtcbiAgfVxuICByZXR1cm4gZGVncmVlO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUucGVyZm9ybURGU09uQ29tcG91bmRzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNvbXBvdW5kT3JkZXIgPSBbXTtcbiAgdGhpcy5maWxsQ29tcGV4T3JkZXJCeURGUyh0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkuZ2V0Tm9kZXMoKSk7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5maWxsQ29tcGV4T3JkZXJCeURGUyA9IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGNoaWxkLmdldENoaWxkKCkgIT0gbnVsbCkge1xuICAgICAgdGhpcy5maWxsQ29tcGV4T3JkZXJCeURGUyhjaGlsZC5nZXRDaGlsZCgpLmdldE5vZGVzKCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5nZXRUb0JlVGlsZWQoY2hpbGQpKSB7XG4gICAgICB0aGlzLmNvbXBvdW5kT3JkZXIucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiogVGhpcyBtZXRob2QgcGxhY2VzIGVhY2ggemVybyBkZWdyZWUgbWVtYmVyIHdydCBnaXZlbiAoeCx5KSBjb29yZGluYXRlcyAodG9wIGxlZnQpLlxuKi9cbkNvU0VMYXlvdXQucHJvdG90eXBlLmFkanVzdExvY2F0aW9ucyA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24sIHgsIHksIGNvbXBvdW5kSG9yaXpvbnRhbE1hcmdpbiwgY29tcG91bmRWZXJ0aWNhbE1hcmdpbiwgY29tcG91bmRMYWJlbE1hcmdpbkxlZnQsIGNvbXBvdW5kTGFiZWxNYXJnaW5Ub3ApIHtcbiAgeCArPSBjb21wb3VuZEhvcml6b250YWxNYXJnaW4gKyBjb21wb3VuZExhYmVsTWFyZ2luTGVmdDtcbiAgeSArPSBjb21wb3VuZFZlcnRpY2FsTWFyZ2luICsgY29tcG91bmRMYWJlbE1hcmdpblRvcDtcblxuICB2YXIgbGVmdCA9IHg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmdhbml6YXRpb24ucm93cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciByb3cgPSBvcmdhbml6YXRpb24ucm93c1tpXTtcbiAgICB4ID0gbGVmdDtcbiAgICB2YXIgbWF4SGVpZ2h0ID0gMDtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcm93Lmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgbG5vZGUgPSByb3dbal07XG5cbiAgICAgIGxub2RlLnJlY3QueCA9IHg7IC8vICsgbG5vZGUucmVjdC53aWR0aCAvIDI7XG4gICAgICBsbm9kZS5yZWN0LnkgPSB5OyAvLyArIGxub2RlLnJlY3QuaGVpZ2h0IC8gMjtcblxuICAgICAgeCArPSBsbm9kZS5yZWN0LndpZHRoICsgb3JnYW5pemF0aW9uLmhvcml6b250YWxQYWRkaW5nO1xuXG4gICAgICBpZiAobG5vZGUucmVjdC5oZWlnaHQgPiBtYXhIZWlnaHQpIG1heEhlaWdodCA9IGxub2RlLnJlY3QuaGVpZ2h0O1xuICAgIH1cblxuICAgIHkgKz0gbWF4SGVpZ2h0ICsgb3JnYW5pemF0aW9uLnZlcnRpY2FsUGFkZGluZztcbiAgfVxufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUudGlsZUNvbXBvdW5kTWVtYmVycyA9IGZ1bmN0aW9uIChjaGlsZEdyYXBoTWFwLCBpZFRvTm9kZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMudGlsZWRNZW1iZXJQYWNrID0gW107XG5cbiAgT2JqZWN0LmtleXMoY2hpbGRHcmFwaE1hcCkuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAvLyBHZXQgdGhlIGNvbXBvdW5kIG5vZGVcbiAgICB2YXIgY29tcG91bmROb2RlID0gaWRUb05vZGVbaWRdO1xuXG4gICAgc2VsZi50aWxlZE1lbWJlclBhY2tbaWRdID0gc2VsZi50aWxlTm9kZXMoY2hpbGRHcmFwaE1hcFtpZF0sIGNvbXBvdW5kTm9kZS5wYWRkaW5nTGVmdCArIGNvbXBvdW5kTm9kZS5wYWRkaW5nUmlnaHQpO1xuXG4gICAgY29tcG91bmROb2RlLnJlY3Qud2lkdGggPSBzZWxmLnRpbGVkTWVtYmVyUGFja1tpZF0ud2lkdGg7XG4gICAgY29tcG91bmROb2RlLnJlY3QuaGVpZ2h0ID0gc2VsZi50aWxlZE1lbWJlclBhY2tbaWRdLmhlaWdodDtcbiAgICBjb21wb3VuZE5vZGUuc2V0Q2VudGVyKHNlbGYudGlsZWRNZW1iZXJQYWNrW2lkXS5jZW50ZXJYLCBzZWxmLnRpbGVkTWVtYmVyUGFja1tpZF0uY2VudGVyWSk7XG5cbiAgICAvLyBjb21wb3VuZCBsZWZ0IGFuZCB0b3AgbWFyZ2luZ3MgZm9yIGxhYmVsc1xuICAgIC8vIHdoZW4gbm9kZSBsYWJlbHMgYXJlIGluY2x1ZGVkLCB0aGVzZSB2YWx1ZXMgbWF5IGJlIHNldCB0byBkaWZmZXJlbnQgdmFsdWVzIGJlbG93IGFuZCBhcmUgdXNlZCBpbiB0aWxpbmdQb3N0TGF5b3V0LFxuICAgIC8vIG90aGVyd2lzZSB0aGV5IHN0YXkgYXMgemVyb1xuICAgIGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpbkxlZnQgPSAwO1xuICAgIGNvbXBvdW5kTm9kZS5sYWJlbE1hcmdpblRvcCA9IDA7XG5cbiAgICAvLyBVcGRhdGUgY29tcG91bmQgYm91bmRzIGNvbnNpZGVyaW5nIGl0cyBsYWJlbCBwcm9wZXJ0aWVzIGFuZCBzZXQgbGFiZWwgbWFyZ2lucyBmb3IgbGVmdCBhbmQgdG9wXG4gICAgaWYgKENvU0VDb25zdGFudHMuTk9ERV9ESU1FTlNJT05TX0lOQ0xVREVfTEFCRUxTKSB7XG5cbiAgICAgIHZhciB3aWR0aCA9IGNvbXBvdW5kTm9kZS5yZWN0LndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IGNvbXBvdW5kTm9kZS5yZWN0LmhlaWdodDtcblxuICAgICAgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFdpZHRoKSB7XG4gICAgICAgIGlmIChjb21wb3VuZE5vZGUubGFiZWxQb3NIb3Jpem9udGFsID09IFwibGVmdFwiKSB7XG4gICAgICAgICAgY29tcG91bmROb2RlLnJlY3QueCAtPSBjb21wb3VuZE5vZGUubGFiZWxXaWR0aDtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0V2lkdGgod2lkdGggKyBjb21wb3VuZE5vZGUubGFiZWxXaWR0aCk7XG4gICAgICAgICAgY29tcG91bmROb2RlLmxhYmVsTWFyZ2luTGVmdCA9IGNvbXBvdW5kTm9kZS5sYWJlbFdpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFBvc0hvcml6b250YWwgPT0gXCJjZW50ZXJcIiAmJiBjb21wb3VuZE5vZGUubGFiZWxXaWR0aCA+IHdpZHRoKSB7XG4gICAgICAgICAgY29tcG91bmROb2RlLnJlY3QueCAtPSAoY29tcG91bmROb2RlLmxhYmVsV2lkdGggLSB3aWR0aCkgLyAyO1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5zZXRXaWR0aChjb21wb3VuZE5vZGUubGFiZWxXaWR0aCk7XG4gICAgICAgICAgY29tcG91bmROb2RlLmxhYmVsTWFyZ2luTGVmdCA9IChjb21wb3VuZE5vZGUubGFiZWxXaWR0aCAtIHdpZHRoKSAvIDI7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcG91bmROb2RlLmxhYmVsUG9zSG9yaXpvbnRhbCA9PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0V2lkdGgod2lkdGggKyBjb21wb3VuZE5vZGUubGFiZWxXaWR0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodCkge1xuICAgICAgICBpZiAoY29tcG91bmROb2RlLmxhYmVsUG9zVmVydGljYWwgPT0gXCJ0b3BcIikge1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5yZWN0LnkgLT0gY29tcG91bmROb2RlLmxhYmVsSGVpZ2h0O1xuICAgICAgICAgIGNvbXBvdW5kTm9kZS5zZXRIZWlnaHQoaGVpZ2h0ICsgY29tcG91bmROb2RlLmxhYmVsSGVpZ2h0KTtcbiAgICAgICAgICBjb21wb3VuZE5vZGUubGFiZWxNYXJnaW5Ub3AgPSBjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoY29tcG91bmROb2RlLmxhYmVsUG9zVmVydGljYWwgPT0gXCJjZW50ZXJcIiAmJiBjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQgPiBoZWlnaHQpIHtcbiAgICAgICAgICBjb21wb3VuZE5vZGUucmVjdC55IC09IChjb21wb3VuZE5vZGUubGFiZWxIZWlnaHQgLSBoZWlnaHQpIC8gMjtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0SGVpZ2h0KGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodCk7XG4gICAgICAgICAgY29tcG91bmROb2RlLmxhYmVsTWFyZ2luVG9wID0gKGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodCAtIGhlaWdodCkgLyAyO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbXBvdW5kTm9kZS5sYWJlbFBvc1ZlcnRpY2FsID09IFwiYm90dG9tXCIpIHtcbiAgICAgICAgICBjb21wb3VuZE5vZGUuc2V0SGVpZ2h0KGhlaWdodCArIGNvbXBvdW5kTm9kZS5sYWJlbEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUudGlsZU5vZGVzID0gZnVuY3Rpb24gKG5vZGVzLCBtaW5XaWR0aCkge1xuICB2YXIgaG9yaXpvbnRhbE9yZyA9IHRoaXMudGlsZU5vZGVzQnlGYXZvcmluZ0RpbShub2RlcywgbWluV2lkdGgsIHRydWUpO1xuICB2YXIgdmVydGljYWxPcmcgPSB0aGlzLnRpbGVOb2Rlc0J5RmF2b3JpbmdEaW0obm9kZXMsIG1pbldpZHRoLCBmYWxzZSk7XG5cbiAgdmFyIGhvcml6b250YWxSYXRpbyA9IHRoaXMuZ2V0T3JnUmF0aW8oaG9yaXpvbnRhbE9yZyk7XG4gIHZhciB2ZXJ0aWNhbFJhdGlvID0gdGhpcy5nZXRPcmdSYXRpbyh2ZXJ0aWNhbE9yZyk7XG4gIHZhciBiZXN0T3JnO1xuXG4gIC8vIHRoZSBiZXN0IHJhdGlvIGlzIHRoZSBvbmUgdGhhdCBpcyBjbG9zZXIgdG8gMSBzaW5jZSB0aGUgcmF0aW9zIGFyZSBhbHJlYWR5IG5vcm1hbGl6ZWRcbiAgLy8gYW5kIHRoZSBiZXN0IG9yZ2FuaXphdGlvbiBpcyB0aGUgb25lIHRoYXQgaGFzIHRoZSBiZXN0IHJhdGlvXG4gIGlmICh2ZXJ0aWNhbFJhdGlvIDwgaG9yaXpvbnRhbFJhdGlvKSB7XG4gICAgYmVzdE9yZyA9IHZlcnRpY2FsT3JnO1xuICB9IGVsc2Uge1xuICAgIGJlc3RPcmcgPSBob3Jpem9udGFsT3JnO1xuICB9XG5cbiAgcmV0dXJuIGJlc3RPcmc7XG59O1xuXG4vLyBnZXQgdGhlIHdpZHRoL2hlaWdodCByYXRpbyBvZiB0aGUgb3JnYW5pemF0aW9uIHRoYXQgaXMgbm9ybWFsaXplZCBzbyB0aGF0IGl0IHdpbGwgbm90IGJlIGxlc3MgdGhhbiAxXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5nZXRPcmdSYXRpbyA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24pIHtcbiAgLy8gZ2V0IGRpbWVuc2lvbnMgYW5kIGNhbGN1bGF0ZSB0aGUgaW5pdGlhbCByYXRpb1xuICB2YXIgd2lkdGggPSBvcmdhbml6YXRpb24ud2lkdGg7XG4gIHZhciBoZWlnaHQgPSBvcmdhbml6YXRpb24uaGVpZ2h0O1xuICB2YXIgcmF0aW8gPSB3aWR0aCAvIGhlaWdodDtcblxuICAvLyBpZiB0aGUgaW5pdGlhbCByYXRpbyBpcyBsZXNzIHRoZW4gMSB0aGVuIGludmVyc2UgaXRcbiAgaWYgKHJhdGlvIDwgMSkge1xuICAgIHJhdGlvID0gMSAvIHJhdGlvO1xuICB9XG5cbiAgLy8gcmV0dXJuIHRoZSBub3JtYWxpemVkIHJhdGlvXG4gIHJldHVybiByYXRpbztcbn07XG5cbi8qXG4gKiBDYWxjdWxhdGVzIHRoZSBpZGVhbCB3aWR0aCBmb3IgdGhlIHJvd3MuIFRoaXMgbWV0aG9kIGFzc3VtZXMgdGhhdFxuICogZWFjaCBub2RlIGhhcyB0aGUgc2FtZSBzaXplcyBhbmQgY2FsY3VsYXRlcyB0aGUgaWRlYWwgcm93IHdpZHRoIHRoYXRcbiAqIGFwcHJveGltYXRlcyBhIHNxdWFyZSBzaGFwZWQgY29tcGxleCBhY2NvcmRpbmdseS4gSG93ZXZlciwgc2luY2Ugbm9kZXMgd291bGRcbiAqIGhhdmUgZGlmZmVyZW50IHNpemVzIHNvbWUgcm93cyB3b3VsZCBoYXZlIGRpZmZlcmVudCBzaXplcyBhbmQgdGhlIHJlc3VsdGluZ1xuICogc2hhcGUgd291bGQgbm90IGJlIGFuIGV4YWN0IHNxdWFyZS5cbiAqL1xuQ29TRUxheW91dC5wcm90b3R5cGUuY2FsY0lkZWFsUm93V2lkdGggPSBmdW5jdGlvbiAobWVtYmVycywgZmF2b3JIb3Jpem9udGFsRGltKSB7XG4gIC8vIFRvIGFwcHJveGltYXRlIGEgc3F1YXJlIHNoYXBlZCBjb21wbGV4IHdlIG5lZWQgdG8gbWFrZSBjb21wbGV4IHdpZHRoIGVxdWFsIHRvIGNvbXBsZXggaGVpZ2h0LlxuICAvLyBUbyBhY2hpZXZlIHRoaXMgd2UgbmVlZCB0byBzb2x2ZSB0aGUgZm9sbG93aW5nIGVxdWF0aW9uIHN5c3RlbSBmb3IgaGM6XG4gIC8vICh4ICsgYngpICogaGMgLSBieCA9ICh5ICsgYnkpICogdmMgLSBieSwgaGMgKiB2YyA9IG5cbiAgLy8gd2hlcmUgeCBpcyB0aGUgYXZhcmFnZSB3aWR0aCBvZiB0aGUgbm9kZXMsIHkgaXMgdGhlIGF2YXJhZ2UgaGVpZ2h0IG9mIG5vZGVzXG4gIC8vIGJ4IGFuZCBieSBhcmUgdGhlIGJ1ZmZlciBzaXplcyBpbiBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBkaW1lbnNpb25zIGFjY29yZGluZ2x5LFxuICAvLyBoYyBhbmQgdmMgYXJlIHRoZSBudW1iZXIgb2Ygcm93cyBpbiBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBkaW1lbnNpb25zXG4gIC8vIG4gaXMgbnVtYmVyIG9mIG1lbWJlcnMuXG5cbiAgdmFyIHZlcnRpY2FsUGFkZGluZyA9IENvU0VDb25zdGFudHMuVElMSU5HX1BBRERJTkdfVkVSVElDQUw7XG4gIHZhciBob3Jpem9udGFsUGFkZGluZyA9IENvU0VDb25zdGFudHMuVElMSU5HX1BBRERJTkdfSE9SSVpPTlRBTDtcblxuICAvLyBudW1iZXIgb2YgbWVtYmVyc1xuICB2YXIgbWVtYmVyc1NpemUgPSBtZW1iZXJzLmxlbmd0aDtcblxuICAvLyBzdW0gb2YgdGhlIHdpZHRoIG9mIGFsbCBtZW1iZXJzXG4gIHZhciB0b3RhbFdpZHRoID0gMDtcblxuICAvLyBzdW0gb2YgdGhlIGhlaWdodCBvZiBhbGwgbWVtYmVyc1xuICB2YXIgdG90YWxIZWlnaHQgPSAwO1xuXG4gIHZhciBtYXhXaWR0aCA9IDA7XG5cbiAgLy8gdHJhdmVyc2UgYWxsIG1lbWJlcnMgdG8gY2FsY3VsYXRlIHRvdGFsIHdpZHRoIGFuZCB0b3RhbCBoZWlnaHQgYW5kIGdldCB0aGUgbWF4aW11bSBtZW1iZXJzIHdpZHRoXG4gIG1lbWJlcnMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgIHRvdGFsV2lkdGggKz0gbm9kZS5nZXRXaWR0aCgpO1xuICAgIHRvdGFsSGVpZ2h0ICs9IG5vZGUuZ2V0SGVpZ2h0KCk7XG5cbiAgICBpZiAobm9kZS5nZXRXaWR0aCgpID4gbWF4V2lkdGgpIHtcbiAgICAgIG1heFdpZHRoID0gbm9kZS5nZXRXaWR0aCgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gYXZlcmFnZSB3aWR0aCBvZiB0aGUgbWVtYmVyc1xuICB2YXIgYXZlcmFnZVdpZHRoID0gdG90YWxXaWR0aCAvIG1lbWJlcnNTaXplO1xuXG4gIC8vIGF2ZXJhZ2UgaGVpZ2h0IG9mIHRoZSBtZW1iZXJzXG4gIHZhciBhdmVyYWdlSGVpZ2h0ID0gdG90YWxIZWlnaHQgLyBtZW1iZXJzU2l6ZTtcblxuICAvLyBzb2x2aW5nIHRoZSBpbml0aWFsIGVxdWF0aW9uIHN5c3RlbSBmb3IgdGhlIGhjIHlpZWxkcyB0aGUgZm9sbG93aW5nIHNlY29uZCBkZWdyZWUgZXF1YXRpb246XG4gIC8vIGhjXjIgKiAoeCtieCkgKyBoYyAqIChieSAtIGJ4KSAtIG4gKiAoeSArIGJ5KSA9IDBcblxuICAvLyB0aGUgZGVsdGEgdmFsdWUgdG8gc29sdmUgdGhlIGVxdWF0aW9uIGFib3ZlIGZvciBoY1xuICB2YXIgZGVsdGEgPSBNYXRoLnBvdyh2ZXJ0aWNhbFBhZGRpbmcgLSBob3Jpem9udGFsUGFkZGluZywgMikgKyA0ICogKGF2ZXJhZ2VXaWR0aCArIGhvcml6b250YWxQYWRkaW5nKSAqIChhdmVyYWdlSGVpZ2h0ICsgdmVydGljYWxQYWRkaW5nKSAqIG1lbWJlcnNTaXplO1xuXG4gIC8vIHNvbHZlIHRoZSBlcXVhdGlvbiB1c2luZyBkZWx0YSB2YWx1ZSB0byBjYWxjdWxhdGUgdGhlIGhvcml6b250YWwgY291bnRcbiAgLy8gdGhhdCByZXByZXNlbnRzIHRoZSBudW1iZXIgb2Ygbm9kZXMgaW4gYW4gaWRlYWwgcm93XG4gIHZhciBob3Jpem9udGFsQ291bnREb3VibGUgPSAoaG9yaXpvbnRhbFBhZGRpbmcgLSB2ZXJ0aWNhbFBhZGRpbmcgKyBNYXRoLnNxcnQoZGVsdGEpKSAvICgyICogKGF2ZXJhZ2VXaWR0aCArIGhvcml6b250YWxQYWRkaW5nKSk7XG4gIC8vIHJvdW5kIHRoZSBjYWxjdWxhdGVkIGhvcml6b250YWwgY291bnQgdXAgb3IgZG93biBhY2NvcmRpbmcgdG8gdGhlIGZhdm9yZWQgZGltZW5zaW9uXG4gIHZhciBob3Jpem9udGFsQ291bnQ7XG5cbiAgaWYgKGZhdm9ySG9yaXpvbnRhbERpbSkge1xuICAgIGhvcml6b250YWxDb3VudCA9IE1hdGguY2VpbChob3Jpem9udGFsQ291bnREb3VibGUpO1xuICAgIC8vIGlmIGhvcml6b250YWxDb3VudCBjb3VudCBpcyBub3QgYSBmbG9hdCB2YWx1ZSB0aGVuIGJvdGggb2Ygcm91bmRpbmcgdG8gZmxvb3IgYW5kIGNlaWxcbiAgICAvLyB3aWxsIHlpZWxkIHRoZSBzYW1lIHZhbHVlcy4gSW5zdGVhZCBvZiByZXBlYXRpbmcgdGhlIHNhbWUgY2FsY3VsYXRpb24gdHJ5IGdvaW5nIHVwXG4gICAgLy8gd2hpbGUgZmF2b3JpbmcgaG9yaXpvbnRhbCBkaW1lbnNpb24gaW4gc3VjaCBjYXNlc1xuICAgIGlmIChob3Jpem9udGFsQ291bnQgPT0gaG9yaXpvbnRhbENvdW50RG91YmxlKSB7XG4gICAgICBob3Jpem9udGFsQ291bnQrKztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaG9yaXpvbnRhbENvdW50ID0gTWF0aC5mbG9vcihob3Jpem9udGFsQ291bnREb3VibGUpO1xuICB9XG5cbiAgLy8gaWRlYWwgd2lkdGggdG8gYmUgY2FsY3VsYXRlZFxuICB2YXIgaWRlYWxXaWR0aCA9IGhvcml6b250YWxDb3VudCAqIChhdmVyYWdlV2lkdGggKyBob3Jpem9udGFsUGFkZGluZykgLSBob3Jpem9udGFsUGFkZGluZztcblxuICAvLyBpZiBtYXggd2lkdGggaXMgYmlnZ2VyIHRoYW4gY2FsY3VsYXRlZCBpZGVhbCB3aWR0aCByZXNldCBpZGVhbCB3aWR0aCB0byBpdFxuICBpZiAobWF4V2lkdGggPiBpZGVhbFdpZHRoKSB7XG4gICAgaWRlYWxXaWR0aCA9IG1heFdpZHRoO1xuICB9XG5cbiAgLy8gYWRkIHRoZSBsZWZ0LXJpZ2h0IG1hcmdpbnMgdG8gdGhlIGlkZWFsIHJvdyB3aWR0aFxuICBpZGVhbFdpZHRoICs9IGhvcml6b250YWxQYWRkaW5nICogMjtcblxuICAvLyByZXR1cm4gdGhlIGlkZWFsIHJvdyB3aWR0aDFcbiAgcmV0dXJuIGlkZWFsV2lkdGg7XG59O1xuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS50aWxlTm9kZXNCeUZhdm9yaW5nRGltID0gZnVuY3Rpb24gKG5vZGVzLCBtaW5XaWR0aCwgZmF2b3JIb3Jpem9udGFsRGltKSB7XG4gIHZhciB2ZXJ0aWNhbFBhZGRpbmcgPSBDb1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX1ZFUlRJQ0FMO1xuICB2YXIgaG9yaXpvbnRhbFBhZGRpbmcgPSBDb1NFQ29uc3RhbnRzLlRJTElOR19QQURESU5HX0hPUklaT05UQUw7XG4gIHZhciB0aWxpbmdDb21wYXJlQnkgPSBDb1NFQ29uc3RhbnRzLlRJTElOR19DT01QQVJFX0JZO1xuICB2YXIgb3JnYW5pemF0aW9uID0ge1xuICAgIHJvd3M6IFtdLFxuICAgIHJvd1dpZHRoOiBbXSxcbiAgICByb3dIZWlnaHQ6IFtdLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogbWluV2lkdGgsIC8vIGFzc3VtZSBtaW5IZWlnaHQgZXF1YWxzIHRvIG1pbldpZHRoXG4gICAgdmVydGljYWxQYWRkaW5nOiB2ZXJ0aWNhbFBhZGRpbmcsXG4gICAgaG9yaXpvbnRhbFBhZGRpbmc6IGhvcml6b250YWxQYWRkaW5nLFxuICAgIGNlbnRlclg6IDAsXG4gICAgY2VudGVyWTogMFxuICB9O1xuXG4gIGlmICh0aWxpbmdDb21wYXJlQnkpIHtcbiAgICBvcmdhbml6YXRpb24uaWRlYWxSb3dXaWR0aCA9IHRoaXMuY2FsY0lkZWFsUm93V2lkdGgobm9kZXMsIGZhdm9ySG9yaXpvbnRhbERpbSk7XG4gIH1cblxuICB2YXIgZ2V0Tm9kZUFyZWEgPSBmdW5jdGlvbiBnZXROb2RlQXJlYShuKSB7XG4gICAgcmV0dXJuIG4ucmVjdC53aWR0aCAqIG4ucmVjdC5oZWlnaHQ7XG4gIH07XG5cbiAgdmFyIGFyZWFDb21wYXJlRmNuID0gZnVuY3Rpb24gYXJlYUNvbXBhcmVGY24objEsIG4yKSB7XG4gICAgcmV0dXJuIGdldE5vZGVBcmVhKG4yKSAtIGdldE5vZGVBcmVhKG4xKTtcbiAgfTtcblxuICAvLyBTb3J0IHRoZSBub2RlcyBpbiBkZXNjZW5kaW5nIG9yZGVyIG9mIHRoZWlyIGFyZWFzXG4gIG5vZGVzLnNvcnQoZnVuY3Rpb24gKG4xLCBuMikge1xuICAgIHZhciBjbXBCeSA9IGFyZWFDb21wYXJlRmNuO1xuICAgIGlmIChvcmdhbml6YXRpb24uaWRlYWxSb3dXaWR0aCkge1xuICAgICAgY21wQnkgPSB0aWxpbmdDb21wYXJlQnk7XG4gICAgICByZXR1cm4gY21wQnkobjEuaWQsIG4yLmlkKTtcbiAgICB9XG4gICAgcmV0dXJuIGNtcEJ5KG4xLCBuMik7XG4gIH0pO1xuXG4gIC8vIENyZWF0ZSB0aGUgb3JnYW5pemF0aW9uIC0+IGNhbGN1bGF0ZSBjb21wb3VuZCBjZW50ZXJcbiAgdmFyIHN1bUNlbnRlclggPSAwO1xuICB2YXIgc3VtQ2VudGVyWSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbE5vZGUgPSBub2Rlc1tpXTtcblxuICAgIHN1bUNlbnRlclggKz0gbE5vZGUuZ2V0Q2VudGVyWCgpO1xuICAgIHN1bUNlbnRlclkgKz0gbE5vZGUuZ2V0Q2VudGVyWSgpO1xuICB9XG5cbiAgb3JnYW5pemF0aW9uLmNlbnRlclggPSBzdW1DZW50ZXJYIC8gbm9kZXMubGVuZ3RoO1xuICBvcmdhbml6YXRpb24uY2VudGVyWSA9IHN1bUNlbnRlclkgLyBub2Rlcy5sZW5ndGg7XG5cbiAgLy8gQ3JlYXRlIHRoZSBvcmdhbml6YXRpb24gLT4gdGlsZSBtZW1iZXJzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbE5vZGUgPSBub2Rlc1tpXTtcblxuICAgIGlmIChvcmdhbml6YXRpb24ucm93cy5sZW5ndGggPT0gMCkge1xuICAgICAgdGhpcy5pbnNlcnROb2RlVG9Sb3cob3JnYW5pemF0aW9uLCBsTm9kZSwgMCwgbWluV2lkdGgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jYW5BZGRIb3Jpem9udGFsKG9yZ2FuaXphdGlvbiwgbE5vZGUucmVjdC53aWR0aCwgbE5vZGUucmVjdC5oZWlnaHQpKSB7XG4gICAgICB2YXIgcm93SW5kZXggPSBvcmdhbml6YXRpb24ucm93cy5sZW5ndGggLSAxO1xuICAgICAgaWYgKCFvcmdhbml6YXRpb24uaWRlYWxSb3dXaWR0aCkge1xuICAgICAgICByb3dJbmRleCA9IHRoaXMuZ2V0U2hvcnRlc3RSb3dJbmRleChvcmdhbml6YXRpb24pO1xuICAgICAgfVxuICAgICAgdGhpcy5pbnNlcnROb2RlVG9Sb3cob3JnYW5pemF0aW9uLCBsTm9kZSwgcm93SW5kZXgsIG1pbldpZHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbnNlcnROb2RlVG9Sb3cob3JnYW5pemF0aW9uLCBsTm9kZSwgb3JnYW5pemF0aW9uLnJvd3MubGVuZ3RoLCBtaW5XaWR0aCk7XG4gICAgfVxuXG4gICAgdGhpcy5zaGlmdFRvTGFzdFJvdyhvcmdhbml6YXRpb24pO1xuICB9XG5cbiAgcmV0dXJuIG9yZ2FuaXphdGlvbjtcbn07XG5cbkNvU0VMYXlvdXQucHJvdG90eXBlLmluc2VydE5vZGVUb1JvdyA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24sIG5vZGUsIHJvd0luZGV4LCBtaW5XaWR0aCkge1xuICB2YXIgbWluQ29tcG91bmRTaXplID0gbWluV2lkdGg7XG5cbiAgLy8gQWRkIG5ldyByb3cgaWYgbmVlZGVkXG4gIGlmIChyb3dJbmRleCA9PSBvcmdhbml6YXRpb24ucm93cy5sZW5ndGgpIHtcbiAgICB2YXIgc2Vjb25kRGltZW5zaW9uID0gW107XG5cbiAgICBvcmdhbml6YXRpb24ucm93cy5wdXNoKHNlY29uZERpbWVuc2lvbik7XG4gICAgb3JnYW5pemF0aW9uLnJvd1dpZHRoLnB1c2gobWluQ29tcG91bmRTaXplKTtcbiAgICBvcmdhbml6YXRpb24ucm93SGVpZ2h0LnB1c2goMCk7XG4gIH1cblxuICAvLyBVcGRhdGUgcm93IHdpZHRoXG4gIHZhciB3ID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW3Jvd0luZGV4XSArIG5vZGUucmVjdC53aWR0aDtcblxuICBpZiAob3JnYW5pemF0aW9uLnJvd3Nbcm93SW5kZXhdLmxlbmd0aCA+IDApIHtcbiAgICB3ICs9IG9yZ2FuaXphdGlvbi5ob3Jpem9udGFsUGFkZGluZztcbiAgfVxuXG4gIG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtyb3dJbmRleF0gPSB3O1xuICAvLyBVcGRhdGUgY29tcG91bmQgd2lkdGhcbiAgaWYgKG9yZ2FuaXphdGlvbi53aWR0aCA8IHcpIHtcbiAgICBvcmdhbml6YXRpb24ud2lkdGggPSB3O1xuICB9XG5cbiAgLy8gVXBkYXRlIGhlaWdodFxuICB2YXIgaCA9IG5vZGUucmVjdC5oZWlnaHQ7XG4gIGlmIChyb3dJbmRleCA+IDApIGggKz0gb3JnYW5pemF0aW9uLnZlcnRpY2FsUGFkZGluZztcblxuICB2YXIgZXh0cmFIZWlnaHQgPSAwO1xuICBpZiAoaCA+IG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbcm93SW5kZXhdKSB7XG4gICAgZXh0cmFIZWlnaHQgPSBvcmdhbml6YXRpb24ucm93SGVpZ2h0W3Jvd0luZGV4XTtcbiAgICBvcmdhbml6YXRpb24ucm93SGVpZ2h0W3Jvd0luZGV4XSA9IGg7XG4gICAgZXh0cmFIZWlnaHQgPSBvcmdhbml6YXRpb24ucm93SGVpZ2h0W3Jvd0luZGV4XSAtIGV4dHJhSGVpZ2h0O1xuICB9XG5cbiAgb3JnYW5pemF0aW9uLmhlaWdodCArPSBleHRyYUhlaWdodDtcblxuICAvLyBJbnNlcnQgbm9kZVxuICBvcmdhbml6YXRpb24ucm93c1tyb3dJbmRleF0ucHVzaChub2RlKTtcbn07XG5cbi8vU2NhbnMgdGhlIHJvd3Mgb2YgYW4gb3JnYW5pemF0aW9uIGFuZCByZXR1cm5zIHRoZSBvbmUgd2l0aCB0aGUgbWluIHdpZHRoXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5nZXRTaG9ydGVzdFJvd0luZGV4ID0gZnVuY3Rpb24gKG9yZ2FuaXphdGlvbikge1xuICB2YXIgciA9IC0xO1xuICB2YXIgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZ2FuaXphdGlvbi5yb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtpXSA8IG1pbikge1xuICAgICAgciA9IGk7XG4gICAgICBtaW4gPSBvcmdhbml6YXRpb24ucm93V2lkdGhbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiByO1xufTtcblxuLy9TY2FucyB0aGUgcm93cyBvZiBhbiBvcmdhbml6YXRpb24gYW5kIHJldHVybnMgdGhlIG9uZSB3aXRoIHRoZSBtYXggd2lkdGhcbkNvU0VMYXlvdXQucHJvdG90eXBlLmdldExvbmdlc3RSb3dJbmRleCA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24pIHtcbiAgdmFyIHIgPSAtMTtcbiAgdmFyIG1heCA9IE51bWJlci5NSU5fVkFMVUU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmdhbml6YXRpb24ucm93cy5sZW5ndGg7IGkrKykge1xuXG4gICAgaWYgKG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtpXSA+IG1heCkge1xuICAgICAgciA9IGk7XG4gICAgICBtYXggPSBvcmdhbml6YXRpb24ucm93V2lkdGhbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHI7XG59O1xuXG4vKipcbiogVGhpcyBtZXRob2QgY2hlY2tzIHdoZXRoZXIgYWRkaW5nIGV4dHJhIHdpZHRoIHRvIHRoZSBvcmdhbml6YXRpb24gdmlvbGF0ZXNcbiogdGhlIGFzcGVjdCByYXRpbygxKSBvciBub3QuXG4qL1xuQ29TRUxheW91dC5wcm90b3R5cGUuY2FuQWRkSG9yaXpvbnRhbCA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24sIGV4dHJhV2lkdGgsIGV4dHJhSGVpZ2h0KSB7XG5cbiAgLy8gaWYgdGhlcmUgaXMgYW4gaWRlYWwgcm93IHdpZHRoIHNwZWNpZmllZCB1c2UgaXQgaW5zdGVhZCBvZiBjaGVja2luZyB0aGUgYXNwZWN0IHJhdGlvXG4gIGlmIChvcmdhbml6YXRpb24uaWRlYWxSb3dXaWR0aCkge1xuICAgIHZhciBsYXN0Um93SW5kZXggPSBvcmdhbml6YXRpb24ucm93cy5sZW5ndGggLSAxO1xuICAgIHZhciBsYXN0Um93V2lkdGggPSBvcmdhbml6YXRpb24ucm93V2lkdGhbbGFzdFJvd0luZGV4XTtcblxuICAgIC8vIGNoZWNrIGFuZCByZXR1cm4gaWYgaWRlYWwgcm93IHdpZHRoIHdpbGwgYmUgZXhjZWVkIGlmIHRoZSBub2RlIGlzIGFkZGVkIHRvIHRoZSByb3dcbiAgICByZXR1cm4gbGFzdFJvd1dpZHRoICsgZXh0cmFXaWR0aCArIG9yZ2FuaXphdGlvbi5ob3Jpem9udGFsUGFkZGluZyA8PSBvcmdhbml6YXRpb24uaWRlYWxSb3dXaWR0aDtcbiAgfVxuXG4gIHZhciBzcmkgPSB0aGlzLmdldFNob3J0ZXN0Um93SW5kZXgob3JnYW5pemF0aW9uKTtcblxuICBpZiAoc3JpIDwgMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIG1pbiA9IG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtzcmldO1xuXG4gIGlmIChtaW4gKyBvcmdhbml6YXRpb24uaG9yaXpvbnRhbFBhZGRpbmcgKyBleHRyYVdpZHRoIDw9IG9yZ2FuaXphdGlvbi53aWR0aCkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIGhEaWZmID0gMDtcblxuICAvLyBBZGRpbmcgdG8gYW4gZXhpc3Rpbmcgcm93XG4gIGlmIChvcmdhbml6YXRpb24ucm93SGVpZ2h0W3NyaV0gPCBleHRyYUhlaWdodCkge1xuICAgIGlmIChzcmkgPiAwKSBoRGlmZiA9IGV4dHJhSGVpZ2h0ICsgb3JnYW5pemF0aW9uLnZlcnRpY2FsUGFkZGluZyAtIG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbc3JpXTtcbiAgfVxuXG4gIHZhciBhZGRfdG9fcm93X3JhdGlvO1xuICBpZiAob3JnYW5pemF0aW9uLndpZHRoIC0gbWluID49IGV4dHJhV2lkdGggKyBvcmdhbml6YXRpb24uaG9yaXpvbnRhbFBhZGRpbmcpIHtcbiAgICBhZGRfdG9fcm93X3JhdGlvID0gKG9yZ2FuaXphdGlvbi5oZWlnaHQgKyBoRGlmZikgLyAobWluICsgZXh0cmFXaWR0aCArIG9yZ2FuaXphdGlvbi5ob3Jpem9udGFsUGFkZGluZyk7XG4gIH0gZWxzZSB7XG4gICAgYWRkX3RvX3Jvd19yYXRpbyA9IChvcmdhbml6YXRpb24uaGVpZ2h0ICsgaERpZmYpIC8gb3JnYW5pemF0aW9uLndpZHRoO1xuICB9XG5cbiAgLy8gQWRkaW5nIGEgbmV3IHJvdyBmb3IgdGhpcyBub2RlXG4gIGhEaWZmID0gZXh0cmFIZWlnaHQgKyBvcmdhbml6YXRpb24udmVydGljYWxQYWRkaW5nO1xuICB2YXIgYWRkX25ld19yb3dfcmF0aW87XG4gIGlmIChvcmdhbml6YXRpb24ud2lkdGggPCBleHRyYVdpZHRoKSB7XG4gICAgYWRkX25ld19yb3dfcmF0aW8gPSAob3JnYW5pemF0aW9uLmhlaWdodCArIGhEaWZmKSAvIGV4dHJhV2lkdGg7XG4gIH0gZWxzZSB7XG4gICAgYWRkX25ld19yb3dfcmF0aW8gPSAob3JnYW5pemF0aW9uLmhlaWdodCArIGhEaWZmKSAvIG9yZ2FuaXphdGlvbi53aWR0aDtcbiAgfVxuXG4gIGlmIChhZGRfbmV3X3Jvd19yYXRpbyA8IDEpIGFkZF9uZXdfcm93X3JhdGlvID0gMSAvIGFkZF9uZXdfcm93X3JhdGlvO1xuXG4gIGlmIChhZGRfdG9fcm93X3JhdGlvIDwgMSkgYWRkX3RvX3Jvd19yYXRpbyA9IDEgLyBhZGRfdG9fcm93X3JhdGlvO1xuXG4gIHJldHVybiBhZGRfdG9fcm93X3JhdGlvIDwgYWRkX25ld19yb3dfcmF0aW87XG59O1xuXG4vL0lmIG1vdmluZyB0aGUgbGFzdCBub2RlIGZyb20gdGhlIGxvbmdlc3Qgcm93IGFuZCBhZGRpbmcgaXQgdG8gdGhlIGxhc3Rcbi8vcm93IG1ha2VzIHRoZSBib3VuZGluZyBib3ggc21hbGxlciwgZG8gaXQuXG5Db1NFTGF5b3V0LnByb3RvdHlwZS5zaGlmdFRvTGFzdFJvdyA9IGZ1bmN0aW9uIChvcmdhbml6YXRpb24pIHtcbiAgdmFyIGxvbmdlc3QgPSB0aGlzLmdldExvbmdlc3RSb3dJbmRleChvcmdhbml6YXRpb24pO1xuICB2YXIgbGFzdCA9IG9yZ2FuaXphdGlvbi5yb3dXaWR0aC5sZW5ndGggLSAxO1xuICB2YXIgcm93ID0gb3JnYW5pemF0aW9uLnJvd3NbbG9uZ2VzdF07XG4gIHZhciBub2RlID0gcm93W3Jvdy5sZW5ndGggLSAxXTtcblxuICB2YXIgZGlmZiA9IG5vZGUud2lkdGggKyBvcmdhbml6YXRpb24uaG9yaXpvbnRhbFBhZGRpbmc7XG5cbiAgLy8gQ2hlY2sgaWYgdGhlcmUgaXMgZW5vdWdoIHNwYWNlIG9uIHRoZSBsYXN0IHJvd1xuICBpZiAob3JnYW5pemF0aW9uLndpZHRoIC0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW2xhc3RdID4gZGlmZiAmJiBsb25nZXN0ICE9IGxhc3QpIHtcbiAgICAvLyBSZW1vdmUgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgbG9uZ2VzdCByb3dcbiAgICByb3cuc3BsaWNlKC0xLCAxKTtcblxuICAgIC8vIFB1c2ggaXQgdG8gdGhlIGxhc3Qgcm93XG4gICAgb3JnYW5pemF0aW9uLnJvd3NbbGFzdF0ucHVzaChub2RlKTtcblxuICAgIG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtsb25nZXN0XSA9IG9yZ2FuaXphdGlvbi5yb3dXaWR0aFtsb25nZXN0XSAtIGRpZmY7XG4gICAgb3JnYW5pemF0aW9uLnJvd1dpZHRoW2xhc3RdID0gb3JnYW5pemF0aW9uLnJvd1dpZHRoW2xhc3RdICsgZGlmZjtcbiAgICBvcmdhbml6YXRpb24ud2lkdGggPSBvcmdhbml6YXRpb24ucm93V2lkdGhbaW5zdGFuY2UuZ2V0TG9uZ2VzdFJvd0luZGV4KG9yZ2FuaXphdGlvbildO1xuXG4gICAgLy8gVXBkYXRlIGhlaWdodHMgb2YgdGhlIG9yZ2FuaXphdGlvblxuICAgIHZhciBtYXhIZWlnaHQgPSBOdW1iZXIuTUlOX1ZBTFVFO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcm93Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocm93W2ldLmhlaWdodCA+IG1heEhlaWdodCkgbWF4SGVpZ2h0ID0gcm93W2ldLmhlaWdodDtcbiAgICB9XG4gICAgaWYgKGxvbmdlc3QgPiAwKSBtYXhIZWlnaHQgKz0gb3JnYW5pemF0aW9uLnZlcnRpY2FsUGFkZGluZztcblxuICAgIHZhciBwcmV2VG90YWwgPSBvcmdhbml6YXRpb24ucm93SGVpZ2h0W2xvbmdlc3RdICsgb3JnYW5pemF0aW9uLnJvd0hlaWdodFtsYXN0XTtcblxuICAgIG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbbG9uZ2VzdF0gPSBtYXhIZWlnaHQ7XG4gICAgaWYgKG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbbGFzdF0gPCBub2RlLmhlaWdodCArIG9yZ2FuaXphdGlvbi52ZXJ0aWNhbFBhZGRpbmcpIG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbbGFzdF0gPSBub2RlLmhlaWdodCArIG9yZ2FuaXphdGlvbi52ZXJ0aWNhbFBhZGRpbmc7XG5cbiAgICB2YXIgZmluYWxUb3RhbCA9IG9yZ2FuaXphdGlvbi5yb3dIZWlnaHRbbG9uZ2VzdF0gKyBvcmdhbml6YXRpb24ucm93SGVpZ2h0W2xhc3RdO1xuICAgIG9yZ2FuaXphdGlvbi5oZWlnaHQgKz0gZmluYWxUb3RhbCAtIHByZXZUb3RhbDtcblxuICAgIHRoaXMuc2hpZnRUb0xhc3RSb3cob3JnYW5pemF0aW9uKTtcbiAgfVxufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUudGlsaW5nUHJlTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoQ29TRUNvbnN0YW50cy5USUxFKSB7XG4gICAgLy8gRmluZCB6ZXJvIGRlZ3JlZSBub2RlcyBhbmQgY3JlYXRlIGEgY29tcG91bmQgZm9yIGVhY2ggbGV2ZWxcbiAgICB0aGlzLmdyb3VwWmVyb0RlZ3JlZU1lbWJlcnMoKTtcbiAgICAvLyBUaWxlIGFuZCBjbGVhciBjaGlsZHJlbiBvZiBlYWNoIGNvbXBvdW5kXG4gICAgdGhpcy5jbGVhckNvbXBvdW5kcygpO1xuICAgIC8vIFNlcGFyYXRlbHkgdGlsZSBhbmQgY2xlYXIgemVybyBkZWdyZWUgbm9kZXMgZm9yIGVhY2ggbGV2ZWxcbiAgICB0aGlzLmNsZWFyWmVyb0RlZ3JlZU1lbWJlcnMoKTtcbiAgfVxufTtcblxuQ29TRUxheW91dC5wcm90b3R5cGUudGlsaW5nUG9zdExheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKENvU0VDb25zdGFudHMuVElMRSkge1xuICAgIHRoaXMucmVwb3B1bGF0ZVplcm9EZWdyZWVNZW1iZXJzKCk7XG4gICAgdGhpcy5yZXBvcHVsYXRlQ29tcG91bmRzKCk7XG4gIH1cbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBTZWN0aW9uOiBUcmVlIFJlZHVjdGlvbiBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUmVkdWNlIHRyZWVzIFxuQ29TRUxheW91dC5wcm90b3R5cGUucmVkdWNlVHJlZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwcnVuZWROb2Rlc0FsbCA9IFtdO1xuICB2YXIgY29udGFpbnNMZWFmID0gdHJ1ZTtcbiAgdmFyIG5vZGU7XG5cbiAgd2hpbGUgKGNvbnRhaW5zTGVhZikge1xuICAgIHZhciBhbGxOb2RlcyA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbE5vZGVzKCk7XG4gICAgdmFyIHBydW5lZE5vZGVzSW5TdGVwVGVtcCA9IFtdO1xuICAgIGNvbnRhaW5zTGVhZiA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbm9kZSA9IGFsbE5vZGVzW2ldO1xuICAgICAgaWYgKG5vZGUuZ2V0RWRnZXMoKS5sZW5ndGggPT0gMSAmJiAhbm9kZS5nZXRFZGdlcygpWzBdLmlzSW50ZXJHcmFwaCAmJiBub2RlLmdldENoaWxkKCkgPT0gbnVsbCkge1xuICAgICAgICBpZiAoQ29TRUNvbnN0YW50cy5QVVJFX0lOQ1JFTUVOVEFMKSB7XG4gICAgICAgICAgdmFyIG90aGVyRW5kID0gbm9kZS5nZXRFZGdlcygpWzBdLmdldE90aGVyRW5kKG5vZGUpO1xuICAgICAgICAgIHZhciByZWxhdGl2ZVBvc2l0aW9uID0gbmV3IERpbWVuc2lvbkQobm9kZS5nZXRDZW50ZXJYKCkgLSBvdGhlckVuZC5nZXRDZW50ZXJYKCksIG5vZGUuZ2V0Q2VudGVyWSgpIC0gb3RoZXJFbmQuZ2V0Q2VudGVyWSgpKTtcbiAgICAgICAgICBwcnVuZWROb2Rlc0luU3RlcFRlbXAucHVzaChbbm9kZSwgbm9kZS5nZXRFZGdlcygpWzBdLCBub2RlLmdldE93bmVyKCksIHJlbGF0aXZlUG9zaXRpb25dKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcnVuZWROb2Rlc0luU3RlcFRlbXAucHVzaChbbm9kZSwgbm9kZS5nZXRFZGdlcygpWzBdLCBub2RlLmdldE93bmVyKCldKTtcbiAgICAgICAgfVxuICAgICAgICBjb250YWluc0xlYWYgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGFpbnNMZWFmID09IHRydWUpIHtcbiAgICAgIHZhciBwcnVuZWROb2Rlc0luU3RlcCA9IFtdO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcnVuZWROb2Rlc0luU3RlcFRlbXAubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHBydW5lZE5vZGVzSW5TdGVwVGVtcFtqXVswXS5nZXRFZGdlcygpLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgcHJ1bmVkTm9kZXNJblN0ZXAucHVzaChwcnVuZWROb2Rlc0luU3RlcFRlbXBbal0pO1xuICAgICAgICAgIHBydW5lZE5vZGVzSW5TdGVwVGVtcFtqXVswXS5nZXRPd25lcigpLnJlbW92ZShwcnVuZWROb2Rlc0luU3RlcFRlbXBbal1bMF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcnVuZWROb2Rlc0FsbC5wdXNoKHBydW5lZE5vZGVzSW5TdGVwKTtcbiAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXMoKTtcbiAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsRWRnZXMoKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5wcnVuZWROb2Rlc0FsbCA9IHBydW5lZE5vZGVzQWxsO1xufTtcblxuLy8gR3JvdyB0cmVlIG9uZSBzdGVwIFxuQ29TRUxheW91dC5wcm90b3R5cGUuZ3Jvd1RyZWUgPSBmdW5jdGlvbiAocHJ1bmVkTm9kZXNBbGwpIHtcbiAgdmFyIGxlbmd0aE9mUHJ1bmVkTm9kZXNJblN0ZXAgPSBwcnVuZWROb2Rlc0FsbC5sZW5ndGg7XG4gIHZhciBwcnVuZWROb2Rlc0luU3RlcCA9IHBydW5lZE5vZGVzQWxsW2xlbmd0aE9mUHJ1bmVkTm9kZXNJblN0ZXAgLSAxXTtcblxuICB2YXIgbm9kZURhdGE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJ1bmVkTm9kZXNJblN0ZXAubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlRGF0YSA9IHBydW5lZE5vZGVzSW5TdGVwW2ldO1xuXG4gICAgdGhpcy5maW5kUGxhY2Vmb3JQcnVuZWROb2RlKG5vZGVEYXRhKTtcblxuICAgIG5vZGVEYXRhWzJdLmFkZChub2RlRGF0YVswXSk7XG4gICAgbm9kZURhdGFbMl0uYWRkKG5vZGVEYXRhWzFdLCBub2RlRGF0YVsxXS5zb3VyY2UsIG5vZGVEYXRhWzFdLnRhcmdldCk7XG4gIH1cblxuICBwcnVuZWROb2Rlc0FsbC5zcGxpY2UocHJ1bmVkTm9kZXNBbGwubGVuZ3RoIC0gMSwgMSk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsTm9kZXMoKTtcbiAgdGhpcy5ncmFwaE1hbmFnZXIucmVzZXRBbGxFZGdlcygpO1xufTtcblxuLy8gRmluZCBhbiBhcHByb3ByaWF0ZSBwb3NpdGlvbiB0byByZXBsYWNlIHBydW5lZCBub2RlLCB0aGlzIG1ldGhvZCBjYW4gYmUgaW1wcm92ZWRcbkNvU0VMYXlvdXQucHJvdG90eXBlLmZpbmRQbGFjZWZvclBydW5lZE5vZGUgPSBmdW5jdGlvbiAobm9kZURhdGEpIHtcblxuICB2YXIgZ3JpZEZvclBydW5lZE5vZGU7XG4gIHZhciBub2RlVG9Db25uZWN0O1xuICB2YXIgcHJ1bmVkTm9kZSA9IG5vZGVEYXRhWzBdO1xuICBpZiAocHJ1bmVkTm9kZSA9PSBub2RlRGF0YVsxXS5zb3VyY2UpIHtcbiAgICBub2RlVG9Db25uZWN0ID0gbm9kZURhdGFbMV0udGFyZ2V0O1xuICB9IGVsc2Uge1xuICAgIG5vZGVUb0Nvbm5lY3QgPSBub2RlRGF0YVsxXS5zb3VyY2U7XG4gIH1cblxuICBpZiAoQ29TRUNvbnN0YW50cy5QVVJFX0lOQ1JFTUVOVEFMKSB7XG4gICAgcHJ1bmVkTm9kZS5zZXRDZW50ZXIobm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJYKCkgKyBub2RlRGF0YVszXS5nZXRXaWR0aCgpLCBub2RlVG9Db25uZWN0LmdldENlbnRlclkoKSArIG5vZGVEYXRhWzNdLmdldEhlaWdodCgpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3RhcnRHcmlkWCA9IG5vZGVUb0Nvbm5lY3Quc3RhcnRYO1xuICAgIHZhciBmaW5pc2hHcmlkWCA9IG5vZGVUb0Nvbm5lY3QuZmluaXNoWDtcbiAgICB2YXIgc3RhcnRHcmlkWSA9IG5vZGVUb0Nvbm5lY3Quc3RhcnRZO1xuICAgIHZhciBmaW5pc2hHcmlkWSA9IG5vZGVUb0Nvbm5lY3QuZmluaXNoWTtcblxuICAgIHZhciB1cE5vZGVDb3VudCA9IDA7XG4gICAgdmFyIGRvd25Ob2RlQ291bnQgPSAwO1xuICAgIHZhciByaWdodE5vZGVDb3VudCA9IDA7XG4gICAgdmFyIGxlZnROb2RlQ291bnQgPSAwO1xuICAgIHZhciBjb250cm9sUmVnaW9ucyA9IFt1cE5vZGVDb3VudCwgcmlnaHROb2RlQ291bnQsIGRvd25Ob2RlQ291bnQsIGxlZnROb2RlQ291bnRdO1xuXG4gICAgaWYgKHN0YXJ0R3JpZFkgPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRHcmlkWDsgaSA8PSBmaW5pc2hHcmlkWDsgaSsrKSB7XG4gICAgICAgIGNvbnRyb2xSZWdpb25zWzBdICs9IHRoaXMuZ3JpZFtpXVtzdGFydEdyaWRZIC0gMV0ubGVuZ3RoICsgdGhpcy5ncmlkW2ldW3N0YXJ0R3JpZFldLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmaW5pc2hHcmlkWCA8IHRoaXMuZ3JpZC5sZW5ndGggLSAxKSB7XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRHcmlkWTsgaSA8PSBmaW5pc2hHcmlkWTsgaSsrKSB7XG4gICAgICAgIGNvbnRyb2xSZWdpb25zWzFdICs9IHRoaXMuZ3JpZFtmaW5pc2hHcmlkWCArIDFdW2ldLmxlbmd0aCArIHRoaXMuZ3JpZFtmaW5pc2hHcmlkWF1baV0ubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZpbmlzaEdyaWRZIDwgdGhpcy5ncmlkWzBdLmxlbmd0aCAtIDEpIHtcbiAgICAgIGZvciAodmFyIGkgPSBzdGFydEdyaWRYOyBpIDw9IGZpbmlzaEdyaWRYOyBpKyspIHtcbiAgICAgICAgY29udHJvbFJlZ2lvbnNbMl0gKz0gdGhpcy5ncmlkW2ldW2ZpbmlzaEdyaWRZICsgMV0ubGVuZ3RoICsgdGhpcy5ncmlkW2ldW2ZpbmlzaEdyaWRZXS5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhcnRHcmlkWCA+IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSBzdGFydEdyaWRZOyBpIDw9IGZpbmlzaEdyaWRZOyBpKyspIHtcbiAgICAgICAgY29udHJvbFJlZ2lvbnNbM10gKz0gdGhpcy5ncmlkW3N0YXJ0R3JpZFggLSAxXVtpXS5sZW5ndGggKyB0aGlzLmdyaWRbc3RhcnRHcmlkWF1baV0ubGVuZ3RoIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG1pbiA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICAgIHZhciBtaW5Db3VudDtcbiAgICB2YXIgbWluSW5kZXg7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb250cm9sUmVnaW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGNvbnRyb2xSZWdpb25zW2pdIDwgbWluKSB7XG4gICAgICAgIG1pbiA9IGNvbnRyb2xSZWdpb25zW2pdO1xuICAgICAgICBtaW5Db3VudCA9IDE7XG4gICAgICAgIG1pbkluZGV4ID0gajtcbiAgICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbal0gPT0gbWluKSB7XG4gICAgICAgIG1pbkNvdW50Kys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1pbkNvdW50ID09IDMgJiYgbWluID09IDApIHtcbiAgICAgIGlmIChjb250cm9sUmVnaW9uc1swXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzFdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbMl0gPT0gMCkge1xuICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDE7XG4gICAgICB9IGVsc2UgaWYgKGNvbnRyb2xSZWdpb25zWzBdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbMV0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1szXSA9PSAwKSB7XG4gICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoY29udHJvbFJlZ2lvbnNbMF0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1syXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzNdID09IDApIHtcbiAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAzO1xuICAgICAgfSBlbHNlIGlmIChjb250cm9sUmVnaW9uc1sxXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzJdID09IDAgJiYgY29udHJvbFJlZ2lvbnNbM10gPT0gMCkge1xuICAgICAgICBncmlkRm9yUHJ1bmVkTm9kZSA9IDI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtaW5Db3VudCA9PSAyICYmIG1pbiA9PSAwKSB7XG4gICAgICB2YXIgcmFuZG9tID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMik7XG4gICAgICBpZiAoY29udHJvbFJlZ2lvbnNbMF0gPT0gMCAmJiBjb250cm9sUmVnaW9uc1sxXSA9PSAwKSB7XG4gICAgICAgIDtcbiAgICAgICAgaWYgKHJhbmRvbSA9PSAwKSB7XG4gICAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb250cm9sUmVnaW9uc1swXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzJdID09IDApIHtcbiAgICAgICAgaWYgKHJhbmRvbSA9PSAwKSB7XG4gICAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb250cm9sUmVnaW9uc1swXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzNdID09IDApIHtcbiAgICAgICAgaWYgKHJhbmRvbSA9PSAwKSB7XG4gICAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb250cm9sUmVnaW9uc1sxXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzJdID09IDApIHtcbiAgICAgICAgaWYgKHJhbmRvbSA9PSAwKSB7XG4gICAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjb250cm9sUmVnaW9uc1sxXSA9PSAwICYmIGNvbnRyb2xSZWdpb25zWzNdID09IDApIHtcbiAgICAgICAgaWYgKHJhbmRvbSA9PSAwKSB7XG4gICAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJhbmRvbSA9PSAwKSB7XG4gICAgICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gMztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobWluQ291bnQgPT0gNCAmJiBtaW4gPT0gMCkge1xuICAgICAgdmFyIHJhbmRvbSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDQpO1xuICAgICAgZ3JpZEZvclBydW5lZE5vZGUgPSByYW5kb207XG4gICAgfSBlbHNlIHtcbiAgICAgIGdyaWRGb3JQcnVuZWROb2RlID0gbWluSW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKGdyaWRGb3JQcnVuZWROb2RlID09IDApIHtcbiAgICAgIHBydW5lZE5vZGUuc2V0Q2VudGVyKG5vZGVUb0Nvbm5lY3QuZ2V0Q2VudGVyWCgpLCBub2RlVG9Db25uZWN0LmdldENlbnRlclkoKSAtIG5vZGVUb0Nvbm5lY3QuZ2V0SGVpZ2h0KCkgLyAyIC0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCAtIHBydW5lZE5vZGUuZ2V0SGVpZ2h0KCkgLyAyKTtcbiAgICB9IGVsc2UgaWYgKGdyaWRGb3JQcnVuZWROb2RlID09IDEpIHtcbiAgICAgIHBydW5lZE5vZGUuc2V0Q2VudGVyKG5vZGVUb0Nvbm5lY3QuZ2V0Q2VudGVyWCgpICsgbm9kZVRvQ29ubmVjdC5nZXRXaWR0aCgpIC8gMiArIEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggKyBwcnVuZWROb2RlLmdldFdpZHRoKCkgLyAyLCBub2RlVG9Db25uZWN0LmdldENlbnRlclkoKSk7XG4gICAgfSBlbHNlIGlmIChncmlkRm9yUHJ1bmVkTm9kZSA9PSAyKSB7XG4gICAgICBwcnVuZWROb2RlLnNldENlbnRlcihub2RlVG9Db25uZWN0LmdldENlbnRlclgoKSwgbm9kZVRvQ29ubmVjdC5nZXRDZW50ZXJZKCkgKyBub2RlVG9Db25uZWN0LmdldEhlaWdodCgpIC8gMiArIEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggKyBwcnVuZWROb2RlLmdldEhlaWdodCgpIC8gMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBydW5lZE5vZGUuc2V0Q2VudGVyKG5vZGVUb0Nvbm5lY3QuZ2V0Q2VudGVyWCgpIC0gbm9kZVRvQ29ubmVjdC5nZXRXaWR0aCgpIC8gMiAtIEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggLSBwcnVuZWROb2RlLmdldFdpZHRoKCkgLyAyLCBub2RlVG9Db25uZWN0LmdldENlbnRlclkoKSk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvU0VMYXlvdXQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA5OTE6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG52YXIgRkRMYXlvdXROb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLkZETGF5b3V0Tm9kZTtcbnZhciBJTWF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5JTWF0aDtcblxuZnVuY3Rpb24gQ29TRU5vZGUoZ20sIGxvYywgc2l6ZSwgdk5vZGUpIHtcbiAgRkRMYXlvdXROb2RlLmNhbGwodGhpcywgZ20sIGxvYywgc2l6ZSwgdk5vZGUpO1xufVxuXG5Db1NFTm9kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZETGF5b3V0Tm9kZS5wcm90b3R5cGUpO1xuZm9yICh2YXIgcHJvcCBpbiBGRExheW91dE5vZGUpIHtcbiAgQ29TRU5vZGVbcHJvcF0gPSBGRExheW91dE5vZGVbcHJvcF07XG59XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5jYWxjdWxhdGVEaXNwbGFjZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsYXlvdXQgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRMYXlvdXQoKTtcbiAgLy8gdGhpcyBjaGVjayBpcyBmb3IgY29tcG91bmQgbm9kZXMgdGhhdCBjb250YWluIGZpeGVkIG5vZGVzXG4gIGlmICh0aGlzLmdldENoaWxkKCkgIT0gbnVsbCAmJiB0aGlzLmZpeGVkTm9kZVdlaWdodCkge1xuICAgIHRoaXMuZGlzcGxhY2VtZW50WCArPSBsYXlvdXQuY29vbGluZ0ZhY3RvciAqICh0aGlzLnNwcmluZ0ZvcmNlWCArIHRoaXMucmVwdWxzaW9uRm9yY2VYICsgdGhpcy5ncmF2aXRhdGlvbkZvcmNlWCkgLyB0aGlzLmZpeGVkTm9kZVdlaWdodDtcbiAgICB0aGlzLmRpc3BsYWNlbWVudFkgKz0gbGF5b3V0LmNvb2xpbmdGYWN0b3IgKiAodGhpcy5zcHJpbmdGb3JjZVkgKyB0aGlzLnJlcHVsc2lvbkZvcmNlWSArIHRoaXMuZ3Jhdml0YXRpb25Gb3JjZVkpIC8gdGhpcy5maXhlZE5vZGVXZWlnaHQ7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5kaXNwbGFjZW1lbnRYICs9IGxheW91dC5jb29saW5nRmFjdG9yICogKHRoaXMuc3ByaW5nRm9yY2VYICsgdGhpcy5yZXB1bHNpb25Gb3JjZVggKyB0aGlzLmdyYXZpdGF0aW9uRm9yY2VYKSAvIHRoaXMubm9PZkNoaWxkcmVuO1xuICAgIHRoaXMuZGlzcGxhY2VtZW50WSArPSBsYXlvdXQuY29vbGluZ0ZhY3RvciAqICh0aGlzLnNwcmluZ0ZvcmNlWSArIHRoaXMucmVwdWxzaW9uRm9yY2VZICsgdGhpcy5ncmF2aXRhdGlvbkZvcmNlWSkgLyB0aGlzLm5vT2ZDaGlsZHJlbjtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyh0aGlzLmRpc3BsYWNlbWVudFgpID4gbGF5b3V0LmNvb2xpbmdGYWN0b3IgKiBsYXlvdXQubWF4Tm9kZURpc3BsYWNlbWVudCkge1xuICAgIHRoaXMuZGlzcGxhY2VtZW50WCA9IGxheW91dC5jb29saW5nRmFjdG9yICogbGF5b3V0Lm1heE5vZGVEaXNwbGFjZW1lbnQgKiBJTWF0aC5zaWduKHRoaXMuZGlzcGxhY2VtZW50WCk7XG4gIH1cblxuICBpZiAoTWF0aC5hYnModGhpcy5kaXNwbGFjZW1lbnRZKSA+IGxheW91dC5jb29saW5nRmFjdG9yICogbGF5b3V0Lm1heE5vZGVEaXNwbGFjZW1lbnQpIHtcbiAgICB0aGlzLmRpc3BsYWNlbWVudFkgPSBsYXlvdXQuY29vbGluZ0ZhY3RvciAqIGxheW91dC5tYXhOb2RlRGlzcGxhY2VtZW50ICogSU1hdGguc2lnbih0aGlzLmRpc3BsYWNlbWVudFkpO1xuICB9XG5cbiAgLy8gbm9uLWVtcHR5IGNvbXBvdW5kIG5vZGUsIHByb3BvZ2F0ZSBtb3ZlbWVudCB0byBjaGlsZHJlbiBhcyB3ZWxsXG4gIGlmICh0aGlzLmNoaWxkICYmIHRoaXMuY2hpbGQuZ2V0Tm9kZXMoKS5sZW5ndGggPiAwKSB7XG4gICAgdGhpcy5wcm9wb2dhdGVEaXNwbGFjZW1lbnRUb0NoaWxkcmVuKHRoaXMuZGlzcGxhY2VtZW50WCwgdGhpcy5kaXNwbGFjZW1lbnRZKTtcbiAgfVxufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLnByb3BvZ2F0ZURpc3BsYWNlbWVudFRvQ2hpbGRyZW4gPSBmdW5jdGlvbiAoZFgsIGRZKSB7XG4gIHZhciBub2RlcyA9IHRoaXMuZ2V0Q2hpbGQoKS5nZXROb2RlcygpO1xuICB2YXIgbm9kZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICBpZiAobm9kZS5nZXRDaGlsZCgpID09IG51bGwpIHtcbiAgICAgIG5vZGUuZGlzcGxhY2VtZW50WCArPSBkWDtcbiAgICAgIG5vZGUuZGlzcGxhY2VtZW50WSArPSBkWTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5wcm9wb2dhdGVEaXNwbGFjZW1lbnRUb0NoaWxkcmVuKGRYLCBkWSk7XG4gICAgfVxuICB9XG59O1xuXG5Db1NFTm9kZS5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxheW91dCA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldExheW91dCgpO1xuXG4gIC8vIGEgc2ltcGxlIG5vZGUgb3IgYW4gZW1wdHkgY29tcG91bmQgbm9kZSwgbW92ZSBpdFxuICBpZiAodGhpcy5jaGlsZCA9PSBudWxsIHx8IHRoaXMuY2hpbGQuZ2V0Tm9kZXMoKS5sZW5ndGggPT0gMCkge1xuICAgIHRoaXMubW92ZUJ5KHRoaXMuZGlzcGxhY2VtZW50WCwgdGhpcy5kaXNwbGFjZW1lbnRZKTtcblxuICAgIGxheW91dC50b3RhbERpc3BsYWNlbWVudCArPSBNYXRoLmFicyh0aGlzLmRpc3BsYWNlbWVudFgpICsgTWF0aC5hYnModGhpcy5kaXNwbGFjZW1lbnRZKTtcbiAgfVxuXG4gIHRoaXMuc3ByaW5nRm9yY2VYID0gMDtcbiAgdGhpcy5zcHJpbmdGb3JjZVkgPSAwO1xuICB0aGlzLnJlcHVsc2lvbkZvcmNlWCA9IDA7XG4gIHRoaXMucmVwdWxzaW9uRm9yY2VZID0gMDtcbiAgdGhpcy5ncmF2aXRhdGlvbkZvcmNlWCA9IDA7XG4gIHRoaXMuZ3Jhdml0YXRpb25Gb3JjZVkgPSAwO1xuICB0aGlzLmRpc3BsYWNlbWVudFggPSAwO1xuICB0aGlzLmRpc3BsYWNlbWVudFkgPSAwO1xufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLnNldFByZWQxID0gZnVuY3Rpb24gKHByZWQxKSB7XG4gIHRoaXMucHJlZDEgPSBwcmVkMTtcbn07XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5nZXRQcmVkMSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHByZWQxO1xufTtcblxuQ29TRU5vZGUucHJvdG90eXBlLmdldFByZWQyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gcHJlZDI7XG59O1xuXG5Db1NFTm9kZS5wcm90b3R5cGUuc2V0TmV4dCA9IGZ1bmN0aW9uIChuZXh0KSB7XG4gIHRoaXMubmV4dCA9IG5leHQ7XG59O1xuXG5Db1NFTm9kZS5wcm90b3R5cGUuZ2V0TmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5leHQ7XG59O1xuXG5Db1NFTm9kZS5wcm90b3R5cGUuc2V0UHJvY2Vzc2VkID0gZnVuY3Rpb24gKHByb2Nlc3NlZCkge1xuICB0aGlzLnByb2Nlc3NlZCA9IHByb2Nlc3NlZDtcbn07XG5cbkNvU0VOb2RlLnByb3RvdHlwZS5pc1Byb2Nlc3NlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHByb2Nlc3NlZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29TRU5vZGU7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA5MDI6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxudmFyIENvU0VDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwNik7XG52YXIgTGlua2VkTGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5MaW5rZWRMaXN0O1xudmFyIE1hdHJpeCA9IF9fd2VicGFja19yZXF1aXJlX18oNTUxKS5NYXRyaXg7XG52YXIgU1ZEID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NTEpLlNWRDtcblxuZnVuY3Rpb24gQ29uc3RyYWludEhhbmRsZXIoKSB7fVxuXG5Db25zdHJhaW50SGFuZGxlci5oYW5kbGVDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChsYXlvdXQpIHtcbiAgLy8gIGxldCBsYXlvdXQgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRMYXlvdXQoKTtcblxuICAvLyBnZXQgY29uc3RyYWludHMgZnJvbSBsYXlvdXRcbiAgdmFyIGNvbnN0cmFpbnRzID0ge307XG4gIGNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQgPSBsYXlvdXQuY29uc3RyYWludHMuZml4ZWROb2RlQ29uc3RyYWludDtcbiAgY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludCA9IGxheW91dC5jb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50O1xuICBjb25zdHJhaW50cy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQgPSBsYXlvdXQuY29uc3RyYWludHMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50O1xuXG4gIHZhciBpZFRvTm9kZU1hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIG5vZGVJbmRleGVzID0gbmV3IE1hcCgpO1xuICB2YXIgeENvb3JkcyA9IFtdO1xuICB2YXIgeUNvb3JkcyA9IFtdO1xuXG4gIHZhciBhbGxOb2RlcyA9IGxheW91dC5nZXRBbGxOb2RlcygpO1xuICB2YXIgaW5kZXggPSAwO1xuICAvLyBmaWxsIGluZGV4IG1hcCBhbmQgY29vcmRpbmF0ZXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gYWxsTm9kZXNbaV07XG4gICAgaWYgKG5vZGUuZ2V0Q2hpbGQoKSA9PSBudWxsKSB7XG4gICAgICBub2RlSW5kZXhlcy5zZXQobm9kZS5pZCwgaW5kZXgrKyk7XG4gICAgICB4Q29vcmRzLnB1c2gobm9kZS5nZXRDZW50ZXJYKCkpO1xuICAgICAgeUNvb3Jkcy5wdXNoKG5vZGUuZ2V0Q2VudGVyWSgpKTtcbiAgICAgIGlkVG9Ob2RlTWFwLnNldChub2RlLmlkLCBub2RlKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGVyZSBleGlzdHMgcmVsYXRpdmUgcGxhY2VtZW50IGNvbnN0cmFpbnQgd2l0aG91dCBnYXAgdmFsdWUsIHNldCBpdCB0byBkZWZhdWx0IFxuICBpZiAoY29uc3RyYWludHMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50KSB7XG4gICAgY29uc3RyYWludHMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50LmZvckVhY2goZnVuY3Rpb24gKGNvbnN0cmFpbnQpIHtcbiAgICAgIGlmICghY29uc3RyYWludC5nYXAgJiYgY29uc3RyYWludC5nYXAgIT0gMCkge1xuICAgICAgICBpZiAoY29uc3RyYWludC5sZWZ0KSB7XG4gICAgICAgICAgY29uc3RyYWludC5nYXAgPSBDb1NFQ29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggKyBpZFRvTm9kZU1hcC5nZXQoY29uc3RyYWludC5sZWZ0KS5nZXRXaWR0aCgpIC8gMiArIGlkVG9Ob2RlTWFwLmdldChjb25zdHJhaW50LnJpZ2h0KS5nZXRXaWR0aCgpIC8gMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdHJhaW50LmdhcCA9IENvU0VDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSCArIGlkVG9Ob2RlTWFwLmdldChjb25zdHJhaW50LnRvcCkuZ2V0SGVpZ2h0KCkgLyAyICsgaWRUb05vZGVNYXAuZ2V0KGNvbnN0cmFpbnQuYm90dG9tKS5nZXRIZWlnaHQoKSAvIDI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qIGF1eGlsaWFyeSBmdW5jdGlvbnMgKi9cblxuICAvLyBjYWxjdWxhdGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBwb3NpdGlvbiBvYmplY3RzXG4gIHZhciBjYWxjdWxhdGVQb3NpdGlvbkRpZmYgPSBmdW5jdGlvbiBjYWxjdWxhdGVQb3NpdGlvbkRpZmYocG9zMSwgcG9zMikge1xuICAgIHJldHVybiB7IHg6IHBvczEueCAtIHBvczIueCwgeTogcG9zMS55IC0gcG9zMi55IH07XG4gIH07XG5cbiAgLy8gY2FsY3VsYXRlIGF2ZXJhZ2UgcG9zaXRpb24gb2YgdGhlIG5vZGVzXG4gIHZhciBjYWxjdWxhdGVBdmdQb3NpdGlvbiA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUF2Z1Bvc2l0aW9uKG5vZGVJZFNldCkge1xuICAgIHZhciB4UG9zU3VtID0gMDtcbiAgICB2YXIgeVBvc1N1bSA9IDA7XG4gICAgbm9kZUlkU2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgeFBvc1N1bSArPSB4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXTtcbiAgICAgIHlQb3NTdW0gKz0geUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV07XG4gICAgfSk7XG5cbiAgICByZXR1cm4geyB4OiB4UG9zU3VtIC8gbm9kZUlkU2V0LnNpemUsIHk6IHlQb3NTdW0gLyBub2RlSWRTZXQuc2l6ZSB9O1xuICB9O1xuXG4gIC8vIGZpbmQgYW4gYXBwcm9wcmlhdGUgcG9zaXRpb25pbmcgZm9yIHRoZSBub2RlcyBpbiBhIGdpdmVuIGdyYXBoIGFjY29yZGluZyB0byByZWxhdGl2ZSBwbGFjZW1lbnQgY29uc3RyYWludHNcbiAgLy8gdGhpcyBmdW5jdGlvbiBhbHNvIHRha2VzIHRoZSBmaXhlZCBub2RlcyBhbmQgYWxpZ25tZW50IGNvbnN0cmFpbnRzIGludG8gYWNjb3VudFxuICAvLyBncmFwaDogZGFnIHRvIGJlIGV2YWx1YXRlZCwgZGlyZWN0aW9uOiBcImhvcml6b250YWxcIiBvciBcInZlcnRpY2FsXCIsIFxuICAvLyBmaXhlZE5vZGVzOiBzZXQgb2YgZml4ZWQgbm9kZXMgdG8gY29uc2lkZXIgZHVyaW5nIGV2YWx1YXRpb24sIGR1bW15UG9zaXRpb25zOiBhcHByb3ByaWF0ZSBjb29yZGluYXRlcyBvZiB0aGUgZHVtbXkgbm9kZXMgIFxuICB2YXIgZmluZEFwcHJvcHJpYXRlUG9zaXRpb25Gb3JSZWxhdGl2ZVBsYWNlbWVudCA9IGZ1bmN0aW9uIGZpbmRBcHByb3ByaWF0ZVBvc2l0aW9uRm9yUmVsYXRpdmVQbGFjZW1lbnQoZ3JhcGgsIGRpcmVjdGlvbiwgZml4ZWROb2RlcywgZHVtbXlQb3NpdGlvbnMsIGNvbXBvbmVudFNvdXJjZXMpIHtcblxuICAgIC8vIGZpbmQgdW5pb24gb2YgdHdvIHNldHNcbiAgICBmdW5jdGlvbiBzZXRVbmlvbihzZXRBLCBzZXRCKSB7XG4gICAgICB2YXIgdW5pb24gPSBuZXcgU2V0KHNldEEpO1xuICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IHNldEJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgICAgdmFyIGVsZW0gPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIHVuaW9uLmFkZChlbGVtKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmlvbjtcbiAgICB9XG5cbiAgICAvLyBmaW5kIGluZGVncmVlIGNvdW50IGZvciBlYWNoIG5vZGVcbiAgICB2YXIgaW5EZWdyZWVzID0gbmV3IE1hcCgpO1xuXG4gICAgZ3JhcGguZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgaW5EZWdyZWVzLnNldChrZXksIDApO1xuICAgIH0pO1xuICAgIGdyYXBoLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKGFkamFjZW50KSB7XG4gICAgICAgIGluRGVncmVlcy5zZXQoYWRqYWNlbnQuaWQsIGluRGVncmVlcy5nZXQoYWRqYWNlbnQuaWQpICsgMSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHZhciBwb3NpdGlvbk1hcCA9IG5ldyBNYXAoKTsgLy8ga2VlcHMgdGhlIHBvc2l0aW9uIGZvciBlYWNoIG5vZGVcbiAgICB2YXIgcGFzdE1hcCA9IG5ldyBNYXAoKTsgLy8ga2VlcHMgdGhlIHByZWRlY2Vzc29ycyhwYXN0KSBvZiBhIG5vZGVcbiAgICB2YXIgcXVldWUgPSBuZXcgTGlua2VkTGlzdCgpO1xuICAgIGluRGVncmVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAodmFsdWUgPT0gMCkge1xuICAgICAgICBxdWV1ZS5wdXNoKGtleSk7XG4gICAgICAgIGlmICghZml4ZWROb2Rlcykge1xuICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uTWFwLnNldChrZXksIG5vZGVJbmRleGVzLmhhcyhrZXkpID8geENvb3Jkc1tub2RlSW5kZXhlcy5nZXQoa2V5KV0gOiBkdW1teVBvc2l0aW9ucy5nZXQoa2V5KSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvc2l0aW9uTWFwLnNldChrZXksIG5vZGVJbmRleGVzLmhhcyhrZXkpID8geUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQoa2V5KV0gOiBkdW1teVBvc2l0aW9ucy5nZXQoa2V5KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3NpdGlvbk1hcC5zZXQoa2V5LCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuICAgICAgfVxuICAgICAgaWYgKGZpeGVkTm9kZXMpIHtcbiAgICAgICAgcGFzdE1hcC5zZXQoa2V5LCBuZXcgU2V0KFtrZXldKSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBhbGlnbiBzb3VyY2VzIG9mIGVhY2ggY29tcG9uZW50IGluIGVuZm9yY2VtZW50IHBoYXNlXG4gICAgaWYgKGZpeGVkTm9kZXMpIHtcbiAgICAgIGNvbXBvbmVudFNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgIHZhciBmaXhlZElkcyA9IFtdO1xuICAgICAgICBjb21wb25lbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgaWYgKGZpeGVkTm9kZXMuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICAgIGZpeGVkSWRzLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZml4ZWRJZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBwb3NpdGlvbiA9IDA7XG4gICAgICAgICAgZml4ZWRJZHMuZm9yRWFjaChmdW5jdGlvbiAoZml4ZWRJZCkge1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PSBcImhvcml6b250YWxcIikge1xuICAgICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQoZml4ZWRJZCwgbm9kZUluZGV4ZXMuaGFzKGZpeGVkSWQpID8geENvb3Jkc1tub2RlSW5kZXhlcy5nZXQoZml4ZWRJZCldIDogZHVtbXlQb3NpdGlvbnMuZ2V0KGZpeGVkSWQpKTtcbiAgICAgICAgICAgICAgcG9zaXRpb24gKz0gcG9zaXRpb25NYXAuZ2V0KGZpeGVkSWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcG9zaXRpb25NYXAuc2V0KGZpeGVkSWQsIG5vZGVJbmRleGVzLmhhcyhmaXhlZElkKSA/IHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KGZpeGVkSWQpXSA6IGR1bW15UG9zaXRpb25zLmdldChmaXhlZElkKSk7XG4gICAgICAgICAgICAgIHBvc2l0aW9uICs9IHBvc2l0aW9uTWFwLmdldChmaXhlZElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uIC8gZml4ZWRJZHMubGVuZ3RoO1xuICAgICAgICAgIGNvbXBvbmVudC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIGlmICghZml4ZWROb2Rlcy5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQobm9kZUlkLCBwb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9wb3NpdGlvbiA9IDA7XG4gICAgICAgICAgY29tcG9uZW50LmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PSBcImhvcml6b250YWxcIikge1xuICAgICAgICAgICAgICBfcG9zaXRpb24gKz0gbm9kZUluZGV4ZXMuaGFzKG5vZGVJZCkgPyB4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXSA6IGR1bW15UG9zaXRpb25zLmdldChub2RlSWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3Bvc2l0aW9uICs9IG5vZGVJbmRleGVzLmhhcyhub2RlSWQpID8geUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV0gOiBkdW1teVBvc2l0aW9ucy5nZXQobm9kZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBfcG9zaXRpb24gPSBfcG9zaXRpb24gLyBjb21wb25lbnQubGVuZ3RoO1xuICAgICAgICAgIGNvbXBvbmVudC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uTWFwLnNldChub2RlSWQsIF9wb3NpdGlvbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSBwb3NpdGlvbnMgb2YgdGhlIG5vZGVzXG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgIHZhciBjdXJyZW50Tm9kZSA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICB2YXIgbmVpZ2hib3JzID0gZ3JhcGguZ2V0KGN1cnJlbnROb2RlKTtcbiAgICAgIG5laWdoYm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChuZWlnaGJvcikge1xuICAgICAgICBpZiAocG9zaXRpb25NYXAuZ2V0KG5laWdoYm9yLmlkKSA8IHBvc2l0aW9uTWFwLmdldChjdXJyZW50Tm9kZSkgKyBuZWlnaGJvci5nYXApIHtcbiAgICAgICAgICBpZiAoZml4ZWROb2RlcyAmJiBmaXhlZE5vZGVzLmhhcyhuZWlnaGJvci5pZCkpIHtcbiAgICAgICAgICAgIHZhciBmaXhlZFBvc2l0aW9uID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PSBcImhvcml6b250YWxcIikge1xuICAgICAgICAgICAgICBmaXhlZFBvc2l0aW9uID0gbm9kZUluZGV4ZXMuaGFzKG5laWdoYm9yLmlkKSA/IHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5laWdoYm9yLmlkKV0gOiBkdW1teVBvc2l0aW9ucy5nZXQobmVpZ2hib3IuaWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZml4ZWRQb3NpdGlvbiA9IG5vZGVJbmRleGVzLmhhcyhuZWlnaGJvci5pZCkgPyB5Q29vcmRzW25vZGVJbmRleGVzLmdldChuZWlnaGJvci5pZCldIDogZHVtbXlQb3NpdGlvbnMuZ2V0KG5laWdoYm9yLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvc2l0aW9uTWFwLnNldChuZWlnaGJvci5pZCwgZml4ZWRQb3NpdGlvbik7IC8vIFRPRE86IG1heSBkbyB1bm5lY2Vzc2FyeSB3b3JrXG4gICAgICAgICAgICBpZiAoZml4ZWRQb3NpdGlvbiA8IHBvc2l0aW9uTWFwLmdldChjdXJyZW50Tm9kZSkgKyBuZWlnaGJvci5nYXApIHtcbiAgICAgICAgICAgICAgdmFyIGRpZmYgPSBwb3NpdGlvbk1hcC5nZXQoY3VycmVudE5vZGUpICsgbmVpZ2hib3IuZ2FwIC0gZml4ZWRQb3NpdGlvbjtcbiAgICAgICAgICAgICAgcGFzdE1hcC5nZXQoY3VycmVudE5vZGUpLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uTWFwLnNldChub2RlSWQsIHBvc2l0aW9uTWFwLmdldChub2RlSWQpIC0gZGlmZik7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3NpdGlvbk1hcC5zZXQobmVpZ2hib3IuaWQsIHBvc2l0aW9uTWFwLmdldChjdXJyZW50Tm9kZSkgKyBuZWlnaGJvci5nYXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbkRlZ3JlZXMuc2V0KG5laWdoYm9yLmlkLCBpbkRlZ3JlZXMuZ2V0KG5laWdoYm9yLmlkKSAtIDEpO1xuICAgICAgICBpZiAoaW5EZWdyZWVzLmdldChuZWlnaGJvci5pZCkgPT0gMCkge1xuICAgICAgICAgIHF1ZXVlLnB1c2gobmVpZ2hib3IuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXhlZE5vZGVzKSB7XG4gICAgICAgICAgcGFzdE1hcC5zZXQobmVpZ2hib3IuaWQsIHNldFVuaW9uKHBhc3RNYXAuZ2V0KGN1cnJlbnROb2RlKSwgcGFzdE1hcC5nZXQobmVpZ2hib3IuaWQpKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB3aGlsZSAocXVldWUubGVuZ3RoICE9IDApIHtcbiAgICAgIF9sb29wKCk7XG4gICAgfVxuXG4gICAgLy8gcmVhZGp1c3QgcG9zaXRpb24gb2YgdGhlIG5vZGVzIGFmdGVyIGVuZm9yY2VtZW50XG4gICAgaWYgKGZpeGVkTm9kZXMpIHtcbiAgICAgIC8vIGZpbmQgaW5kZWdyZWUgY291bnQgZm9yIGVhY2ggbm9kZVxuICAgICAgdmFyIHNpbmtOb2RlcyA9IG5ldyBTZXQoKTtcblxuICAgICAgZ3JhcGguZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09IDApIHtcbiAgICAgICAgICBzaW5rTm9kZXMuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgX2NvbXBvbmVudHMgPSBbXTtcbiAgICAgIHBhc3RNYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICBpZiAoc2lua05vZGVzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgdmFyIGlzRml4ZWRDb21wb25lbnQgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgPSB0cnVlO1xuICAgICAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvcjIgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IyID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSB2YWx1ZVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuICAgICAgICAgICAgICB2YXIgbm9kZUlkID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgICAgICAgIGlmIChmaXhlZE5vZGVzLmhhcyhub2RlSWQpKSB7XG4gICAgICAgICAgICAgICAgaXNGaXhlZENvbXBvbmVudCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IyLnJldHVybigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpc0ZpeGVkQ29tcG9uZW50KSB7XG4gICAgICAgICAgICB2YXIgaXNFeGlzdCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGV4aXN0QXQgPSB2b2lkIDA7XG4gICAgICAgICAgICBfY29tcG9uZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wb25lbnQsIGluZGV4KSB7XG4gICAgICAgICAgICAgIGlmIChjb21wb25lbnQuaGFzKFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodmFsdWUpKVswXSkpIHtcbiAgICAgICAgICAgICAgICBpc0V4aXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBleGlzdEF0ID0gaW5kZXg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFpc0V4aXN0KSB7XG4gICAgICAgICAgICAgIF9jb21wb25lbnRzLnB1c2gobmV3IFNldCh2YWx1ZSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAoZWxlKSB7XG4gICAgICAgICAgICAgICAgX2NvbXBvbmVudHNbZXhpc3RBdF0uYWRkKGVsZSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIF9jb21wb25lbnRzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIG1pbkJlZm9yZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgdmFyIG1pbkFmdGVyID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICB2YXIgbWF4QmVmb3JlID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgICB2YXIgbWF4QWZ0ZXIgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yMyA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3IzID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yMyA9IGNvbXBvbmVudFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMzsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyA9IChfc3RlcDMgPSBfaXRlcmF0b3IzLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24zID0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIG5vZGVJZCA9IF9zdGVwMy52YWx1ZTtcblxuICAgICAgICAgICAgdmFyIHBvc0JlZm9yZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICAgICAgcG9zQmVmb3JlID0gbm9kZUluZGV4ZXMuaGFzKG5vZGVJZCkgPyB4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXSA6IGR1bW15UG9zaXRpb25zLmdldChub2RlSWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcG9zQmVmb3JlID0gbm9kZUluZGV4ZXMuaGFzKG5vZGVJZCkgPyB5Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXSA6IGR1bW15UG9zaXRpb25zLmdldChub2RlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBvc0FmdGVyID0gcG9zaXRpb25NYXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICBpZiAocG9zQmVmb3JlIDwgbWluQmVmb3JlKSB7XG4gICAgICAgICAgICAgIG1pbkJlZm9yZSA9IHBvc0JlZm9yZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3NCZWZvcmUgPiBtYXhCZWZvcmUpIHtcbiAgICAgICAgICAgICAgbWF4QmVmb3JlID0gcG9zQmVmb3JlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvc0FmdGVyIDwgbWluQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgbWluQWZ0ZXIgPSBwb3NBZnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3NBZnRlciA+IG1heEFmdGVyKSB7XG4gICAgICAgICAgICAgIG1heEFmdGVyID0gcG9zQWZ0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjMgPSB0cnVlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yMyA9IGVycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMyAmJiBfaXRlcmF0b3IzLnJldHVybikge1xuICAgICAgICAgICAgICBfaXRlcmF0b3IzLnJldHVybigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IzKSB7XG4gICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlmZiA9IChtaW5CZWZvcmUgKyBtYXhCZWZvcmUpIC8gMiAtIChtaW5BZnRlciArIG1heEFmdGVyKSAvIDI7XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNCA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I0ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNCA9IGNvbXBvbmVudFtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwNDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNCA9IChfc3RlcDQgPSBfaXRlcmF0b3I0Lm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ID0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIF9ub2RlSWQgPSBfc3RlcDQudmFsdWU7XG5cbiAgICAgICAgICAgIHBvc2l0aW9uTWFwLnNldChfbm9kZUlkLCBwb3NpdGlvbk1hcC5nZXQoX25vZGVJZCkgKyBkaWZmKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yNCA9IHRydWU7XG4gICAgICAgICAgX2l0ZXJhdG9yRXJyb3I0ID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb240ICYmIF9pdGVyYXRvcjQucmV0dXJuKSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjQucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvc2l0aW9uTWFwO1xuICB9O1xuXG4gIC8vIGZpbmQgdHJhbnNmb3JtYXRpb24gYmFzZWQgb24gcmVsLiBwbGFjZW1lbnQgY29uc3RyYWludHMgaWYgdGhlcmUgYXJlIGJvdGggYWxpZ25tZW50IGFuZCByZWwuIHBsYWNlbWVudCBjb25zdHJhaW50c1xuICAvLyBvciBpZiB0aGVyZSBhcmUgb25seSByZWwuIHBsYWNlbWVudCBjb250cmFpbnRzIHdoZXJlIHRoZSBsYXJnZXN0IGNvbXBvbmVudCBpc24ndCBzdWZmaWNpZW50bHkgbGFyZ2VcbiAgdmFyIGFwcGx5UmVmbGVjdGlvbkZvclJlbGF0aXZlUGxhY2VtZW50ID0gZnVuY3Rpb24gYXBwbHlSZWZsZWN0aW9uRm9yUmVsYXRpdmVQbGFjZW1lbnQocmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50cykge1xuICAgIC8vIHZhcmlhYmxlcyB0byBjb3VudCB2b3Rlc1xuICAgIHZhciByZWZsZWN0T25ZID0gMCxcbiAgICAgICAgbm90UmVmbGVjdE9uWSA9IDA7XG4gICAgdmFyIHJlZmxlY3RPblggPSAwLFxuICAgICAgICBub3RSZWZsZWN0T25YID0gMDtcblxuICAgIHJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludHMuZm9yRWFjaChmdW5jdGlvbiAoY29uc3RyYWludCkge1xuICAgICAgaWYgKGNvbnN0cmFpbnQubGVmdCkge1xuICAgICAgICB4Q29vcmRzW25vZGVJbmRleGVzLmdldChjb25zdHJhaW50LmxlZnQpXSAtIHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KGNvbnN0cmFpbnQucmlnaHQpXSA+PSAwID8gcmVmbGVjdE9uWSsrIDogbm90UmVmbGVjdE9uWSsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQoY29uc3RyYWludC50b3ApXSAtIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KGNvbnN0cmFpbnQuYm90dG9tKV0gPj0gMCA/IHJlZmxlY3RPblgrKyA6IG5vdFJlZmxlY3RPblgrKztcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChyZWZsZWN0T25ZID4gbm90UmVmbGVjdE9uWSAmJiByZWZsZWN0T25YID4gbm90UmVmbGVjdE9uWCkge1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5vZGVJbmRleGVzLnNpemU7IF9pKyspIHtcbiAgICAgICAgeENvb3Jkc1tfaV0gPSAtMSAqIHhDb29yZHNbX2ldO1xuICAgICAgICB5Q29vcmRzW19pXSA9IC0xICogeUNvb3Jkc1tfaV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWZsZWN0T25ZID4gbm90UmVmbGVjdE9uWSkge1xuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbm9kZUluZGV4ZXMuc2l6ZTsgX2kyKyspIHtcbiAgICAgICAgeENvb3Jkc1tfaTJdID0gLTEgKiB4Q29vcmRzW19pMl07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWZsZWN0T25YID4gbm90UmVmbGVjdE9uWCkge1xuICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbm9kZUluZGV4ZXMuc2l6ZTsgX2kzKyspIHtcbiAgICAgICAgeUNvb3Jkc1tfaTNdID0gLTEgKiB5Q29vcmRzW19pM107XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIGZpbmQgd2Vha2x5IGNvbm5lY3RlZCBjb21wb25lbnRzIGluIHVuZGlyZWN0ZWQgZ3JhcGhcbiAgdmFyIGZpbmRDb21wb25lbnRzID0gZnVuY3Rpb24gZmluZENvbXBvbmVudHMoZ3JhcGgpIHtcbiAgICAvLyBmaW5kIHdlYWtseSBjb25uZWN0ZWQgY29tcG9uZW50cyBpbiBkYWdcbiAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICAgIHZhciBxdWV1ZSA9IG5ldyBMaW5rZWRMaXN0KCk7XG4gICAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGNvdW50ID0gMDtcblxuICAgIGdyYXBoLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmICghdmlzaXRlZC5oYXMoa2V5KSkge1xuICAgICAgICBjb21wb25lbnRzW2NvdW50XSA9IFtdO1xuICAgICAgICB2YXIgX2N1cnJlbnROb2RlID0ga2V5O1xuICAgICAgICBxdWV1ZS5wdXNoKF9jdXJyZW50Tm9kZSk7XG4gICAgICAgIHZpc2l0ZWQuYWRkKF9jdXJyZW50Tm9kZSk7XG4gICAgICAgIGNvbXBvbmVudHNbY291bnRdLnB1c2goX2N1cnJlbnROb2RlKTtcblxuICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoICE9IDApIHtcbiAgICAgICAgICBfY3VycmVudE5vZGUgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgIHZhciBuZWlnaGJvcnMgPSBncmFwaC5nZXQoX2N1cnJlbnROb2RlKTtcbiAgICAgICAgICBuZWlnaGJvcnMuZm9yRWFjaChmdW5jdGlvbiAobmVpZ2hib3IpIHtcbiAgICAgICAgICAgIGlmICghdmlzaXRlZC5oYXMobmVpZ2hib3IuaWQpKSB7XG4gICAgICAgICAgICAgIHF1ZXVlLnB1c2gobmVpZ2hib3IuaWQpO1xuICAgICAgICAgICAgICB2aXNpdGVkLmFkZChuZWlnaGJvci5pZCk7XG4gICAgICAgICAgICAgIGNvbXBvbmVudHNbY291bnRdLnB1c2gobmVpZ2hib3IuaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbXBvbmVudHM7XG4gIH07XG5cbiAgLy8gcmV0dXJuIHVuZGlyZWN0ZWQgdmVyc2lvbiBvZiBnaXZlbiBkYWdcbiAgdmFyIGRhZ1RvVW5kaXJlY3RlZCA9IGZ1bmN0aW9uIGRhZ1RvVW5kaXJlY3RlZChkYWcpIHtcbiAgICB2YXIgdW5kaXJlY3RlZCA9IG5ldyBNYXAoKTtcblxuICAgIGRhZy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICB1bmRpcmVjdGVkLnNldChrZXksIFtdKTtcbiAgICB9KTtcblxuICAgIGRhZy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChhZGphY2VudCkge1xuICAgICAgICB1bmRpcmVjdGVkLmdldChrZXkpLnB1c2goYWRqYWNlbnQpO1xuICAgICAgICB1bmRpcmVjdGVkLmdldChhZGphY2VudC5pZCkucHVzaCh7IGlkOiBrZXksIGdhcDogYWRqYWNlbnQuZ2FwLCBkaXJlY3Rpb246IGFkamFjZW50LmRpcmVjdGlvbiB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHVuZGlyZWN0ZWQ7XG4gIH07XG5cbiAgLy8gcmV0dXJuIHJldmVyc2VkIChkaXJlY3Rpb25zIGludmVydGVkKSB2ZXJzaW9uIG9mIGdpdmVuIGRhZ1xuICB2YXIgZGFnVG9SZXZlcnNlZCA9IGZ1bmN0aW9uIGRhZ1RvUmV2ZXJzZWQoZGFnKSB7XG4gICAgdmFyIHJldmVyc2VkID0gbmV3IE1hcCgpO1xuXG4gICAgZGFnLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIHJldmVyc2VkLnNldChrZXksIFtdKTtcbiAgICB9KTtcblxuICAgIGRhZy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChhZGphY2VudCkge1xuICAgICAgICByZXZlcnNlZC5nZXQoYWRqYWNlbnQuaWQpLnB1c2goeyBpZDoga2V5LCBnYXA6IGFkamFjZW50LmdhcCwgZGlyZWN0aW9uOiBhZGphY2VudC5kaXJlY3Rpb24gfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXZlcnNlZDtcbiAgfTtcblxuICAvKioqKiAgYXBwbHkgdHJhbnNmb3JtYXRpb24gdG8gdGhlIGluaXRpYWwgZHJhZnQgbGF5b3V0IHRvIGJldHRlciBhbGlnbiB3aXRoIGNvbnN0cmFpbmVkIG5vZGVzICoqKiovXG4gIC8vIHNvbHZlIHRoZSBPcnRob2dvbmFsIFByb2NydXN0ZWFuIFByb2JsZW0gdG8gcm90YXRlIGFuZC9vciByZWZsZWN0IGluaXRpYWwgZHJhZnQgbGF5b3V0XG4gIC8vIGhlcmUgd2UgZm9sbG93IHRoZSBzb2x1dGlvbiBpbiBDaGFwdGVyIDIwLjIgb2YgQm9yZywgSS4gJiBHcm9lbmVuLCBQLiAoMjAwNSkgTW9kZXJuIE11bHRpZGltZW5zaW9uYWwgU2NhbGluZzogVGhlb3J5IGFuZCBBcHBsaWNhdGlvbnMgXG5cbiAgLyogY29uc3RydWN0IHNvdXJjZSBhbmQgdGFyZ2V0IGNvbmZpZ3VyYXRpb25zICovXG5cbiAgdmFyIHRhcmdldE1hdHJpeCA9IFtdOyAvLyBBIC0gdGFyZ2V0IGNvbmZpZ3VyYXRpb25cbiAgdmFyIHNvdXJjZU1hdHJpeCA9IFtdOyAvLyBCIC0gc291cmNlIGNvbmZpZ3VyYXRpb24gXG4gIHZhciBzdGFuZGFyZFRyYW5zZm9ybWF0aW9uID0gZmFsc2U7IC8vIGZhbHNlIGZvciBubyB0cmFuc2Zvcm1hdGlvbiwgdHJ1ZSBmb3Igc3RhbmRhcnQgKFByb2NydXN0ZXMpIHRyYW5zZm9ybWF0aW9uIChyb3RhdGlvbiBhbmQvb3IgcmVmbGVjdGlvbilcbiAgdmFyIHJlZmxlY3Rpb25UeXBlID0gZmFsc2U7IC8vIGZhbHNlL3RydWUgZm9yIHJlZmxlY3Rpb24gY2hlY2ssICdyZWZsZWN0T25YJywgJ3JlZmxlY3RPblknIG9yICdyZWZsZWN0T25Cb3RoJyBmb3IgcmVmbGVjdGlvbiB0eXBlIGlmIG5lY2Vzc2FyeVxuICB2YXIgZml4ZWROb2RlcyA9IG5ldyBTZXQoKTtcbiAgdmFyIGRhZyA9IG5ldyBNYXAoKTsgLy8gYWRqYWNlbmN5IGxpc3QgdG8ga2VlcCBkaXJlY3RlZCBhY3ljbGljIGdyYXBoIChkYWcpIHRoYXQgY29uc2lzdHMgb2YgcmVsYXRpdmUgcGxhY2VtZW50IGNvbnN0cmFpbnRzXG4gIHZhciBkYWdVbmRpcmVjdGVkID0gbmV3IE1hcCgpOyAvLyB1bmRpcmVjdGVkIHZlcnNpb24gb2YgdGhlIGRhZ1xuICB2YXIgY29tcG9uZW50cyA9IFtdOyAvLyB3ZWFrbHkgY29ubmVjdGVkIGNvbXBvbmVudHNcblxuICAvLyBmaWxsIGZpeGVkTm9kZXMgY29sbGVjdGlvbiB0byB1c2UgbGF0ZXJcbiAgaWYgKGNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQpIHtcbiAgICBjb25zdHJhaW50cy5maXhlZE5vZGVDb25zdHJhaW50LmZvckVhY2goZnVuY3Rpb24gKG5vZGVEYXRhKSB7XG4gICAgICBmaXhlZE5vZGVzLmFkZChub2RlRGF0YS5ub2RlSWQpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gY29uc3RydWN0IGRhZyBmcm9tIHJlbGF0aXZlIHBsYWNlbWVudCBjb25zdHJhaW50cyBcbiAgaWYgKGNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCkge1xuICAgIC8vIGNvbnN0cnVjdCBib3RoIGRpcmVjdGVkIGFuZCB1bmRpcmVjdGVkIHZlcnNpb24gb2YgdGhlIGRhZ1xuICAgIGNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludC5mb3JFYWNoKGZ1bmN0aW9uIChjb25zdHJhaW50KSB7XG4gICAgICBpZiAoY29uc3RyYWludC5sZWZ0KSB7XG4gICAgICAgIGlmIChkYWcuaGFzKGNvbnN0cmFpbnQubGVmdCkpIHtcbiAgICAgICAgICBkYWcuZ2V0KGNvbnN0cmFpbnQubGVmdCkucHVzaCh7IGlkOiBjb25zdHJhaW50LnJpZ2h0LCBnYXA6IGNvbnN0cmFpbnQuZ2FwLCBkaXJlY3Rpb246IFwiaG9yaXpvbnRhbFwiIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhZy5zZXQoY29uc3RyYWludC5sZWZ0LCBbeyBpZDogY29uc3RyYWludC5yaWdodCwgZ2FwOiBjb25zdHJhaW50LmdhcCwgZGlyZWN0aW9uOiBcImhvcml6b250YWxcIiB9XSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYWcuaGFzKGNvbnN0cmFpbnQucmlnaHQpKSB7XG4gICAgICAgICAgZGFnLnNldChjb25zdHJhaW50LnJpZ2h0LCBbXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChkYWcuaGFzKGNvbnN0cmFpbnQudG9wKSkge1xuICAgICAgICAgIGRhZy5nZXQoY29uc3RyYWludC50b3ApLnB1c2goeyBpZDogY29uc3RyYWludC5ib3R0b20sIGdhcDogY29uc3RyYWludC5nYXAsIGRpcmVjdGlvbjogXCJ2ZXJ0aWNhbFwiIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhZy5zZXQoY29uc3RyYWludC50b3AsIFt7IGlkOiBjb25zdHJhaW50LmJvdHRvbSwgZ2FwOiBjb25zdHJhaW50LmdhcCwgZGlyZWN0aW9uOiBcInZlcnRpY2FsXCIgfV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGFnLmhhcyhjb25zdHJhaW50LmJvdHRvbSkpIHtcbiAgICAgICAgICBkYWcuc2V0KGNvbnN0cmFpbnQuYm90dG9tLCBbXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRhZ1VuZGlyZWN0ZWQgPSBkYWdUb1VuZGlyZWN0ZWQoZGFnKTtcbiAgICBjb21wb25lbnRzID0gZmluZENvbXBvbmVudHMoZGFnVW5kaXJlY3RlZCk7XG4gIH1cblxuICBpZiAoQ29TRUNvbnN0YW50cy5UUkFOU0ZPUk1fT05fQ09OU1RSQUlOVF9IQU5ETElORykge1xuICAgIC8vIGZpcnN0IGNoZWNrIGZpeGVkIG5vZGUgY29uc3RyYWludFxuICAgIGlmIChjb25zdHJhaW50cy5maXhlZE5vZGVDb25zdHJhaW50ICYmIGNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3RyYWludHMuZml4ZWROb2RlQ29uc3RyYWludC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlRGF0YSwgaSkge1xuICAgICAgICB0YXJnZXRNYXRyaXhbaV0gPSBbbm9kZURhdGEucG9zaXRpb24ueCwgbm9kZURhdGEucG9zaXRpb24ueV07XG4gICAgICAgIHNvdXJjZU1hdHJpeFtpXSA9IFt4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlRGF0YS5ub2RlSWQpXSwgeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZURhdGEubm9kZUlkKV1dO1xuICAgICAgfSk7XG4gICAgICBzdGFuZGFyZFRyYW5zZm9ybWF0aW9uID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQpIHtcbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHRoZW4gY2hlY2sgYWxpZ25tZW50IGNvbnN0cmFpbnRcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgaWYgKGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWwpIHtcbiAgICAgICAgICB2YXIgdmVydGljYWxBbGlnbiA9IGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWw7XG5cbiAgICAgICAgICB2YXIgX2xvb3AyID0gZnVuY3Rpb24gX2xvb3AyKF9pNCkge1xuICAgICAgICAgICAgdmFyIGFsaWdubWVudFNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIHZlcnRpY2FsQWxpZ25bX2k0XS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgICAgYWxpZ25tZW50U2V0LmFkZChub2RlSWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gbmV3IFNldChbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFsaWdubWVudFNldCkpLmZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICByZXR1cm4gZml4ZWROb2Rlcy5oYXMoeCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB2YXIgeFBvcyA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb24uc2l6ZSA+IDApIHhQb3MgPSB4Q29vcmRzW25vZGVJbmRleGVzLmdldChpbnRlcnNlY3Rpb24udmFsdWVzKCkubmV4dCgpLnZhbHVlKV07ZWxzZSB4UG9zID0gY2FsY3VsYXRlQXZnUG9zaXRpb24oYWxpZ25tZW50U2V0KS54O1xuXG4gICAgICAgICAgICB2ZXJ0aWNhbEFsaWduW19pNF0uZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICAgIHRhcmdldE1hdHJpeFtjb3VudF0gPSBbeFBvcywgeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV1dO1xuICAgICAgICAgICAgICBzb3VyY2VNYXRyaXhbY291bnRdID0gW3hDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldLCB5Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXV07XG4gICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgdmVydGljYWxBbGlnbi5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICAgICAgICBfbG9vcDIoX2k0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhbmRhcmRUcmFuc2Zvcm1hdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQuaG9yaXpvbnRhbCkge1xuICAgICAgICAgIHZhciBob3Jpem9udGFsQWxpZ24gPSBjb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50Lmhvcml6b250YWw7XG5cbiAgICAgICAgICB2YXIgX2xvb3AzID0gZnVuY3Rpb24gX2xvb3AzKF9pNSkge1xuICAgICAgICAgICAgdmFyIGFsaWdubWVudFNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGhvcml6b250YWxBbGlnbltfaTVdLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICBhbGlnbm1lbnRTZXQuYWRkKG5vZGVJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBuZXcgU2V0KFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoYWxpZ25tZW50U2V0KSkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmaXhlZE5vZGVzLmhhcyh4KTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHZhciB5UG9zID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKGludGVyc2VjdGlvbi5zaXplID4gMCkgeVBvcyA9IHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KGludGVyc2VjdGlvbi52YWx1ZXMoKS5uZXh0KCkudmFsdWUpXTtlbHNlIHlQb3MgPSBjYWxjdWxhdGVBdmdQb3NpdGlvbihhbGlnbm1lbnRTZXQpLnk7XG5cbiAgICAgICAgICAgIGhvcml6b250YWxBbGlnbltfaTVdLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICB0YXJnZXRNYXRyaXhbY291bnRdID0gW3hDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldLCB5UG9zXTtcbiAgICAgICAgICAgICAgc291cmNlTWF0cml4W2NvdW50XSA9IFt4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXSwgeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV1dO1xuICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IGhvcml6b250YWxBbGlnbi5sZW5ndGg7IF9pNSsrKSB7XG4gICAgICAgICAgICBfbG9vcDMoX2k1KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhbmRhcmRUcmFuc2Zvcm1hdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCkge1xuICAgICAgICAgIHJlZmxlY3Rpb25UeXBlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSkoKTtcbiAgICB9IGVsc2UgaWYgKGNvbnN0cmFpbnRzLnJlbGF0aXZlUGxhY2VtZW50Q29uc3RyYWludCkge1xuICAgICAgLy8gZmluYWxseSBjaGVjayByZWxhdGl2ZSBwbGFjZW1lbnQgY29uc3RyYWludFxuICAgICAgLy8gZmluZCBsYXJnZXN0IGNvbXBvbmVudCBpbiBkYWdcbiAgICAgIHZhciBsYXJnZXN0Q29tcG9uZW50U2l6ZSA9IDA7XG4gICAgICB2YXIgbGFyZ2VzdENvbXBvbmVudEluZGV4ID0gMDtcbiAgICAgIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IGNvbXBvbmVudHMubGVuZ3RoOyBfaTYrKykge1xuICAgICAgICBpZiAoY29tcG9uZW50c1tfaTZdLmxlbmd0aCA+IGxhcmdlc3RDb21wb25lbnRTaXplKSB7XG4gICAgICAgICAgbGFyZ2VzdENvbXBvbmVudFNpemUgPSBjb21wb25lbnRzW19pNl0ubGVuZ3RoO1xuICAgICAgICAgIGxhcmdlc3RDb21wb25lbnRJbmRleCA9IF9pNjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaWYgbGFyZ2VzdCBjb21wb25lbnQgaXNuJ3QgZG9taW5hbnQsIHRoZW4gdGFrZSB0aGUgdm90ZXMgZm9yIHJlZmxlY3Rpb25cbiAgICAgIGlmIChsYXJnZXN0Q29tcG9uZW50U2l6ZSA8IGRhZ1VuZGlyZWN0ZWQuc2l6ZSAvIDIpIHtcbiAgICAgICAgYXBwbHlSZWZsZWN0aW9uRm9yUmVsYXRpdmVQbGFjZW1lbnQoY29uc3RyYWludHMucmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50KTtcbiAgICAgICAgc3RhbmRhcmRUcmFuc2Zvcm1hdGlvbiA9IGZhbHNlO1xuICAgICAgICByZWZsZWN0aW9uVHlwZSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdXNlIGxhcmdlc3QgY29tcG9uZW50IGZvciB0cmFuc2Zvcm1hdGlvblxuICAgICAgICAvLyBjb25zdHJ1Y3QgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgc3ViZ3JhcGhzIGluIHRoZSBsYXJnZXN0IGNvbXBvbmVudFxuICAgICAgICB2YXIgc3ViR3JhcGhPbkhvcml6b250YWwgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBzdWJHcmFwaE9uVmVydGljYWwgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBjb25zdHJhaW50c0lubGFyZ2VzdENvbXBvbmVudCA9IFtdO1xuXG4gICAgICAgIGNvbXBvbmVudHNbbGFyZ2VzdENvbXBvbmVudEluZGV4XS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICBkYWcuZ2V0KG5vZGVJZCkuZm9yRWFjaChmdW5jdGlvbiAoYWRqYWNlbnQpIHtcbiAgICAgICAgICAgIGlmIChhZGphY2VudC5kaXJlY3Rpb24gPT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICAgICAgaWYgKHN1YkdyYXBoT25Ib3Jpem9udGFsLmhhcyhub2RlSWQpKSB7XG4gICAgICAgICAgICAgICAgc3ViR3JhcGhPbkhvcml6b250YWwuZ2V0KG5vZGVJZCkucHVzaChhZGphY2VudCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3ViR3JhcGhPbkhvcml6b250YWwuc2V0KG5vZGVJZCwgW2FkamFjZW50XSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFzdWJHcmFwaE9uSG9yaXpvbnRhbC5oYXMoYWRqYWNlbnQuaWQpKSB7XG4gICAgICAgICAgICAgICAgc3ViR3JhcGhPbkhvcml6b250YWwuc2V0KGFkamFjZW50LmlkLCBbXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3RyYWludHNJbmxhcmdlc3RDb21wb25lbnQucHVzaCh7IGxlZnQ6IG5vZGVJZCwgcmlnaHQ6IGFkamFjZW50LmlkIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHN1YkdyYXBoT25WZXJ0aWNhbC5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgICAgIHN1YkdyYXBoT25WZXJ0aWNhbC5nZXQobm9kZUlkKS5wdXNoKGFkamFjZW50KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdWJHcmFwaE9uVmVydGljYWwuc2V0KG5vZGVJZCwgW2FkamFjZW50XSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFzdWJHcmFwaE9uVmVydGljYWwuaGFzKGFkamFjZW50LmlkKSkge1xuICAgICAgICAgICAgICAgIHN1YkdyYXBoT25WZXJ0aWNhbC5zZXQoYWRqYWNlbnQuaWQsIFtdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdHJhaW50c0lubGFyZ2VzdENvbXBvbmVudC5wdXNoKHsgdG9wOiBub2RlSWQsIGJvdHRvbTogYWRqYWNlbnQuaWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFwcGx5UmVmbGVjdGlvbkZvclJlbGF0aXZlUGxhY2VtZW50KGNvbnN0cmFpbnRzSW5sYXJnZXN0Q29tcG9uZW50KTtcbiAgICAgICAgcmVmbGVjdGlvblR5cGUgPSBmYWxzZTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgYXBwcm9wcmlhdGUgcG9zaXRpb25pbmcgZm9yIHN1YmdyYXBoc1xuICAgICAgICB2YXIgcG9zaXRpb25NYXBIb3Jpem9udGFsID0gZmluZEFwcHJvcHJpYXRlUG9zaXRpb25Gb3JSZWxhdGl2ZVBsYWNlbWVudChzdWJHcmFwaE9uSG9yaXpvbnRhbCwgXCJob3Jpem9udGFsXCIpO1xuICAgICAgICB2YXIgcG9zaXRpb25NYXBWZXJ0aWNhbCA9IGZpbmRBcHByb3ByaWF0ZVBvc2l0aW9uRm9yUmVsYXRpdmVQbGFjZW1lbnQoc3ViR3JhcGhPblZlcnRpY2FsLCBcInZlcnRpY2FsXCIpO1xuXG4gICAgICAgIC8vIGNvbnN0cnVjdCBzb3VyY2UgYW5kIHRhcmdldCBjb25maWd1cmF0aW9uXG4gICAgICAgIGNvbXBvbmVudHNbbGFyZ2VzdENvbXBvbmVudEluZGV4XS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQsIGkpIHtcbiAgICAgICAgICBzb3VyY2VNYXRyaXhbaV0gPSBbeENvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV0sIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldXTtcbiAgICAgICAgICB0YXJnZXRNYXRyaXhbaV0gPSBbXTtcbiAgICAgICAgICBpZiAocG9zaXRpb25NYXBIb3Jpem9udGFsLmhhcyhub2RlSWQpKSB7XG4gICAgICAgICAgICB0YXJnZXRNYXRyaXhbaV1bMF0gPSBwb3NpdGlvbk1hcEhvcml6b250YWwuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldE1hdHJpeFtpXVswXSA9IHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVJZCldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocG9zaXRpb25NYXBWZXJ0aWNhbC5oYXMobm9kZUlkKSkge1xuICAgICAgICAgICAgdGFyZ2V0TWF0cml4W2ldWzFdID0gcG9zaXRpb25NYXBWZXJ0aWNhbC5nZXQobm9kZUlkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0TWF0cml4W2ldWzFdID0geUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBzdGFuZGFyZFRyYW5zZm9ybWF0aW9uID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB0cmFuc2Zvcm1hdGlvbiBpcyByZXF1aXJlZCwgdGhlbiBjYWxjdWxhdGUgYW5kIGFwcGx5IHRyYW5zZm9ybWF0aW9uIG1hdHJpeFxuICAgIGlmIChzdGFuZGFyZFRyYW5zZm9ybWF0aW9uKSB7XG4gICAgICAvKiBjYWxjdWxhdGUgdHJhbnNmb3JtYXRpb24gbWF0cml4ICovXG4gICAgICB2YXIgdHJhbnNmb3JtYXRpb25NYXRyaXggPSB2b2lkIDA7XG4gICAgICB2YXIgdGFyZ2V0TWF0cml4VHJhbnNwb3NlID0gTWF0cml4LnRyYW5zcG9zZSh0YXJnZXRNYXRyaXgpOyAvLyBBJ1xuICAgICAgdmFyIHNvdXJjZU1hdHJpeFRyYW5zcG9zZSA9IE1hdHJpeC50cmFuc3Bvc2Uoc291cmNlTWF0cml4KTsgLy8gQidcblxuICAgICAgLy8gY2VudHJhbGl6ZSB0cmFuc3Bvc2UgbWF0cmljZXNcbiAgICAgIGZvciAodmFyIF9pNyA9IDA7IF9pNyA8IHRhcmdldE1hdHJpeFRyYW5zcG9zZS5sZW5ndGg7IF9pNysrKSB7XG4gICAgICAgIHRhcmdldE1hdHJpeFRyYW5zcG9zZVtfaTddID0gTWF0cml4Lm11bHRHYW1tYSh0YXJnZXRNYXRyaXhUcmFuc3Bvc2VbX2k3XSk7XG4gICAgICAgIHNvdXJjZU1hdHJpeFRyYW5zcG9zZVtfaTddID0gTWF0cml4Lm11bHRHYW1tYShzb3VyY2VNYXRyaXhUcmFuc3Bvc2VbX2k3XSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGRvIGFjdHVhbCBjYWxjdWxhdGlvbiBmb3IgdHJhbnNmb3JtYXRpb24gbWF0cml4XG4gICAgICB2YXIgdGVtcE1hdHJpeCA9IE1hdHJpeC5tdWx0TWF0KHRhcmdldE1hdHJpeFRyYW5zcG9zZSwgTWF0cml4LnRyYW5zcG9zZShzb3VyY2VNYXRyaXhUcmFuc3Bvc2UpKTsgLy8gdGVtcE1hdHJpeCA9IEEnQlxuICAgICAgdmFyIFNWRFJlc3VsdCA9IFNWRC5zdmQodGVtcE1hdHJpeCk7IC8vIFNWRChBJ0IpID0gVVNWJywgc3ZkIGZ1bmN0aW9uIHJldHVybnMgVSwgUyBhbmQgViBcbiAgICAgIHRyYW5zZm9ybWF0aW9uTWF0cml4ID0gTWF0cml4Lm11bHRNYXQoU1ZEUmVzdWx0LlYsIE1hdHJpeC50cmFuc3Bvc2UoU1ZEUmVzdWx0LlUpKTsgLy8gdHJhbnNmb3JtYXRpb25NYXRyaXggPSBUID0gVlUnXG5cbiAgICAgIC8qIGFwcGx5IGZvdW5kIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCB0byBvYnRhaW4gZmluYWwgZHJhZnQgbGF5b3V0ICovXG4gICAgICBmb3IgKHZhciBfaTggPSAwOyBfaTggPCBub2RlSW5kZXhlcy5zaXplOyBfaTgrKykge1xuICAgICAgICB2YXIgdGVtcDEgPSBbeENvb3Jkc1tfaThdLCB5Q29vcmRzW19pOF1dO1xuICAgICAgICB2YXIgdGVtcDIgPSBbdHJhbnNmb3JtYXRpb25NYXRyaXhbMF1bMF0sIHRyYW5zZm9ybWF0aW9uTWF0cml4WzFdWzBdXTtcbiAgICAgICAgdmFyIHRlbXAzID0gW3RyYW5zZm9ybWF0aW9uTWF0cml4WzBdWzFdLCB0cmFuc2Zvcm1hdGlvbk1hdHJpeFsxXVsxXV07XG4gICAgICAgIHhDb29yZHNbX2k4XSA9IE1hdHJpeC5kb3RQcm9kdWN0KHRlbXAxLCB0ZW1wMik7XG4gICAgICAgIHlDb29yZHNbX2k4XSA9IE1hdHJpeC5kb3RQcm9kdWN0KHRlbXAxLCB0ZW1wMyk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGxpZWQgb25seSBib3RoIGFsaWdubWVudCBhbmQgcmVsLiBwbGFjZW1lbnQgY29uc3RyYWludHMgZXhpc3RcbiAgICAgIGlmIChyZWZsZWN0aW9uVHlwZSkge1xuICAgICAgICBhcHBseVJlZmxlY3Rpb25Gb3JSZWxhdGl2ZVBsYWNlbWVudChjb25zdHJhaW50cy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChDb1NFQ29uc3RhbnRzLkVORk9SQ0VfQ09OU1RSQUlOVFMpIHtcbiAgICAvKioqKiAgZW5mb3JjZSBjb25zdHJhaW50cyBvbiB0aGUgdHJhbnNmb3JtZWQgZHJhZnQgbGF5b3V0ICoqKiovXG5cbiAgICAvKiBmaXJzdCBlbmZvcmNlIGZpeGVkIG5vZGUgY29uc3RyYWludCAqL1xuXG4gICAgaWYgKGNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQgJiYgY29uc3RyYWludHMuZml4ZWROb2RlQ29uc3RyYWludC5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgdHJhbnNsYXRpb25BbW91bnQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgIGNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQuZm9yRWFjaChmdW5jdGlvbiAobm9kZURhdGEsIGkpIHtcbiAgICAgICAgdmFyIHBvc0luVGhlb3J5ID0geyB4OiB4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlRGF0YS5ub2RlSWQpXSwgeTogeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZURhdGEubm9kZUlkKV0gfTtcbiAgICAgICAgdmFyIHBvc0Rlc2lyZWQgPSBub2RlRGF0YS5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHBvc0RpZmYgPSBjYWxjdWxhdGVQb3NpdGlvbkRpZmYocG9zRGVzaXJlZCwgcG9zSW5UaGVvcnkpO1xuICAgICAgICB0cmFuc2xhdGlvbkFtb3VudC54ICs9IHBvc0RpZmYueDtcbiAgICAgICAgdHJhbnNsYXRpb25BbW91bnQueSArPSBwb3NEaWZmLnk7XG4gICAgICB9KTtcbiAgICAgIHRyYW5zbGF0aW9uQW1vdW50LnggLz0gY29uc3RyYWludHMuZml4ZWROb2RlQ29uc3RyYWludC5sZW5ndGg7XG4gICAgICB0cmFuc2xhdGlvbkFtb3VudC55IC89IGNvbnN0cmFpbnRzLmZpeGVkTm9kZUNvbnN0cmFpbnQubGVuZ3RoO1xuXG4gICAgICB4Q29vcmRzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgICAgIHhDb29yZHNbaV0gKz0gdHJhbnNsYXRpb25BbW91bnQueDtcbiAgICAgIH0pO1xuXG4gICAgICB5Q29vcmRzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBpKSB7XG4gICAgICAgIHlDb29yZHNbaV0gKz0gdHJhbnNsYXRpb25BbW91bnQueTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdHJhaW50cy5maXhlZE5vZGVDb25zdHJhaW50LmZvckVhY2goZnVuY3Rpb24gKG5vZGVEYXRhKSB7XG4gICAgICAgIHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KG5vZGVEYXRhLm5vZGVJZCldID0gbm9kZURhdGEucG9zaXRpb24ueDtcbiAgICAgICAgeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZURhdGEubm9kZUlkKV0gPSBub2RlRGF0YS5wb3NpdGlvbi55O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyogdGhlbiBlbmZvcmNlIGFsaWdubWVudCBjb25zdHJhaW50ICovXG5cbiAgICBpZiAoY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludCkge1xuICAgICAgaWYgKGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWwpIHtcbiAgICAgICAgdmFyIHhBbGlnbiA9IGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQudmVydGljYWw7XG5cbiAgICAgICAgdmFyIF9sb29wNCA9IGZ1bmN0aW9uIF9sb29wNChfaTkpIHtcbiAgICAgICAgICB2YXIgYWxpZ25tZW50U2V0ID0gbmV3IFNldCgpO1xuICAgICAgICAgIHhBbGlnbltfaTldLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgYWxpZ25tZW50U2V0LmFkZChub2RlSWQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBuZXcgU2V0KFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoYWxpZ25tZW50U2V0KSkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gZml4ZWROb2Rlcy5oYXMoeCk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHZhciB4UG9zID0gdm9pZCAwO1xuICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb24uc2l6ZSA+IDApIHhQb3MgPSB4Q29vcmRzW25vZGVJbmRleGVzLmdldChpbnRlcnNlY3Rpb24udmFsdWVzKCkubmV4dCgpLnZhbHVlKV07ZWxzZSB4UG9zID0gY2FsY3VsYXRlQXZnUG9zaXRpb24oYWxpZ25tZW50U2V0KS54O1xuXG4gICAgICAgICAgYWxpZ25tZW50U2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgaWYgKCFmaXhlZE5vZGVzLmhhcyhub2RlSWQpKSB4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXSA9IHhQb3M7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgX2k5ID0gMDsgX2k5IDwgeEFsaWduLmxlbmd0aDsgX2k5KyspIHtcbiAgICAgICAgICBfbG9vcDQoX2k5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQuaG9yaXpvbnRhbCkge1xuICAgICAgICB2YXIgeUFsaWduID0gY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC5ob3Jpem9udGFsO1xuXG4gICAgICAgIHZhciBfbG9vcDUgPSBmdW5jdGlvbiBfbG9vcDUoX2kxMCkge1xuICAgICAgICAgIHZhciBhbGlnbm1lbnRTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgeUFsaWduW19pMTBdLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgYWxpZ25tZW50U2V0LmFkZChub2RlSWQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBuZXcgU2V0KFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoYWxpZ25tZW50U2V0KSkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gZml4ZWROb2Rlcy5oYXMoeCk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHZhciB5UG9zID0gdm9pZCAwO1xuICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb24uc2l6ZSA+IDApIHlQb3MgPSB5Q29vcmRzW25vZGVJbmRleGVzLmdldChpbnRlcnNlY3Rpb24udmFsdWVzKCkubmV4dCgpLnZhbHVlKV07ZWxzZSB5UG9zID0gY2FsY3VsYXRlQXZnUG9zaXRpb24oYWxpZ25tZW50U2V0KS55O1xuXG4gICAgICAgICAgYWxpZ25tZW50U2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgaWYgKCFmaXhlZE5vZGVzLmhhcyhub2RlSWQpKSB5Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXSA9IHlQb3M7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgX2kxMCA9IDA7IF9pMTAgPCB5QWxpZ24ubGVuZ3RoOyBfaTEwKyspIHtcbiAgICAgICAgICBfbG9vcDUoX2kxMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBmaW5hbGx5IGVuZm9yY2UgcmVsYXRpdmUgcGxhY2VtZW50IGNvbnN0cmFpbnQgKi9cblxuICAgIGlmIChjb25zdHJhaW50cy5yZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnQpIHtcbiAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50ID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50ID0gbmV3IE1hcCgpO1xuICAgICAgICB2YXIgZHVtbXlUb05vZGVGb3JWZXJ0aWNhbEFsaWdubWVudCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIGR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIGR1bW15UG9zaXRpb25zRm9yVmVydGljYWxBbGlnbm1lbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBkdW1teVBvc2l0aW9uc0Zvckhvcml6b250YWxBbGlnbm1lbnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBmaXhlZE5vZGVzT25Ib3Jpem9udGFsID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgZml4ZWROb2Rlc09uVmVydGljYWwgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgLy8gZmlsbCBtYXBzIGFuZCBzZXRzICAgICAgXG4gICAgICAgIGZpeGVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgZml4ZWROb2Rlc09uSG9yaXpvbnRhbC5hZGQobm9kZUlkKTtcbiAgICAgICAgICBmaXhlZE5vZGVzT25WZXJ0aWNhbC5hZGQobm9kZUlkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGNvbnN0cmFpbnRzLmFsaWdubWVudENvbnN0cmFpbnQpIHtcbiAgICAgICAgICBpZiAoY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC52ZXJ0aWNhbCkge1xuICAgICAgICAgICAgdmFyIHZlcnRpY2FsQWxpZ25tZW50ID0gY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC52ZXJ0aWNhbDtcblxuICAgICAgICAgICAgdmFyIF9sb29wNiA9IGZ1bmN0aW9uIF9sb29wNihfaTExKSB7XG4gICAgICAgICAgICAgIGR1bW15VG9Ob2RlRm9yVmVydGljYWxBbGlnbm1lbnQuc2V0KFwiZHVtbXlcIiArIF9pMTEsIFtdKTtcbiAgICAgICAgICAgICAgdmVydGljYWxBbGlnbm1lbnRbX2kxMV0uZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgbm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudC5zZXQobm9kZUlkLCBcImR1bW15XCIgKyBfaTExKTtcbiAgICAgICAgICAgICAgICBkdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChcImR1bW15XCIgKyBfaTExKS5wdXNoKG5vZGVJZCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpeGVkTm9kZXMuaGFzKG5vZGVJZCkpIHtcbiAgICAgICAgICAgICAgICAgIGZpeGVkTm9kZXNPbkhvcml6b250YWwuYWRkKFwiZHVtbXlcIiArIF9pMTEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGR1bW15UG9zaXRpb25zRm9yVmVydGljYWxBbGlnbm1lbnQuc2V0KFwiZHVtbXlcIiArIF9pMTEsIHhDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KHZlcnRpY2FsQWxpZ25tZW50W19pMTFdWzBdKV0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2kxMSA9IDA7IF9pMTEgPCB2ZXJ0aWNhbEFsaWdubWVudC5sZW5ndGg7IF9pMTErKykge1xuICAgICAgICAgICAgICBfbG9vcDYoX2kxMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb25zdHJhaW50cy5hbGlnbm1lbnRDb25zdHJhaW50Lmhvcml6b250YWwpIHtcbiAgICAgICAgICAgIHZhciBob3Jpem9udGFsQWxpZ25tZW50ID0gY29uc3RyYWludHMuYWxpZ25tZW50Q29uc3RyYWludC5ob3Jpem9udGFsO1xuXG4gICAgICAgICAgICB2YXIgX2xvb3A3ID0gZnVuY3Rpb24gX2xvb3A3KF9pMTIpIHtcbiAgICAgICAgICAgICAgZHVtbXlUb05vZGVGb3JIb3Jpem9udGFsQWxpZ25tZW50LnNldChcImR1bW15XCIgKyBfaTEyLCBbXSk7XG4gICAgICAgICAgICAgIGhvcml6b250YWxBbGlnbm1lbnRbX2kxMl0uZm9yRWFjaChmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgbm9kZVRvRHVtbXlGb3JIb3Jpem9udGFsQWxpZ25tZW50LnNldChub2RlSWQsIFwiZHVtbXlcIiArIF9pMTIpO1xuICAgICAgICAgICAgICAgIGR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5nZXQoXCJkdW1teVwiICsgX2kxMikucHVzaChub2RlSWQpO1xuICAgICAgICAgICAgICAgIGlmIChmaXhlZE5vZGVzLmhhcyhub2RlSWQpKSB7XG4gICAgICAgICAgICAgICAgICBmaXhlZE5vZGVzT25WZXJ0aWNhbC5hZGQoXCJkdW1teVwiICsgX2kxMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgZHVtbXlQb3NpdGlvbnNGb3JIb3Jpem9udGFsQWxpZ25tZW50LnNldChcImR1bW15XCIgKyBfaTEyLCB5Q29vcmRzW25vZGVJbmRleGVzLmdldChob3Jpem9udGFsQWxpZ25tZW50W19pMTJdWzBdKV0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yICh2YXIgX2kxMiA9IDA7IF9pMTIgPCBob3Jpem9udGFsQWxpZ25tZW50Lmxlbmd0aDsgX2kxMisrKSB7XG4gICAgICAgICAgICAgIF9sb29wNyhfaTEyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zdHJ1Y3QgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgZGFncyAoc3ViZ3JhcGhzKSBmcm9tIG92ZXJhbGwgZGFnXG4gICAgICAgIHZhciBkYWdPbkhvcml6b250YWwgPSBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBkYWdPblZlcnRpY2FsID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIHZhciBfbG9vcDggPSBmdW5jdGlvbiBfbG9vcDgobm9kZUlkKSB7XG4gICAgICAgICAgZGFnLmdldChub2RlSWQpLmZvckVhY2goZnVuY3Rpb24gKGFkamFjZW50KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlSWQgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0Tm9kZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChhZGphY2VudFtcImRpcmVjdGlvblwiXSA9PSBcImhvcml6b250YWxcIikge1xuICAgICAgICAgICAgICBzb3VyY2VJZCA9IG5vZGVUb0R1bW15Rm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KG5vZGVJZCkgPyBub2RlVG9EdW1teUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChub2RlSWQpIDogbm9kZUlkO1xuICAgICAgICAgICAgICBpZiAobm9kZVRvRHVtbXlGb3JWZXJ0aWNhbEFsaWdubWVudC5nZXQoYWRqYWNlbnQuaWQpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IHsgaWQ6IG5vZGVUb0R1bW15Rm9yVmVydGljYWxBbGlnbm1lbnQuZ2V0KGFkamFjZW50LmlkKSwgZ2FwOiBhZGphY2VudC5nYXAsIGRpcmVjdGlvbjogYWRqYWNlbnQuZGlyZWN0aW9uIH07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGFkamFjZW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkYWdPbkhvcml6b250YWwuaGFzKHNvdXJjZUlkKSkge1xuICAgICAgICAgICAgICAgIGRhZ09uSG9yaXpvbnRhbC5nZXQoc291cmNlSWQpLnB1c2godGFyZ2V0Tm9kZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGFnT25Ib3Jpem9udGFsLnNldChzb3VyY2VJZCwgW3RhcmdldE5vZGVdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWRhZ09uSG9yaXpvbnRhbC5oYXModGFyZ2V0Tm9kZS5pZCkpIHtcbiAgICAgICAgICAgICAgICBkYWdPbkhvcml6b250YWwuc2V0KHRhcmdldE5vZGUuaWQsIFtdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc291cmNlSWQgPSBub2RlVG9EdW1teUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KG5vZGVJZCkgPyBub2RlVG9EdW1teUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KG5vZGVJZCkgOiBub2RlSWQ7XG4gICAgICAgICAgICAgIGlmIChub2RlVG9EdW1teUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KGFkamFjZW50LmlkKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSB7IGlkOiBub2RlVG9EdW1teUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KGFkamFjZW50LmlkKSwgZ2FwOiBhZGphY2VudC5nYXAsIGRpcmVjdGlvbjogYWRqYWNlbnQuZGlyZWN0aW9uIH07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGFkamFjZW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkYWdPblZlcnRpY2FsLmhhcyhzb3VyY2VJZCkpIHtcbiAgICAgICAgICAgICAgICBkYWdPblZlcnRpY2FsLmdldChzb3VyY2VJZCkucHVzaCh0YXJnZXROb2RlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYWdPblZlcnRpY2FsLnNldChzb3VyY2VJZCwgW3RhcmdldE5vZGVdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWRhZ09uVmVydGljYWwuaGFzKHRhcmdldE5vZGUuaWQpKSB7XG4gICAgICAgICAgICAgICAgZGFnT25WZXJ0aWNhbC5zZXQodGFyZ2V0Tm9kZS5pZCwgW10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb241ID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNSA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I1ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNSA9IGRhZy5rZXlzKClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDU7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgPSAoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNSA9IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBub2RlSWQgPSBfc3RlcDUudmFsdWU7XG5cbiAgICAgICAgICAgIF9sb29wOChub2RlSWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGZpbmQgc291cmNlIG5vZGVzIG9mIGVhY2ggY29tcG9uZW50IGluIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGRhZ3NcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I1ID0gdHJ1ZTtcbiAgICAgICAgICBfaXRlcmF0b3JFcnJvcjUgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjUgJiYgX2l0ZXJhdG9yNS5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yNS5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNSkge1xuICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVuZGlyZWN0ZWRPbkhvcml6b250YWwgPSBkYWdUb1VuZGlyZWN0ZWQoZGFnT25Ib3Jpem9udGFsKTtcbiAgICAgICAgdmFyIHVuZGlyZWN0ZWRPblZlcnRpY2FsID0gZGFnVG9VbmRpcmVjdGVkKGRhZ09uVmVydGljYWwpO1xuICAgICAgICB2YXIgY29tcG9uZW50c09uSG9yaXpvbnRhbCA9IGZpbmRDb21wb25lbnRzKHVuZGlyZWN0ZWRPbkhvcml6b250YWwpO1xuICAgICAgICB2YXIgY29tcG9uZW50c09uVmVydGljYWwgPSBmaW5kQ29tcG9uZW50cyh1bmRpcmVjdGVkT25WZXJ0aWNhbCk7XG4gICAgICAgIHZhciByZXZlcnNlZERhZ09uSG9yaXpvbnRhbCA9IGRhZ1RvUmV2ZXJzZWQoZGFnT25Ib3Jpem9udGFsKTtcbiAgICAgICAgdmFyIHJldmVyc2VkRGFnT25WZXJ0aWNhbCA9IGRhZ1RvUmV2ZXJzZWQoZGFnT25WZXJ0aWNhbCk7XG4gICAgICAgIHZhciBjb21wb25lbnRTb3VyY2VzT25Ib3Jpem9udGFsID0gW107XG4gICAgICAgIHZhciBjb21wb25lbnRTb3VyY2VzT25WZXJ0aWNhbCA9IFtdO1xuXG4gICAgICAgIGNvbXBvbmVudHNPbkhvcml6b250YWwuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50LCBpbmRleCkge1xuICAgICAgICAgIGNvbXBvbmVudFNvdXJjZXNPbkhvcml6b250YWxbaW5kZXhdID0gW107XG4gICAgICAgICAgY29tcG9uZW50LmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgaWYgKHJldmVyc2VkRGFnT25Ib3Jpem9udGFsLmdldChub2RlSWQpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgIGNvbXBvbmVudFNvdXJjZXNPbkhvcml6b250YWxbaW5kZXhdLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29tcG9uZW50c09uVmVydGljYWwuZm9yRWFjaChmdW5jdGlvbiAoY29tcG9uZW50LCBpbmRleCkge1xuICAgICAgICAgIGNvbXBvbmVudFNvdXJjZXNPblZlcnRpY2FsW2luZGV4XSA9IFtdO1xuICAgICAgICAgIGNvbXBvbmVudC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgIGlmIChyZXZlcnNlZERhZ09uVmVydGljYWwuZ2V0KG5vZGVJZCkubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgY29tcG9uZW50U291cmNlc09uVmVydGljYWxbaW5kZXhdLnB1c2gobm9kZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIGFwcHJvcHJpYXRlIHBvc2l0aW9uaW5nIGZvciBzdWJncmFwaHNcbiAgICAgICAgdmFyIHBvc2l0aW9uTWFwSG9yaXpvbnRhbCA9IGZpbmRBcHByb3ByaWF0ZVBvc2l0aW9uRm9yUmVsYXRpdmVQbGFjZW1lbnQoZGFnT25Ib3Jpem9udGFsLCBcImhvcml6b250YWxcIiwgZml4ZWROb2Rlc09uSG9yaXpvbnRhbCwgZHVtbXlQb3NpdGlvbnNGb3JWZXJ0aWNhbEFsaWdubWVudCwgY29tcG9uZW50U291cmNlc09uSG9yaXpvbnRhbCk7XG4gICAgICAgIHZhciBwb3NpdGlvbk1hcFZlcnRpY2FsID0gZmluZEFwcHJvcHJpYXRlUG9zaXRpb25Gb3JSZWxhdGl2ZVBsYWNlbWVudChkYWdPblZlcnRpY2FsLCBcInZlcnRpY2FsXCIsIGZpeGVkTm9kZXNPblZlcnRpY2FsLCBkdW1teVBvc2l0aW9uc0Zvckhvcml6b250YWxBbGlnbm1lbnQsIGNvbXBvbmVudFNvdXJjZXNPblZlcnRpY2FsKTtcblxuICAgICAgICAvLyB1cGRhdGUgcG9zaXRpb25zIG9mIHRoZSBub2RlcyBiYXNlZCBvbiByZWxhdGl2ZSBwbGFjZW1lbnQgY29uc3RyYWludHNcblxuICAgICAgICB2YXIgX2xvb3A5ID0gZnVuY3Rpb24gX2xvb3A5KGtleSkge1xuICAgICAgICAgIGlmIChkdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChrZXkpKSB7XG4gICAgICAgICAgICBkdW1teVRvTm9kZUZvclZlcnRpY2FsQWxpZ25tZW50LmdldChrZXkpLmZvckVhY2goZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgICAgICB4Q29vcmRzW25vZGVJbmRleGVzLmdldChub2RlSWQpXSA9IHBvc2l0aW9uTWFwSG9yaXpvbnRhbC5nZXQoa2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4Q29vcmRzW25vZGVJbmRleGVzLmdldChrZXkpXSA9IHBvc2l0aW9uTWFwSG9yaXpvbnRhbC5nZXQoa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb242ID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNiA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I2ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNiA9IHBvc2l0aW9uTWFwSG9yaXpvbnRhbC5rZXlzKClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDY7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgPSAoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNiA9IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBfc3RlcDYudmFsdWU7XG5cbiAgICAgICAgICAgIF9sb29wOShrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3I2ID0gdHJ1ZTtcbiAgICAgICAgICBfaXRlcmF0b3JFcnJvcjYgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjYgJiYgX2l0ZXJhdG9yNi5yZXR1cm4pIHtcbiAgICAgICAgICAgICAgX2l0ZXJhdG9yNi5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yNikge1xuICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9sb29wMTAgPSBmdW5jdGlvbiBfbG9vcDEwKGtleSkge1xuICAgICAgICAgIGlmIChkdW1teVRvTm9kZUZvckhvcml6b250YWxBbGlnbm1lbnQuZ2V0KGtleSkpIHtcbiAgICAgICAgICAgIGR1bW15VG9Ob2RlRm9ySG9yaXpvbnRhbEFsaWdubWVudC5nZXQoa2V5KS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICAgICAgeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQobm9kZUlkKV0gPSBwb3NpdGlvbk1hcFZlcnRpY2FsLmdldChrZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHlDb29yZHNbbm9kZUluZGV4ZXMuZ2V0KGtleSldID0gcG9zaXRpb25NYXBWZXJ0aWNhbC5nZXQoa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9kaWRJdGVyYXRvckVycm9yNyA9IGZhbHNlO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yRXJyb3I3ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yNyA9IHBvc2l0aW9uTWFwVmVydGljYWwua2V5cygpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA3OyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb243ID0gKF9zdGVwNyA9IF9pdGVyYXRvcjcubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjcgPSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gX3N0ZXA3LnZhbHVlO1xuXG4gICAgICAgICAgICBfbG9vcDEwKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjcgPSB0cnVlO1xuICAgICAgICAgIF9pdGVyYXRvckVycm9yNyA9IGVycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uNyAmJiBfaXRlcmF0b3I3LnJldHVybikge1xuICAgICAgICAgICAgICBfaXRlcmF0b3I3LnJldHVybigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3I3KSB7XG4gICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yNztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gYXNzaWduIG5ldyBjb29yZGluYXRlcyB0byBub2RlcyBhZnRlciBjb25zdHJhaW50IGhhbmRsaW5nXG4gIGZvciAodmFyIF9pMTMgPSAwOyBfaTEzIDwgYWxsTm9kZXMubGVuZ3RoOyBfaTEzKyspIHtcbiAgICB2YXIgX25vZGUgPSBhbGxOb2Rlc1tfaTEzXTtcbiAgICBpZiAoX25vZGUuZ2V0Q2hpbGQoKSA9PSBudWxsKSB7XG4gICAgICBfbm9kZS5zZXRDZW50ZXIoeENvb3Jkc1tub2RlSW5kZXhlcy5nZXQoX25vZGUuaWQpXSwgeUNvb3Jkc1tub2RlSW5kZXhlcy5nZXQoX25vZGUuaWQpXSk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnN0cmFpbnRIYW5kbGVyO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNTUxOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX181NTFfXztcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIHN0YXJ0dXBcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdC8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/cytoscape-fcose/node_modules/cose-base/cose-base.js\n");

/***/ }),

/***/ "./node_modules/cytoscape-fcose/node_modules/layout-base/layout-base.js":
/*!******************************************************************************!*\
  !*** ./node_modules/cytoscape-fcose/node_modules/layout-base/layout-base.js ***!
  \******************************************************************************/
/***/ (function(module) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_543__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_543__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_543__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_543__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__nested_webpack_require_543__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_543__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_543__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_543__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_543__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_543__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_543__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_543__(__nested_webpack_require_543__.s = 28);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction LayoutConstants() {}\n\n/**\r\n * Layout Quality: 0:draft, 1:default, 2:proof\r\n */\nLayoutConstants.QUALITY = 1;\n\n/**\r\n * Default parameters\r\n */\nLayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED = false;\nLayoutConstants.DEFAULT_INCREMENTAL = false;\nLayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT = true;\nLayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT = false;\nLayoutConstants.DEFAULT_ANIMATION_PERIOD = 50;\nLayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = false;\n\n// -----------------------------------------------------------------------------\n// Section: General other constants\n// -----------------------------------------------------------------------------\n/*\r\n * Margins of a graph to be applied on bouding rectangle of its contents. We\r\n * assume margins on all four sides to be uniform.\r\n */\nLayoutConstants.DEFAULT_GRAPH_MARGIN = 15;\n\n/*\r\n * Whether to consider labels in node dimensions or not\r\n */\nLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = false;\n\n/*\r\n * Default dimension of a non-compound node.\r\n */\nLayoutConstants.SIMPLE_NODE_SIZE = 40;\n\n/*\r\n * Default dimension of a non-compound node.\r\n */\nLayoutConstants.SIMPLE_NODE_HALF_SIZE = LayoutConstants.SIMPLE_NODE_SIZE / 2;\n\n/*\r\n * Empty compound node size. When a compound node is empty, its both\r\n * dimensions should be of this value.\r\n */\nLayoutConstants.EMPTY_COMPOUND_NODE_SIZE = 40;\n\n/*\r\n * Minimum length that an edge should take during layout\r\n */\nLayoutConstants.MIN_EDGE_LENGTH = 1;\n\n/*\r\n * World boundaries that layout operates on\r\n */\nLayoutConstants.WORLD_BOUNDARY = 1000000;\n\n/*\r\n * World boundaries that random positioning can be performed with\r\n */\nLayoutConstants.INITIAL_WORLD_BOUNDARY = LayoutConstants.WORLD_BOUNDARY / 1000;\n\n/*\r\n * Coordinates of the world center\r\n */\nLayoutConstants.WORLD_CENTER_X = 1200;\nLayoutConstants.WORLD_CENTER_Y = 900;\n\nmodule.exports = LayoutConstants;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __nested_webpack_require_4947__) {\n\n\"use strict\";\n\n\nvar LGraphObject = __nested_webpack_require_4947__(2);\nvar IGeometry = __nested_webpack_require_4947__(8);\nvar IMath = __nested_webpack_require_4947__(9);\n\nfunction LEdge(source, target, vEdge) {\n  LGraphObject.call(this, vEdge);\n\n  this.isOverlapingSourceAndTarget = false;\n  this.vGraphObject = vEdge;\n  this.bendpoints = [];\n  this.source = source;\n  this.target = target;\n}\n\nLEdge.prototype = Object.create(LGraphObject.prototype);\n\nfor (var prop in LGraphObject) {\n  LEdge[prop] = LGraphObject[prop];\n}\n\nLEdge.prototype.getSource = function () {\n  return this.source;\n};\n\nLEdge.prototype.getTarget = function () {\n  return this.target;\n};\n\nLEdge.prototype.isInterGraph = function () {\n  return this.isInterGraph;\n};\n\nLEdge.prototype.getLength = function () {\n  return this.length;\n};\n\nLEdge.prototype.isOverlapingSourceAndTarget = function () {\n  return this.isOverlapingSourceAndTarget;\n};\n\nLEdge.prototype.getBendpoints = function () {\n  return this.bendpoints;\n};\n\nLEdge.prototype.getLca = function () {\n  return this.lca;\n};\n\nLEdge.prototype.getSourceInLca = function () {\n  return this.sourceInLca;\n};\n\nLEdge.prototype.getTargetInLca = function () {\n  return this.targetInLca;\n};\n\nLEdge.prototype.getOtherEnd = function (node) {\n  if (this.source === node) {\n    return this.target;\n  } else if (this.target === node) {\n    return this.source;\n  } else {\n    throw \"Node is not incident with this edge\";\n  }\n};\n\nLEdge.prototype.getOtherEndInGraph = function (node, graph) {\n  var otherEnd = this.getOtherEnd(node);\n  var root = graph.getGraphManager().getRoot();\n\n  while (true) {\n    if (otherEnd.getOwner() == graph) {\n      return otherEnd;\n    }\n\n    if (otherEnd.getOwner() == root) {\n      break;\n    }\n\n    otherEnd = otherEnd.getOwner().getParent();\n  }\n\n  return null;\n};\n\nLEdge.prototype.updateLength = function () {\n  var clipPointCoordinates = new Array(4);\n\n  this.isOverlapingSourceAndTarget = IGeometry.getIntersection(this.target.getRect(), this.source.getRect(), clipPointCoordinates);\n\n  if (!this.isOverlapingSourceAndTarget) {\n    this.lengthX = clipPointCoordinates[0] - clipPointCoordinates[2];\n    this.lengthY = clipPointCoordinates[1] - clipPointCoordinates[3];\n\n    if (Math.abs(this.lengthX) < 1.0) {\n      this.lengthX = IMath.sign(this.lengthX);\n    }\n\n    if (Math.abs(this.lengthY) < 1.0) {\n      this.lengthY = IMath.sign(this.lengthY);\n    }\n\n    this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n  }\n};\n\nLEdge.prototype.updateLengthSimple = function () {\n  this.lengthX = this.target.getCenterX() - this.source.getCenterX();\n  this.lengthY = this.target.getCenterY() - this.source.getCenterY();\n\n  if (Math.abs(this.lengthX) < 1.0) {\n    this.lengthX = IMath.sign(this.lengthX);\n  }\n\n  if (Math.abs(this.lengthY) < 1.0) {\n    this.lengthY = IMath.sign(this.lengthY);\n  }\n\n  this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);\n};\n\nmodule.exports = LEdge;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction LGraphObject(vGraphObject) {\n  this.vGraphObject = vGraphObject;\n}\n\nmodule.exports = LGraphObject;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __nested_webpack_require_8167__) {\n\n\"use strict\";\n\n\nvar LGraphObject = __nested_webpack_require_8167__(2);\nvar Integer = __nested_webpack_require_8167__(10);\nvar RectangleD = __nested_webpack_require_8167__(13);\nvar LayoutConstants = __nested_webpack_require_8167__(0);\nvar RandomSeed = __nested_webpack_require_8167__(16);\nvar PointD = __nested_webpack_require_8167__(5);\n\nfunction LNode(gm, loc, size, vNode) {\n  //Alternative constructor 1 : LNode(LGraphManager gm, Point loc, Dimension size, Object vNode)\n  if (size == null && vNode == null) {\n    vNode = loc;\n  }\n\n  LGraphObject.call(this, vNode);\n\n  //Alternative constructor 2 : LNode(Layout layout, Object vNode)\n  if (gm.graphManager != null) gm = gm.graphManager;\n\n  this.estimatedSize = Integer.MIN_VALUE;\n  this.inclusionTreeDepth = Integer.MAX_VALUE;\n  this.vGraphObject = vNode;\n  this.edges = [];\n  this.graphManager = gm;\n\n  if (size != null && loc != null) this.rect = new RectangleD(loc.x, loc.y, size.width, size.height);else this.rect = new RectangleD();\n}\n\nLNode.prototype = Object.create(LGraphObject.prototype);\nfor (var prop in LGraphObject) {\n  LNode[prop] = LGraphObject[prop];\n}\n\nLNode.prototype.getEdges = function () {\n  return this.edges;\n};\n\nLNode.prototype.getChild = function () {\n  return this.child;\n};\n\nLNode.prototype.getOwner = function () {\n  //  if (this.owner != null) {\n  //    if (!(this.owner == null || this.owner.getNodes().indexOf(this) > -1)) {\n  //      throw \"assert failed\";\n  //    }\n  //  }\n\n  return this.owner;\n};\n\nLNode.prototype.getWidth = function () {\n  return this.rect.width;\n};\n\nLNode.prototype.setWidth = function (width) {\n  this.rect.width = width;\n};\n\nLNode.prototype.getHeight = function () {\n  return this.rect.height;\n};\n\nLNode.prototype.setHeight = function (height) {\n  this.rect.height = height;\n};\n\nLNode.prototype.getCenterX = function () {\n  return this.rect.x + this.rect.width / 2;\n};\n\nLNode.prototype.getCenterY = function () {\n  return this.rect.y + this.rect.height / 2;\n};\n\nLNode.prototype.getCenter = function () {\n  return new PointD(this.rect.x + this.rect.width / 2, this.rect.y + this.rect.height / 2);\n};\n\nLNode.prototype.getLocation = function () {\n  return new PointD(this.rect.x, this.rect.y);\n};\n\nLNode.prototype.getRect = function () {\n  return this.rect;\n};\n\nLNode.prototype.getDiagonal = function () {\n  return Math.sqrt(this.rect.width * this.rect.width + this.rect.height * this.rect.height);\n};\n\n/**\n * This method returns half the diagonal length of this node.\n */\nLNode.prototype.getHalfTheDiagonal = function () {\n  return Math.sqrt(this.rect.height * this.rect.height + this.rect.width * this.rect.width) / 2;\n};\n\nLNode.prototype.setRect = function (upperLeft, dimension) {\n  this.rect.x = upperLeft.x;\n  this.rect.y = upperLeft.y;\n  this.rect.width = dimension.width;\n  this.rect.height = dimension.height;\n};\n\nLNode.prototype.setCenter = function (cx, cy) {\n  this.rect.x = cx - this.rect.width / 2;\n  this.rect.y = cy - this.rect.height / 2;\n};\n\nLNode.prototype.setLocation = function (x, y) {\n  this.rect.x = x;\n  this.rect.y = y;\n};\n\nLNode.prototype.moveBy = function (dx, dy) {\n  this.rect.x += dx;\n  this.rect.y += dy;\n};\n\nLNode.prototype.getEdgeListToNode = function (to) {\n  var edgeList = [];\n  var edge;\n  var self = this;\n\n  self.edges.forEach(function (edge) {\n\n    if (edge.target == to) {\n      if (edge.source != self) throw \"Incorrect edge source!\";\n\n      edgeList.push(edge);\n    }\n  });\n\n  return edgeList;\n};\n\nLNode.prototype.getEdgesBetween = function (other) {\n  var edgeList = [];\n  var edge;\n\n  var self = this;\n  self.edges.forEach(function (edge) {\n\n    if (!(edge.source == self || edge.target == self)) throw \"Incorrect edge source and/or target\";\n\n    if (edge.target == other || edge.source == other) {\n      edgeList.push(edge);\n    }\n  });\n\n  return edgeList;\n};\n\nLNode.prototype.getNeighborsList = function () {\n  var neighbors = new Set();\n\n  var self = this;\n  self.edges.forEach(function (edge) {\n\n    if (edge.source == self) {\n      neighbors.add(edge.target);\n    } else {\n      if (edge.target != self) {\n        throw \"Incorrect incidency!\";\n      }\n\n      neighbors.add(edge.source);\n    }\n  });\n\n  return neighbors;\n};\n\nLNode.prototype.withChildren = function () {\n  var withNeighborsList = new Set();\n  var childNode;\n  var children;\n\n  withNeighborsList.add(this);\n\n  if (this.child != null) {\n    var nodes = this.child.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      childNode = nodes[i];\n      children = childNode.withChildren();\n      children.forEach(function (node) {\n        withNeighborsList.add(node);\n      });\n    }\n  }\n\n  return withNeighborsList;\n};\n\nLNode.prototype.getNoOfChildren = function () {\n  var noOfChildren = 0;\n  var childNode;\n\n  if (this.child == null) {\n    noOfChildren = 1;\n  } else {\n    var nodes = this.child.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      childNode = nodes[i];\n\n      noOfChildren += childNode.getNoOfChildren();\n    }\n  }\n\n  if (noOfChildren == 0) {\n    noOfChildren = 1;\n  }\n  return noOfChildren;\n};\n\nLNode.prototype.getEstimatedSize = function () {\n  if (this.estimatedSize == Integer.MIN_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.estimatedSize;\n};\n\nLNode.prototype.calcEstimatedSize = function () {\n  if (this.child == null) {\n    return this.estimatedSize = (this.rect.width + this.rect.height) / 2;\n  } else {\n    this.estimatedSize = this.child.calcEstimatedSize();\n    this.rect.width = this.estimatedSize;\n    this.rect.height = this.estimatedSize;\n\n    return this.estimatedSize;\n  }\n};\n\nLNode.prototype.scatter = function () {\n  var randomCenterX;\n  var randomCenterY;\n\n  var minX = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  var maxX = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  randomCenterX = LayoutConstants.WORLD_CENTER_X + RandomSeed.nextDouble() * (maxX - minX) + minX;\n\n  var minY = -LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  var maxY = LayoutConstants.INITIAL_WORLD_BOUNDARY;\n  randomCenterY = LayoutConstants.WORLD_CENTER_Y + RandomSeed.nextDouble() * (maxY - minY) + minY;\n\n  this.rect.x = randomCenterX;\n  this.rect.y = randomCenterY;\n};\n\nLNode.prototype.updateBounds = function () {\n  if (this.getChild() == null) {\n    throw \"assert failed\";\n  }\n  if (this.getChild().getNodes().length != 0) {\n    // wrap the children nodes by re-arranging the boundaries\n    var childGraph = this.getChild();\n    childGraph.updateBounds(true);\n\n    this.rect.x = childGraph.getLeft();\n    this.rect.y = childGraph.getTop();\n\n    this.setWidth(childGraph.getRight() - childGraph.getLeft());\n    this.setHeight(childGraph.getBottom() - childGraph.getTop());\n\n    // Update compound bounds considering its label properties    \n    if (LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {\n\n      var width = childGraph.getRight() - childGraph.getLeft();\n      var height = childGraph.getBottom() - childGraph.getTop();\n\n      if (this.labelWidth) {\n        if (this.labelPosHorizontal == \"left\") {\n          this.rect.x -= this.labelWidth;\n          this.setWidth(width + this.labelWidth);\n        } else if (this.labelPosHorizontal == \"center\" && this.labelWidth > width) {\n          this.rect.x -= (this.labelWidth - width) / 2;\n          this.setWidth(this.labelWidth);\n        } else if (this.labelPosHorizontal == \"right\") {\n          this.setWidth(width + this.labelWidth);\n        }\n      }\n\n      if (this.labelHeight) {\n        if (this.labelPosVertical == \"top\") {\n          this.rect.y -= this.labelHeight;\n          this.setHeight(height + this.labelHeight);\n        } else if (this.labelPosVertical == \"center\" && this.labelHeight > height) {\n          this.rect.y -= (this.labelHeight - height) / 2;\n          this.setHeight(this.labelHeight);\n        } else if (this.labelPosVertical == \"bottom\") {\n          this.setHeight(height + this.labelHeight);\n        }\n      }\n    }\n  }\n};\n\nLNode.prototype.getInclusionTreeDepth = function () {\n  if (this.inclusionTreeDepth == Integer.MAX_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.inclusionTreeDepth;\n};\n\nLNode.prototype.transform = function (trans) {\n  var left = this.rect.x;\n\n  if (left > LayoutConstants.WORLD_BOUNDARY) {\n    left = LayoutConstants.WORLD_BOUNDARY;\n  } else if (left < -LayoutConstants.WORLD_BOUNDARY) {\n    left = -LayoutConstants.WORLD_BOUNDARY;\n  }\n\n  var top = this.rect.y;\n\n  if (top > LayoutConstants.WORLD_BOUNDARY) {\n    top = LayoutConstants.WORLD_BOUNDARY;\n  } else if (top < -LayoutConstants.WORLD_BOUNDARY) {\n    top = -LayoutConstants.WORLD_BOUNDARY;\n  }\n\n  var leftTop = new PointD(left, top);\n  var vLeftTop = trans.inverseTransformPoint(leftTop);\n\n  this.setLocation(vLeftTop.x, vLeftTop.y);\n};\n\nLNode.prototype.getLeft = function () {\n  return this.rect.x;\n};\n\nLNode.prototype.getRight = function () {\n  return this.rect.x + this.rect.width;\n};\n\nLNode.prototype.getTop = function () {\n  return this.rect.y;\n};\n\nLNode.prototype.getBottom = function () {\n  return this.rect.y + this.rect.height;\n};\n\nLNode.prototype.getParent = function () {\n  if (this.owner == null) {\n    return null;\n  }\n\n  return this.owner.getParent();\n};\n\nmodule.exports = LNode;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __nested_webpack_require_17290__) {\n\n\"use strict\";\n\n\nvar LayoutConstants = __nested_webpack_require_17290__(0);\n\nfunction FDLayoutConstants() {}\n\n//FDLayoutConstants inherits static props in LayoutConstants\nfor (var prop in LayoutConstants) {\n  FDLayoutConstants[prop] = LayoutConstants[prop];\n}\n\nFDLayoutConstants.MAX_ITERATIONS = 2500;\n\nFDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;\nFDLayoutConstants.DEFAULT_SPRING_STRENGTH = 0.45;\nFDLayoutConstants.DEFAULT_REPULSION_STRENGTH = 4500.0;\nFDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = 0.4;\nFDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1.0;\nFDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8;\nFDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5;\nFDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = true;\nFDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = true;\nFDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = 0.3;\nFDLayoutConstants.COOLING_ADAPTATION_FACTOR = 0.33;\nFDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT = 1000;\nFDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT = 5000;\nFDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100.0;\nFDLayoutConstants.MAX_NODE_DISPLACEMENT = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL * 3;\nFDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;\nFDLayoutConstants.CONVERGENCE_CHECK_PERIOD = 100;\nFDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = 0.1;\nFDLayoutConstants.MIN_EDGE_LENGTH = 1;\nFDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD = 10;\n\nmodule.exports = FDLayoutConstants;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction PointD(x, y) {\n  if (x == null && y == null) {\n    this.x = 0;\n    this.y = 0;\n  } else {\n    this.x = x;\n    this.y = y;\n  }\n}\n\nPointD.prototype.getX = function () {\n  return this.x;\n};\n\nPointD.prototype.getY = function () {\n  return this.y;\n};\n\nPointD.prototype.setX = function (x) {\n  this.x = x;\n};\n\nPointD.prototype.setY = function (y) {\n  this.y = y;\n};\n\nPointD.prototype.getDifference = function (pt) {\n  return new DimensionD(this.x - pt.x, this.y - pt.y);\n};\n\nPointD.prototype.getCopy = function () {\n  return new PointD(this.x, this.y);\n};\n\nPointD.prototype.translate = function (dim) {\n  this.x += dim.width;\n  this.y += dim.height;\n  return this;\n};\n\nmodule.exports = PointD;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __nested_webpack_require_19670__) {\n\n\"use strict\";\n\n\nvar LGraphObject = __nested_webpack_require_19670__(2);\nvar Integer = __nested_webpack_require_19670__(10);\nvar LayoutConstants = __nested_webpack_require_19670__(0);\nvar LGraphManager = __nested_webpack_require_19670__(7);\nvar LNode = __nested_webpack_require_19670__(3);\nvar LEdge = __nested_webpack_require_19670__(1);\nvar RectangleD = __nested_webpack_require_19670__(13);\nvar Point = __nested_webpack_require_19670__(12);\nvar LinkedList = __nested_webpack_require_19670__(11);\n\nfunction LGraph(parent, obj2, vGraph) {\n  LGraphObject.call(this, vGraph);\n  this.estimatedSize = Integer.MIN_VALUE;\n  this.margin = LayoutConstants.DEFAULT_GRAPH_MARGIN;\n  this.edges = [];\n  this.nodes = [];\n  this.isConnected = false;\n  this.parent = parent;\n\n  if (obj2 != null && obj2 instanceof LGraphManager) {\n    this.graphManager = obj2;\n  } else if (obj2 != null && obj2 instanceof Layout) {\n    this.graphManager = obj2.graphManager;\n  }\n}\n\nLGraph.prototype = Object.create(LGraphObject.prototype);\nfor (var prop in LGraphObject) {\n  LGraph[prop] = LGraphObject[prop];\n}\n\nLGraph.prototype.getNodes = function () {\n  return this.nodes;\n};\n\nLGraph.prototype.getEdges = function () {\n  return this.edges;\n};\n\nLGraph.prototype.getGraphManager = function () {\n  return this.graphManager;\n};\n\nLGraph.prototype.getParent = function () {\n  return this.parent;\n};\n\nLGraph.prototype.getLeft = function () {\n  return this.left;\n};\n\nLGraph.prototype.getRight = function () {\n  return this.right;\n};\n\nLGraph.prototype.getTop = function () {\n  return this.top;\n};\n\nLGraph.prototype.getBottom = function () {\n  return this.bottom;\n};\n\nLGraph.prototype.isConnected = function () {\n  return this.isConnected;\n};\n\nLGraph.prototype.add = function (obj1, sourceNode, targetNode) {\n  if (sourceNode == null && targetNode == null) {\n    var newNode = obj1;\n    if (this.graphManager == null) {\n      throw \"Graph has no graph mgr!\";\n    }\n    if (this.getNodes().indexOf(newNode) > -1) {\n      throw \"Node already in graph!\";\n    }\n    newNode.owner = this;\n    this.getNodes().push(newNode);\n\n    return newNode;\n  } else {\n    var newEdge = obj1;\n    if (!(this.getNodes().indexOf(sourceNode) > -1 && this.getNodes().indexOf(targetNode) > -1)) {\n      throw \"Source or target not in graph!\";\n    }\n\n    if (!(sourceNode.owner == targetNode.owner && sourceNode.owner == this)) {\n      throw \"Both owners must be this graph!\";\n    }\n\n    if (sourceNode.owner != targetNode.owner) {\n      return null;\n    }\n\n    // set source and target\n    newEdge.source = sourceNode;\n    newEdge.target = targetNode;\n\n    // set as intra-graph edge\n    newEdge.isInterGraph = false;\n\n    // add to graph edge list\n    this.getEdges().push(newEdge);\n\n    // add to incidency lists\n    sourceNode.edges.push(newEdge);\n\n    if (targetNode != sourceNode) {\n      targetNode.edges.push(newEdge);\n    }\n\n    return newEdge;\n  }\n};\n\nLGraph.prototype.remove = function (obj) {\n  var node = obj;\n  if (obj instanceof LNode) {\n    if (node == null) {\n      throw \"Node is null!\";\n    }\n    if (!(node.owner != null && node.owner == this)) {\n      throw \"Owner graph is invalid!\";\n    }\n    if (this.graphManager == null) {\n      throw \"Owner graph manager is invalid!\";\n    }\n    // remove incident edges first (make a copy to do it safely)\n    var edgesToBeRemoved = node.edges.slice();\n    var edge;\n    var s = edgesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      edge = edgesToBeRemoved[i];\n\n      if (edge.isInterGraph) {\n        this.graphManager.remove(edge);\n      } else {\n        edge.source.owner.remove(edge);\n      }\n    }\n\n    // now the node itself\n    var index = this.nodes.indexOf(node);\n    if (index == -1) {\n      throw \"Node not in owner node list!\";\n    }\n\n    this.nodes.splice(index, 1);\n  } else if (obj instanceof LEdge) {\n    var edge = obj;\n    if (edge == null) {\n      throw \"Edge is null!\";\n    }\n    if (!(edge.source != null && edge.target != null)) {\n      throw \"Source and/or target is null!\";\n    }\n    if (!(edge.source.owner != null && edge.target.owner != null && edge.source.owner == this && edge.target.owner == this)) {\n      throw \"Source and/or target owner is invalid!\";\n    }\n\n    var sourceIndex = edge.source.edges.indexOf(edge);\n    var targetIndex = edge.target.edges.indexOf(edge);\n    if (!(sourceIndex > -1 && targetIndex > -1)) {\n      throw \"Source and/or target doesn't know this edge!\";\n    }\n\n    edge.source.edges.splice(sourceIndex, 1);\n\n    if (edge.target != edge.source) {\n      edge.target.edges.splice(targetIndex, 1);\n    }\n\n    var index = edge.source.owner.getEdges().indexOf(edge);\n    if (index == -1) {\n      throw \"Not in owner's edge list!\";\n    }\n\n    edge.source.owner.getEdges().splice(index, 1);\n  }\n};\n\nLGraph.prototype.updateLeftTop = function () {\n  var top = Integer.MAX_VALUE;\n  var left = Integer.MAX_VALUE;\n  var nodeTop;\n  var nodeLeft;\n  var margin;\n\n  var nodes = this.getNodes();\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    nodeTop = lNode.getTop();\n    nodeLeft = lNode.getLeft();\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n  }\n\n  // Do we have any nodes in this graph?\n  if (top == Integer.MAX_VALUE) {\n    return null;\n  }\n\n  if (nodes[0].getParent().paddingLeft != undefined) {\n    margin = nodes[0].getParent().paddingLeft;\n  } else {\n    margin = this.margin;\n  }\n\n  this.left = left - margin;\n  this.top = top - margin;\n\n  // Apply the margins and return the result\n  return new Point(this.left, this.top);\n};\n\nLGraph.prototype.updateBounds = function (recursive) {\n  // calculate bounds\n  var left = Integer.MAX_VALUE;\n  var right = -Integer.MAX_VALUE;\n  var top = Integer.MAX_VALUE;\n  var bottom = -Integer.MAX_VALUE;\n  var nodeLeft;\n  var nodeRight;\n  var nodeTop;\n  var nodeBottom;\n  var margin;\n\n  var nodes = this.nodes;\n  var s = nodes.length;\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n\n    if (recursive && lNode.child != null) {\n      lNode.updateBounds();\n    }\n    nodeLeft = lNode.getLeft();\n    nodeRight = lNode.getRight();\n    nodeTop = lNode.getTop();\n    nodeBottom = lNode.getBottom();\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight) {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom) {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n  if (left == Integer.MAX_VALUE) {\n    this.left = this.parent.getLeft();\n    this.right = this.parent.getRight();\n    this.top = this.parent.getTop();\n    this.bottom = this.parent.getBottom();\n  }\n\n  if (nodes[0].getParent().paddingLeft != undefined) {\n    margin = nodes[0].getParent().paddingLeft;\n  } else {\n    margin = this.margin;\n  }\n\n  this.left = boundingRect.x - margin;\n  this.right = boundingRect.x + boundingRect.width + margin;\n  this.top = boundingRect.y - margin;\n  this.bottom = boundingRect.y + boundingRect.height + margin;\n};\n\nLGraph.calculateBounds = function (nodes) {\n  var left = Integer.MAX_VALUE;\n  var right = -Integer.MAX_VALUE;\n  var top = Integer.MAX_VALUE;\n  var bottom = -Integer.MAX_VALUE;\n  var nodeLeft;\n  var nodeRight;\n  var nodeTop;\n  var nodeBottom;\n\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    nodeLeft = lNode.getLeft();\n    nodeRight = lNode.getRight();\n    nodeTop = lNode.getTop();\n    nodeBottom = lNode.getBottom();\n\n    if (left > nodeLeft) {\n      left = nodeLeft;\n    }\n\n    if (right < nodeRight) {\n      right = nodeRight;\n    }\n\n    if (top > nodeTop) {\n      top = nodeTop;\n    }\n\n    if (bottom < nodeBottom) {\n      bottom = nodeBottom;\n    }\n  }\n\n  var boundingRect = new RectangleD(left, top, right - left, bottom - top);\n\n  return boundingRect;\n};\n\nLGraph.prototype.getInclusionTreeDepth = function () {\n  if (this == this.graphManager.getRoot()) {\n    return 1;\n  } else {\n    return this.parent.getInclusionTreeDepth();\n  }\n};\n\nLGraph.prototype.getEstimatedSize = function () {\n  if (this.estimatedSize == Integer.MIN_VALUE) {\n    throw \"assert failed\";\n  }\n  return this.estimatedSize;\n};\n\nLGraph.prototype.calcEstimatedSize = function () {\n  var size = 0;\n  var nodes = this.nodes;\n  var s = nodes.length;\n\n  for (var i = 0; i < s; i++) {\n    var lNode = nodes[i];\n    size += lNode.calcEstimatedSize();\n  }\n\n  if (size == 0) {\n    this.estimatedSize = LayoutConstants.EMPTY_COMPOUND_NODE_SIZE;\n  } else {\n    this.estimatedSize = size / Math.sqrt(this.nodes.length);\n  }\n\n  return this.estimatedSize;\n};\n\nLGraph.prototype.updateConnected = function () {\n  var self = this;\n  if (this.nodes.length == 0) {\n    this.isConnected = true;\n    return;\n  }\n\n  var queue = new LinkedList();\n  var visited = new Set();\n  var currentNode = this.nodes[0];\n  var neighborEdges;\n  var currentNeighbor;\n  var childrenOfNode = currentNode.withChildren();\n  childrenOfNode.forEach(function (node) {\n    queue.push(node);\n    visited.add(node);\n  });\n\n  while (queue.length !== 0) {\n    currentNode = queue.shift();\n\n    // Traverse all neighbors of this node\n    neighborEdges = currentNode.getEdges();\n    var size = neighborEdges.length;\n    for (var i = 0; i < size; i++) {\n      var neighborEdge = neighborEdges[i];\n      currentNeighbor = neighborEdge.getOtherEndInGraph(currentNode, this);\n\n      // Add unvisited neighbors to the list to visit\n      if (currentNeighbor != null && !visited.has(currentNeighbor)) {\n        var childrenOfNeighbor = currentNeighbor.withChildren();\n\n        childrenOfNeighbor.forEach(function (node) {\n          queue.push(node);\n          visited.add(node);\n        });\n      }\n    }\n  }\n\n  this.isConnected = false;\n\n  if (visited.size >= this.nodes.length) {\n    var noOfVisitedInThisGraph = 0;\n\n    visited.forEach(function (visitedNode) {\n      if (visitedNode.owner == self) {\n        noOfVisitedInThisGraph++;\n      }\n    });\n\n    if (noOfVisitedInThisGraph == this.nodes.length) {\n      this.isConnected = true;\n    }\n  }\n};\n\nmodule.exports = LGraph;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __nested_webpack_require_29738__) {\n\n\"use strict\";\n\n\nvar LGraph;\nvar LEdge = __nested_webpack_require_29738__(1);\n\nfunction LGraphManager(layout) {\n  LGraph = __nested_webpack_require_29738__(6); // It may be better to initilize this out of this function but it gives an error (Right-hand side of 'instanceof' is not callable) now.\n  this.layout = layout;\n\n  this.graphs = [];\n  this.edges = [];\n}\n\nLGraphManager.prototype.addRoot = function () {\n  var ngraph = this.layout.newGraph();\n  var nnode = this.layout.newNode(null);\n  var root = this.add(ngraph, nnode);\n  this.setRootGraph(root);\n  return this.rootGraph;\n};\n\nLGraphManager.prototype.add = function (newGraph, parentNode, newEdge, sourceNode, targetNode) {\n  //there are just 2 parameters are passed then it adds an LGraph else it adds an LEdge\n  if (newEdge == null && sourceNode == null && targetNode == null) {\n    if (newGraph == null) {\n      throw \"Graph is null!\";\n    }\n    if (parentNode == null) {\n      throw \"Parent node is null!\";\n    }\n    if (this.graphs.indexOf(newGraph) > -1) {\n      throw \"Graph already in this graph mgr!\";\n    }\n\n    this.graphs.push(newGraph);\n\n    if (newGraph.parent != null) {\n      throw \"Already has a parent!\";\n    }\n    if (parentNode.child != null) {\n      throw \"Already has a child!\";\n    }\n\n    newGraph.parent = parentNode;\n    parentNode.child = newGraph;\n\n    return newGraph;\n  } else {\n    //change the order of the parameters\n    targetNode = newEdge;\n    sourceNode = parentNode;\n    newEdge = newGraph;\n    var sourceGraph = sourceNode.getOwner();\n    var targetGraph = targetNode.getOwner();\n\n    if (!(sourceGraph != null && sourceGraph.getGraphManager() == this)) {\n      throw \"Source not in this graph mgr!\";\n    }\n    if (!(targetGraph != null && targetGraph.getGraphManager() == this)) {\n      throw \"Target not in this graph mgr!\";\n    }\n\n    if (sourceGraph == targetGraph) {\n      newEdge.isInterGraph = false;\n      return sourceGraph.add(newEdge, sourceNode, targetNode);\n    } else {\n      newEdge.isInterGraph = true;\n\n      // set source and target\n      newEdge.source = sourceNode;\n      newEdge.target = targetNode;\n\n      // add edge to inter-graph edge list\n      if (this.edges.indexOf(newEdge) > -1) {\n        throw \"Edge already in inter-graph edge list!\";\n      }\n\n      this.edges.push(newEdge);\n\n      // add edge to source and target incidency lists\n      if (!(newEdge.source != null && newEdge.target != null)) {\n        throw \"Edge source and/or target is null!\";\n      }\n\n      if (!(newEdge.source.edges.indexOf(newEdge) == -1 && newEdge.target.edges.indexOf(newEdge) == -1)) {\n        throw \"Edge already in source and/or target incidency list!\";\n      }\n\n      newEdge.source.edges.push(newEdge);\n      newEdge.target.edges.push(newEdge);\n\n      return newEdge;\n    }\n  }\n};\n\nLGraphManager.prototype.remove = function (lObj) {\n  if (lObj instanceof LGraph) {\n    var graph = lObj;\n    if (graph.getGraphManager() != this) {\n      throw \"Graph not in this graph mgr\";\n    }\n    if (!(graph == this.rootGraph || graph.parent != null && graph.parent.graphManager == this)) {\n      throw \"Invalid parent node!\";\n    }\n\n    // first the edges (make a copy to do it safely)\n    var edgesToBeRemoved = [];\n\n    edgesToBeRemoved = edgesToBeRemoved.concat(graph.getEdges());\n\n    var edge;\n    var s = edgesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      edge = edgesToBeRemoved[i];\n      graph.remove(edge);\n    }\n\n    // then the nodes (make a copy to do it safely)\n    var nodesToBeRemoved = [];\n\n    nodesToBeRemoved = nodesToBeRemoved.concat(graph.getNodes());\n\n    var node;\n    s = nodesToBeRemoved.length;\n    for (var i = 0; i < s; i++) {\n      node = nodesToBeRemoved[i];\n      graph.remove(node);\n    }\n\n    // check if graph is the root\n    if (graph == this.rootGraph) {\n      this.setRootGraph(null);\n    }\n\n    // now remove the graph itself\n    var index = this.graphs.indexOf(graph);\n    this.graphs.splice(index, 1);\n\n    // also reset the parent of the graph\n    graph.parent = null;\n  } else if (lObj instanceof LEdge) {\n    edge = lObj;\n    if (edge == null) {\n      throw \"Edge is null!\";\n    }\n    if (!edge.isInterGraph) {\n      throw \"Not an inter-graph edge!\";\n    }\n    if (!(edge.source != null && edge.target != null)) {\n      throw \"Source and/or target is null!\";\n    }\n\n    // remove edge from source and target nodes' incidency lists\n\n    if (!(edge.source.edges.indexOf(edge) != -1 && edge.target.edges.indexOf(edge) != -1)) {\n      throw \"Source and/or target doesn't know this edge!\";\n    }\n\n    var index = edge.source.edges.indexOf(edge);\n    edge.source.edges.splice(index, 1);\n    index = edge.target.edges.indexOf(edge);\n    edge.target.edges.splice(index, 1);\n\n    // remove edge from owner graph manager's inter-graph edge list\n\n    if (!(edge.source.owner != null && edge.source.owner.getGraphManager() != null)) {\n      throw \"Edge owner graph or owner graph manager is null!\";\n    }\n    if (edge.source.owner.getGraphManager().edges.indexOf(edge) == -1) {\n      throw \"Not in owner graph manager's edge list!\";\n    }\n\n    var index = edge.source.owner.getGraphManager().edges.indexOf(edge);\n    edge.source.owner.getGraphManager().edges.splice(index, 1);\n  }\n};\n\nLGraphManager.prototype.updateBounds = function () {\n  this.rootGraph.updateBounds(true);\n};\n\nLGraphManager.prototype.getGraphs = function () {\n  return this.graphs;\n};\n\nLGraphManager.prototype.getAllNodes = function () {\n  if (this.allNodes == null) {\n    var nodeList = [];\n    var graphs = this.getGraphs();\n    var s = graphs.length;\n    for (var i = 0; i < s; i++) {\n      nodeList = nodeList.concat(graphs[i].getNodes());\n    }\n    this.allNodes = nodeList;\n  }\n  return this.allNodes;\n};\n\nLGraphManager.prototype.resetAllNodes = function () {\n  this.allNodes = null;\n};\n\nLGraphManager.prototype.resetAllEdges = function () {\n  this.allEdges = null;\n};\n\nLGraphManager.prototype.resetAllNodesToApplyGravitation = function () {\n  this.allNodesToApplyGravitation = null;\n};\n\nLGraphManager.prototype.getAllEdges = function () {\n  if (this.allEdges == null) {\n    var edgeList = [];\n    var graphs = this.getGraphs();\n    var s = graphs.length;\n    for (var i = 0; i < graphs.length; i++) {\n      edgeList = edgeList.concat(graphs[i].getEdges());\n    }\n\n    edgeList = edgeList.concat(this.edges);\n\n    this.allEdges = edgeList;\n  }\n  return this.allEdges;\n};\n\nLGraphManager.prototype.getAllNodesToApplyGravitation = function () {\n  return this.allNodesToApplyGravitation;\n};\n\nLGraphManager.prototype.setAllNodesToApplyGravitation = function (nodeList) {\n  if (this.allNodesToApplyGravitation != null) {\n    throw \"assert failed\";\n  }\n\n  this.allNodesToApplyGravitation = nodeList;\n};\n\nLGraphManager.prototype.getRoot = function () {\n  return this.rootGraph;\n};\n\nLGraphManager.prototype.setRootGraph = function (graph) {\n  if (graph.getGraphManager() != this) {\n    throw \"Root not in this graph mgr!\";\n  }\n\n  this.rootGraph = graph;\n  // root graph must have a root node associated with it for convenience\n  if (graph.parent == null) {\n    graph.parent = this.layout.newNode(\"Root node\");\n  }\n};\n\nLGraphManager.prototype.getLayout = function () {\n  return this.layout;\n};\n\nLGraphManager.prototype.isOneAncestorOfOther = function (firstNode, secondNode) {\n  if (!(firstNode != null && secondNode != null)) {\n    throw \"assert failed\";\n  }\n\n  if (firstNode == secondNode) {\n    return true;\n  }\n  // Is second node an ancestor of the first one?\n  var ownerGraph = firstNode.getOwner();\n  var parentNode;\n\n  do {\n    parentNode = ownerGraph.getParent();\n\n    if (parentNode == null) {\n      break;\n    }\n\n    if (parentNode == secondNode) {\n      return true;\n    }\n\n    ownerGraph = parentNode.getOwner();\n    if (ownerGraph == null) {\n      break;\n    }\n  } while (true);\n  // Is first node an ancestor of the second one?\n  ownerGraph = secondNode.getOwner();\n\n  do {\n    parentNode = ownerGraph.getParent();\n\n    if (parentNode == null) {\n      break;\n    }\n\n    if (parentNode == firstNode) {\n      return true;\n    }\n\n    ownerGraph = parentNode.getOwner();\n    if (ownerGraph == null) {\n      break;\n    }\n  } while (true);\n\n  return false;\n};\n\nLGraphManager.prototype.calcLowestCommonAncestors = function () {\n  var edge;\n  var sourceNode;\n  var targetNode;\n  var sourceAncestorGraph;\n  var targetAncestorGraph;\n\n  var edges = this.getAllEdges();\n  var s = edges.length;\n  for (var i = 0; i < s; i++) {\n    edge = edges[i];\n\n    sourceNode = edge.source;\n    targetNode = edge.target;\n    edge.lca = null;\n    edge.sourceInLca = sourceNode;\n    edge.targetInLca = targetNode;\n\n    if (sourceNode == targetNode) {\n      edge.lca = sourceNode.getOwner();\n      continue;\n    }\n\n    sourceAncestorGraph = sourceNode.getOwner();\n\n    while (edge.lca == null) {\n      edge.targetInLca = targetNode;\n      targetAncestorGraph = targetNode.getOwner();\n\n      while (edge.lca == null) {\n        if (targetAncestorGraph == sourceAncestorGraph) {\n          edge.lca = targetAncestorGraph;\n          break;\n        }\n\n        if (targetAncestorGraph == this.rootGraph) {\n          break;\n        }\n\n        if (edge.lca != null) {\n          throw \"assert failed\";\n        }\n        edge.targetInLca = targetAncestorGraph.getParent();\n        targetAncestorGraph = edge.targetInLca.getOwner();\n      }\n\n      if (sourceAncestorGraph == this.rootGraph) {\n        break;\n      }\n\n      if (edge.lca == null) {\n        edge.sourceInLca = sourceAncestorGraph.getParent();\n        sourceAncestorGraph = edge.sourceInLca.getOwner();\n      }\n    }\n\n    if (edge.lca == null) {\n      throw \"assert failed\";\n    }\n  }\n};\n\nLGraphManager.prototype.calcLowestCommonAncestor = function (firstNode, secondNode) {\n  if (firstNode == secondNode) {\n    return firstNode.getOwner();\n  }\n  var firstOwnerGraph = firstNode.getOwner();\n\n  do {\n    if (firstOwnerGraph == null) {\n      break;\n    }\n    var secondOwnerGraph = secondNode.getOwner();\n\n    do {\n      if (secondOwnerGraph == null) {\n        break;\n      }\n\n      if (secondOwnerGraph == firstOwnerGraph) {\n        return secondOwnerGraph;\n      }\n      secondOwnerGraph = secondOwnerGraph.getParent().getOwner();\n    } while (true);\n\n    firstOwnerGraph = firstOwnerGraph.getParent().getOwner();\n  } while (true);\n\n  return firstOwnerGraph;\n};\n\nLGraphManager.prototype.calcInclusionTreeDepths = function (graph, depth) {\n  if (graph == null && depth == null) {\n    graph = this.rootGraph;\n    depth = 1;\n  }\n  var node;\n\n  var nodes = graph.getNodes();\n  var s = nodes.length;\n  for (var i = 0; i < s; i++) {\n    node = nodes[i];\n    node.inclusionTreeDepth = depth;\n\n    if (node.child != null) {\n      this.calcInclusionTreeDepths(node.child, depth + 1);\n    }\n  }\n};\n\nLGraphManager.prototype.includesInvalidEdge = function () {\n  var edge;\n  var edgesToRemove = [];\n\n  var s = this.edges.length;\n  for (var i = 0; i < s; i++) {\n    edge = this.edges[i];\n\n    if (this.isOneAncestorOfOther(edge.source, edge.target)) {\n      edgesToRemove.push(edge);\n    }\n  }\n\n  // Remove invalid edges from graph manager\n  for (var i = 0; i < edgesToRemove.length; i++) {\n    this.remove(edgesToRemove[i]);\n  }\n\n  // Invalid edges are cleared, so return false\n  return false;\n};\n\nmodule.exports = LGraphManager;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __nested_webpack_require_41052__) {\n\n\"use strict\";\n\n\n/**\n * This class maintains a list of static geometry related utility methods.\n *\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar Point = __nested_webpack_require_41052__(12);\n\nfunction IGeometry() {}\n\n/**\n * This method calculates *half* the amount in x and y directions of the two\n * input rectangles needed to separate them keeping their respective\n * positioning, and returns the result in the input array. An input\n * separation buffer added to the amount in both directions. We assume that\n * the two rectangles do intersect.\n */\nIGeometry.calcSeparationAmount = function (rectA, rectB, overlapAmount, separationBuffer) {\n  if (!rectA.intersects(rectB)) {\n    throw \"assert failed\";\n  }\n\n  var directions = new Array(2);\n\n  this.decideDirectionsForOverlappingNodes(rectA, rectB, directions);\n\n  overlapAmount[0] = Math.min(rectA.getRight(), rectB.getRight()) - Math.max(rectA.x, rectB.x);\n  overlapAmount[1] = Math.min(rectA.getBottom(), rectB.getBottom()) - Math.max(rectA.y, rectB.y);\n\n  // update the overlapping amounts for the following cases:\n  if (rectA.getX() <= rectB.getX() && rectA.getRight() >= rectB.getRight()) {\n    /* Case x.1:\n    *\n    * rectA\n    * \t|                       |\n    * \t|        _________      |\n    * \t|        |       |      |\n    * \t|________|_______|______|\n    * \t\t\t |       |\n    *           |       |\n    *        rectB\n    */\n    overlapAmount[0] += Math.min(rectB.getX() - rectA.getX(), rectA.getRight() - rectB.getRight());\n  } else if (rectB.getX() <= rectA.getX() && rectB.getRight() >= rectA.getRight()) {\n    /* Case x.2:\n    *\n    * rectB\n    * \t|                       |\n    * \t|        _________      |\n    * \t|        |       |      |\n    * \t|________|_______|______|\n    * \t\t\t |       |\n    *           |       |\n    *        rectA\n    */\n    overlapAmount[0] += Math.min(rectA.getX() - rectB.getX(), rectB.getRight() - rectA.getRight());\n  }\n  if (rectA.getY() <= rectB.getY() && rectA.getBottom() >= rectB.getBottom()) {\n    /* Case y.1:\n     *          ________ rectA\n     *         |\n     *         |\n     *   ______|____  rectB\n     *         |    |\n     *         |    |\n     *   ______|____|\n     *         |\n     *         |\n     *         |________\n     *\n     */\n    overlapAmount[1] += Math.min(rectB.getY() - rectA.getY(), rectA.getBottom() - rectB.getBottom());\n  } else if (rectB.getY() <= rectA.getY() && rectB.getBottom() >= rectA.getBottom()) {\n    /* Case y.2:\n    *          ________ rectB\n    *         |\n    *         |\n    *   ______|____  rectA\n    *         |    |\n    *         |    |\n    *   ______|____|\n    *         |\n    *         |\n    *         |________\n    *\n    */\n    overlapAmount[1] += Math.min(rectA.getY() - rectB.getY(), rectB.getBottom() - rectA.getBottom());\n  }\n\n  // find slope of the line passes two centers\n  var slope = Math.abs((rectB.getCenterY() - rectA.getCenterY()) / (rectB.getCenterX() - rectA.getCenterX()));\n  // if centers are overlapped\n  if (rectB.getCenterY() === rectA.getCenterY() && rectB.getCenterX() === rectA.getCenterX()) {\n    // assume the slope is 1 (45 degree)\n    slope = 1.0;\n  }\n\n  var moveByY = slope * overlapAmount[0];\n  var moveByX = overlapAmount[1] / slope;\n  if (overlapAmount[0] < moveByX) {\n    moveByX = overlapAmount[0];\n  } else {\n    moveByY = overlapAmount[1];\n  }\n  // return half the amount so that if each rectangle is moved by these\n  // amounts in opposite directions, overlap will be resolved\n  overlapAmount[0] = -1 * directions[0] * (moveByX / 2 + separationBuffer);\n  overlapAmount[1] = -1 * directions[1] * (moveByY / 2 + separationBuffer);\n};\n\n/**\n * This method decides the separation direction of overlapping nodes\n *\n * if directions[0] = -1, then rectA goes left\n * if directions[0] = 1,  then rectA goes right\n * if directions[1] = -1, then rectA goes up\n * if directions[1] = 1,  then rectA goes down\n */\nIGeometry.decideDirectionsForOverlappingNodes = function (rectA, rectB, directions) {\n  if (rectA.getCenterX() < rectB.getCenterX()) {\n    directions[0] = -1;\n  } else {\n    directions[0] = 1;\n  }\n\n  if (rectA.getCenterY() < rectB.getCenterY()) {\n    directions[1] = -1;\n  } else {\n    directions[1] = 1;\n  }\n};\n\n/**\n * This method calculates the intersection (clipping) points of the two\n * input rectangles with line segment defined by the centers of these two\n * rectangles. The clipping points are saved in the input double array and\n * whether or not the two rectangles overlap is returned.\n */\nIGeometry.getIntersection2 = function (rectA, rectB, result) {\n  //result[0-1] will contain clipPoint of rectA, result[2-3] will contain clipPoint of rectB\n  var p1x = rectA.getCenterX();\n  var p1y = rectA.getCenterY();\n  var p2x = rectB.getCenterX();\n  var p2y = rectB.getCenterY();\n\n  //if two rectangles intersect, then clipping points are centers\n  if (rectA.intersects(rectB)) {\n    result[0] = p1x;\n    result[1] = p1y;\n    result[2] = p2x;\n    result[3] = p2y;\n    return true;\n  }\n  //variables for rectA\n  var topLeftAx = rectA.getX();\n  var topLeftAy = rectA.getY();\n  var topRightAx = rectA.getRight();\n  var bottomLeftAx = rectA.getX();\n  var bottomLeftAy = rectA.getBottom();\n  var bottomRightAx = rectA.getRight();\n  var halfWidthA = rectA.getWidthHalf();\n  var halfHeightA = rectA.getHeightHalf();\n  //variables for rectB\n  var topLeftBx = rectB.getX();\n  var topLeftBy = rectB.getY();\n  var topRightBx = rectB.getRight();\n  var bottomLeftBx = rectB.getX();\n  var bottomLeftBy = rectB.getBottom();\n  var bottomRightBx = rectB.getRight();\n  var halfWidthB = rectB.getWidthHalf();\n  var halfHeightB = rectB.getHeightHalf();\n\n  //flag whether clipping points are found\n  var clipPointAFound = false;\n  var clipPointBFound = false;\n\n  // line is vertical\n  if (p1x === p2x) {\n    if (p1y > p2y) {\n      result[0] = p1x;\n      result[1] = topLeftAy;\n      result[2] = p2x;\n      result[3] = bottomLeftBy;\n      return false;\n    } else if (p1y < p2y) {\n      result[0] = p1x;\n      result[1] = bottomLeftAy;\n      result[2] = p2x;\n      result[3] = topLeftBy;\n      return false;\n    } else {\n      //not line, return null;\n    }\n  }\n  // line is horizontal\n  else if (p1y === p2y) {\n      if (p1x > p2x) {\n        result[0] = topLeftAx;\n        result[1] = p1y;\n        result[2] = topRightBx;\n        result[3] = p2y;\n        return false;\n      } else if (p1x < p2x) {\n        result[0] = topRightAx;\n        result[1] = p1y;\n        result[2] = topLeftBx;\n        result[3] = p2y;\n        return false;\n      } else {\n        //not valid line, return null;\n      }\n    } else {\n      //slopes of rectA's and rectB's diagonals\n      var slopeA = rectA.height / rectA.width;\n      var slopeB = rectB.height / rectB.width;\n\n      //slope of line between center of rectA and center of rectB\n      var slopePrime = (p2y - p1y) / (p2x - p1x);\n      var cardinalDirectionA = void 0;\n      var cardinalDirectionB = void 0;\n      var tempPointAx = void 0;\n      var tempPointAy = void 0;\n      var tempPointBx = void 0;\n      var tempPointBy = void 0;\n\n      //determine whether clipping point is the corner of nodeA\n      if (-slopeA === slopePrime) {\n        if (p1x > p2x) {\n          result[0] = bottomLeftAx;\n          result[1] = bottomLeftAy;\n          clipPointAFound = true;\n        } else {\n          result[0] = topRightAx;\n          result[1] = topLeftAy;\n          clipPointAFound = true;\n        }\n      } else if (slopeA === slopePrime) {\n        if (p1x > p2x) {\n          result[0] = topLeftAx;\n          result[1] = topLeftAy;\n          clipPointAFound = true;\n        } else {\n          result[0] = bottomRightAx;\n          result[1] = bottomLeftAy;\n          clipPointAFound = true;\n        }\n      }\n\n      //determine whether clipping point is the corner of nodeB\n      if (-slopeB === slopePrime) {\n        if (p2x > p1x) {\n          result[2] = bottomLeftBx;\n          result[3] = bottomLeftBy;\n          clipPointBFound = true;\n        } else {\n          result[2] = topRightBx;\n          result[3] = topLeftBy;\n          clipPointBFound = true;\n        }\n      } else if (slopeB === slopePrime) {\n        if (p2x > p1x) {\n          result[2] = topLeftBx;\n          result[3] = topLeftBy;\n          clipPointBFound = true;\n        } else {\n          result[2] = bottomRightBx;\n          result[3] = bottomLeftBy;\n          clipPointBFound = true;\n        }\n      }\n\n      //if both clipping points are corners\n      if (clipPointAFound && clipPointBFound) {\n        return false;\n      }\n\n      //determine Cardinal Direction of rectangles\n      if (p1x > p2x) {\n        if (p1y > p2y) {\n          cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 4);\n          cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 2);\n        } else {\n          cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 3);\n          cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 1);\n        }\n      } else {\n        if (p1y > p2y) {\n          cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 1);\n          cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 3);\n        } else {\n          cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 2);\n          cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 4);\n        }\n      }\n      //calculate clipping Point if it is not found before\n      if (!clipPointAFound) {\n        switch (cardinalDirectionA) {\n          case 1:\n            tempPointAy = topLeftAy;\n            tempPointAx = p1x + -halfHeightA / slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 2:\n            tempPointAx = bottomRightAx;\n            tempPointAy = p1y + halfWidthA * slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 3:\n            tempPointAy = bottomLeftAy;\n            tempPointAx = p1x + halfHeightA / slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n          case 4:\n            tempPointAx = bottomLeftAx;\n            tempPointAy = p1y + -halfWidthA * slopePrime;\n            result[0] = tempPointAx;\n            result[1] = tempPointAy;\n            break;\n        }\n      }\n      if (!clipPointBFound) {\n        switch (cardinalDirectionB) {\n          case 1:\n            tempPointBy = topLeftBy;\n            tempPointBx = p2x + -halfHeightB / slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 2:\n            tempPointBx = bottomRightBx;\n            tempPointBy = p2y + halfWidthB * slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 3:\n            tempPointBy = bottomLeftBy;\n            tempPointBx = p2x + halfHeightB / slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n          case 4:\n            tempPointBx = bottomLeftBx;\n            tempPointBy = p2y + -halfWidthB * slopePrime;\n            result[2] = tempPointBx;\n            result[3] = tempPointBy;\n            break;\n        }\n      }\n    }\n  return false;\n};\n\n/**\n * This method returns in which cardinal direction does input point stays\n * 1: North\n * 2: East\n * 3: South\n * 4: West\n */\nIGeometry.getCardinalDirection = function (slope, slopePrime, line) {\n  if (slope > slopePrime) {\n    return line;\n  } else {\n    return 1 + line % 4;\n  }\n};\n\n/**\n * This method calculates the intersection of the two lines defined by\n * point pairs (s1,s2) and (f1,f2).\n */\nIGeometry.getIntersection = function (s1, s2, f1, f2) {\n  if (f2 == null) {\n    return this.getIntersection2(s1, s2, f1);\n  }\n\n  var x1 = s1.x;\n  var y1 = s1.y;\n  var x2 = s2.x;\n  var y2 = s2.y;\n  var x3 = f1.x;\n  var y3 = f1.y;\n  var x4 = f2.x;\n  var y4 = f2.y;\n  var x = void 0,\n      y = void 0; // intersection point\n  var a1 = void 0,\n      a2 = void 0,\n      b1 = void 0,\n      b2 = void 0,\n      c1 = void 0,\n      c2 = void 0; // coefficients of line eqns.\n  var denom = void 0;\n\n  a1 = y2 - y1;\n  b1 = x1 - x2;\n  c1 = x2 * y1 - x1 * y2; // { a1*x + b1*y + c1 = 0 is line 1 }\n\n  a2 = y4 - y3;\n  b2 = x3 - x4;\n  c2 = x4 * y3 - x3 * y4; // { a2*x + b2*y + c2 = 0 is line 2 }\n\n  denom = a1 * b2 - a2 * b1;\n\n  if (denom === 0) {\n    return null;\n  }\n\n  x = (b1 * c2 - b2 * c1) / denom;\n  y = (a2 * c1 - a1 * c2) / denom;\n\n  return new Point(x, y);\n};\n\n/**\n * This method finds and returns the angle of the vector from the + x-axis\n * in clockwise direction (compatible w/ Java coordinate system!).\n */\nIGeometry.angleOfVector = function (Cx, Cy, Nx, Ny) {\n  var C_angle = void 0;\n\n  if (Cx !== Nx) {\n    C_angle = Math.atan((Ny - Cy) / (Nx - Cx));\n\n    if (Nx < Cx) {\n      C_angle += Math.PI;\n    } else if (Ny < Cy) {\n      C_angle += this.TWO_PI;\n    }\n  } else if (Ny < Cy) {\n    C_angle = this.ONE_AND_HALF_PI; // 270 degrees\n  } else {\n    C_angle = this.HALF_PI; // 90 degrees\n  }\n\n  return C_angle;\n};\n\n/**\n * This method checks whether the given two line segments (one with point\n * p1 and p2, the other with point p3 and p4) intersect at a point other\n * than these points.\n */\nIGeometry.doIntersect = function (p1, p2, p3, p4) {\n  var a = p1.x;\n  var b = p1.y;\n  var c = p2.x;\n  var d = p2.y;\n  var p = p3.x;\n  var q = p3.y;\n  var r = p4.x;\n  var s = p4.y;\n  var det = (c - a) * (s - q) - (r - p) * (d - b);\n\n  if (det === 0) {\n    return false;\n  } else {\n    var lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;\n    var gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;\n    return 0 < lambda && lambda < 1 && 0 < gamma && gamma < 1;\n  }\n};\n\n/**\n * This method checks and calculates the intersection of \n * a line segment and a circle.\n */\nIGeometry.findCircleLineIntersections = function (Ex, Ey, Lx, Ly, Cx, Cy, r) {\n\n  // E is the starting point of the ray,\n  // L is the end point of the ray,\n  // C is the center of sphere you're testing against\n  // r is the radius of that sphere\n\n  // Compute:\n  // d = L - E ( Direction vector of ray, from start to end )\n  // f = E - C ( Vector from center sphere to ray start )\n\n  // Then the intersection is found by..\n  // P = E + t * d\n  // This is a parametric equation:\n  // Px = Ex + tdx\n  // Py = Ey + tdy\n\n  // get a, b, c values\n  var a = (Lx - Ex) * (Lx - Ex) + (Ly - Ey) * (Ly - Ey);\n  var b = 2 * ((Ex - Cx) * (Lx - Ex) + (Ey - Cy) * (Ly - Ey));\n  var c = (Ex - Cx) * (Ex - Cx) + (Ey - Cy) * (Ey - Cy) - r * r;\n\n  // get discriminant\n  var disc = b * b - 4 * a * c;\n  if (disc >= 0) {\n    // insert into quadratic formula\n    var t1 = (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);\n    var t2 = (-b - Math.sqrt(b * b - 4 * a * c)) / (2 * a);\n    var intersections = null;\n    if (t1 >= 0 && t1 <= 1) {\n      // t1 is the intersection, and it's closer than t2\n      // (since t1 uses -b - discriminant)\n      // Impale, Poke\n      return [t1];\n    }\n\n    // here t1 didn't intersect so we are either started\n    // inside the sphere or completely past it\n    if (t2 >= 0 && t2 <= 1) {\n      // ExitWound\n      return [t2];\n    }\n\n    return intersections;\n  } else return null;\n};\n\n// -----------------------------------------------------------------------------\n// Section: Class Constants\n// -----------------------------------------------------------------------------\n/**\n * Some useful pre-calculated constants\n */\nIGeometry.HALF_PI = 0.5 * Math.PI;\nIGeometry.ONE_AND_HALF_PI = 1.5 * Math.PI;\nIGeometry.TWO_PI = 2.0 * Math.PI;\nIGeometry.THREE_PI = 3.0 * Math.PI;\n\nmodule.exports = IGeometry;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction IMath() {}\n\n/**\n * This method returns the sign of the input value.\n */\nIMath.sign = function (value) {\n  if (value > 0) {\n    return 1;\n  } else if (value < 0) {\n    return -1;\n  } else {\n    return 0;\n  }\n};\n\nIMath.floor = function (value) {\n  return value < 0 ? Math.ceil(value) : Math.floor(value);\n};\n\nIMath.ceil = function (value) {\n  return value < 0 ? Math.floor(value) : Math.ceil(value);\n};\n\nmodule.exports = IMath;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction Integer() {}\n\nInteger.MAX_VALUE = 2147483647;\nInteger.MIN_VALUE = -2147483648;\n\nmodule.exports = Integer;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar nodeFrom = function nodeFrom(value) {\n  return { value: value, next: null, prev: null };\n};\n\nvar add = function add(prev, node, next, list) {\n  if (prev !== null) {\n    prev.next = node;\n  } else {\n    list.head = node;\n  }\n\n  if (next !== null) {\n    next.prev = node;\n  } else {\n    list.tail = node;\n  }\n\n  node.prev = prev;\n  node.next = next;\n\n  list.length++;\n\n  return node;\n};\n\nvar _remove = function _remove(node, list) {\n  var prev = node.prev,\n      next = node.next;\n\n\n  if (prev !== null) {\n    prev.next = next;\n  } else {\n    list.head = next;\n  }\n\n  if (next !== null) {\n    next.prev = prev;\n  } else {\n    list.tail = prev;\n  }\n\n  node.prev = node.next = null;\n\n  list.length--;\n\n  return node;\n};\n\nvar LinkedList = function () {\n  function LinkedList(vals) {\n    var _this = this;\n\n    _classCallCheck(this, LinkedList);\n\n    this.length = 0;\n    this.head = null;\n    this.tail = null;\n\n    if (vals != null) {\n      vals.forEach(function (v) {\n        return _this.push(v);\n      });\n    }\n  }\n\n  _createClass(LinkedList, [{\n    key: \"size\",\n    value: function size() {\n      return this.length;\n    }\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(val, otherNode) {\n      return add(otherNode.prev, nodeFrom(val), otherNode, this);\n    }\n  }, {\n    key: \"insertAfter\",\n    value: function insertAfter(val, otherNode) {\n      return add(otherNode, nodeFrom(val), otherNode.next, this);\n    }\n  }, {\n    key: \"insertNodeBefore\",\n    value: function insertNodeBefore(newNode, otherNode) {\n      return add(otherNode.prev, newNode, otherNode, this);\n    }\n  }, {\n    key: \"insertNodeAfter\",\n    value: function insertNodeAfter(newNode, otherNode) {\n      return add(otherNode, newNode, otherNode.next, this);\n    }\n  }, {\n    key: \"push\",\n    value: function push(val) {\n      return add(this.tail, nodeFrom(val), null, this);\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(val) {\n      return add(null, nodeFrom(val), this.head, this);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(node) {\n      return _remove(node, this);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      return _remove(this.tail, this).value;\n    }\n  }, {\n    key: \"popNode\",\n    value: function popNode() {\n      return _remove(this.tail, this);\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      return _remove(this.head, this).value;\n    }\n  }, {\n    key: \"shiftNode\",\n    value: function shiftNode() {\n      return _remove(this.head, this);\n    }\n  }, {\n    key: \"get_object_at\",\n    value: function get_object_at(index) {\n      if (index <= this.length()) {\n        var i = 1;\n        var current = this.head;\n        while (i < index) {\n          current = current.next;\n          i++;\n        }\n        return current.value;\n      }\n    }\n  }, {\n    key: \"set_object_at\",\n    value: function set_object_at(index, value) {\n      if (index <= this.length()) {\n        var i = 1;\n        var current = this.head;\n        while (i < index) {\n          current = current.next;\n          i++;\n        }\n        current.value = value;\n      }\n    }\n  }]);\n\n  return LinkedList;\n}();\n\nmodule.exports = LinkedList;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/*\r\n *This class is the javascript implementation of the Point.java class in jdk\r\n */\nfunction Point(x, y, p) {\n  this.x = null;\n  this.y = null;\n  if (x == null && y == null && p == null) {\n    this.x = 0;\n    this.y = 0;\n  } else if (typeof x == 'number' && typeof y == 'number' && p == null) {\n    this.x = x;\n    this.y = y;\n  } else if (x.constructor.name == 'Point' && y == null && p == null) {\n    p = x;\n    this.x = p.x;\n    this.y = p.y;\n  }\n}\n\nPoint.prototype.getX = function () {\n  return this.x;\n};\n\nPoint.prototype.getY = function () {\n  return this.y;\n};\n\nPoint.prototype.getLocation = function () {\n  return new Point(this.x, this.y);\n};\n\nPoint.prototype.setLocation = function (x, y, p) {\n  if (x.constructor.name == 'Point' && y == null && p == null) {\n    p = x;\n    this.setLocation(p.x, p.y);\n  } else if (typeof x == 'number' && typeof y == 'number' && p == null) {\n    //if both parameters are integer just move (x,y) location\n    if (parseInt(x) == x && parseInt(y) == y) {\n      this.move(x, y);\n    } else {\n      this.x = Math.floor(x + 0.5);\n      this.y = Math.floor(y + 0.5);\n    }\n  }\n};\n\nPoint.prototype.move = function (x, y) {\n  this.x = x;\n  this.y = y;\n};\n\nPoint.prototype.translate = function (dx, dy) {\n  this.x += dx;\n  this.y += dy;\n};\n\nPoint.prototype.equals = function (obj) {\n  if (obj.constructor.name == \"Point\") {\n    var pt = obj;\n    return this.x == pt.x && this.y == pt.y;\n  }\n  return this == obj;\n};\n\nPoint.prototype.toString = function () {\n  return new Point().constructor.name + \"[x=\" + this.x + \",y=\" + this.y + \"]\";\n};\n\nmodule.exports = Point;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction RectangleD(x, y, width, height) {\n  this.x = 0;\n  this.y = 0;\n  this.width = 0;\n  this.height = 0;\n\n  if (x != null && y != null && width != null && height != null) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n}\n\nRectangleD.prototype.getX = function () {\n  return this.x;\n};\n\nRectangleD.prototype.setX = function (x) {\n  this.x = x;\n};\n\nRectangleD.prototype.getY = function () {\n  return this.y;\n};\n\nRectangleD.prototype.setY = function (y) {\n  this.y = y;\n};\n\nRectangleD.prototype.getWidth = function () {\n  return this.width;\n};\n\nRectangleD.prototype.setWidth = function (width) {\n  this.width = width;\n};\n\nRectangleD.prototype.getHeight = function () {\n  return this.height;\n};\n\nRectangleD.prototype.setHeight = function (height) {\n  this.height = height;\n};\n\nRectangleD.prototype.getRight = function () {\n  return this.x + this.width;\n};\n\nRectangleD.prototype.getBottom = function () {\n  return this.y + this.height;\n};\n\nRectangleD.prototype.intersects = function (a) {\n  if (this.getRight() < a.x) {\n    return false;\n  }\n\n  if (this.getBottom() < a.y) {\n    return false;\n  }\n\n  if (a.getRight() < this.x) {\n    return false;\n  }\n\n  if (a.getBottom() < this.y) {\n    return false;\n  }\n\n  return true;\n};\n\nRectangleD.prototype.getCenterX = function () {\n  return this.x + this.width / 2;\n};\n\nRectangleD.prototype.getMinX = function () {\n  return this.getX();\n};\n\nRectangleD.prototype.getMaxX = function () {\n  return this.getX() + this.width;\n};\n\nRectangleD.prototype.getCenterY = function () {\n  return this.y + this.height / 2;\n};\n\nRectangleD.prototype.getMinY = function () {\n  return this.getY();\n};\n\nRectangleD.prototype.getMaxY = function () {\n  return this.getY() + this.height;\n};\n\nRectangleD.prototype.getWidthHalf = function () {\n  return this.width / 2;\n};\n\nRectangleD.prototype.getHeightHalf = function () {\n  return this.height / 2;\n};\n\nmodule.exports = RectangleD;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction UniqueIDGeneretor() {}\n\nUniqueIDGeneretor.lastID = 0;\n\nUniqueIDGeneretor.createID = function (obj) {\n  if (UniqueIDGeneretor.isPrimitive(obj)) {\n    return obj;\n  }\n  if (obj.uniqueID != null) {\n    return obj.uniqueID;\n  }\n  obj.uniqueID = UniqueIDGeneretor.getString();\n  UniqueIDGeneretor.lastID++;\n  return obj.uniqueID;\n};\n\nUniqueIDGeneretor.getString = function (id) {\n  if (id == null) id = UniqueIDGeneretor.lastID;\n  return \"Object#\" + id + \"\";\n};\n\nUniqueIDGeneretor.isPrimitive = function (arg) {\n  var type = typeof arg === \"undefined\" ? \"undefined\" : _typeof(arg);\n  return arg == null || type != \"object\" && type != \"function\";\n};\n\nmodule.exports = UniqueIDGeneretor;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __nested_webpack_require_66321__) {\n\n\"use strict\";\n\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar LayoutConstants = __nested_webpack_require_66321__(0);\nvar LGraphManager = __nested_webpack_require_66321__(7);\nvar LNode = __nested_webpack_require_66321__(3);\nvar LEdge = __nested_webpack_require_66321__(1);\nvar LGraph = __nested_webpack_require_66321__(6);\nvar PointD = __nested_webpack_require_66321__(5);\nvar Transform = __nested_webpack_require_66321__(17);\nvar Emitter = __nested_webpack_require_66321__(29);\n\nfunction Layout(isRemoteUse) {\n  Emitter.call(this);\n\n  //Layout Quality: 0:draft, 1:default, 2:proof\n  this.layoutQuality = LayoutConstants.QUALITY;\n  //Whether layout should create bendpoints as needed or not\n  this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n  //Whether layout should be incremental or not\n  this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n  //Whether we animate from before to after layout node positions\n  this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n  //Whether we animate the layout process or not\n  this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n  //Number iterations that should be done between two successive animations\n  this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n  /**\r\n   * Whether or not leaf nodes (non-compound nodes) are of uniform sizes. When\r\n   * they are, both spring and repulsion forces between two leaf nodes can be\r\n   * calculated without the expensive clipping point calculations, resulting\r\n   * in major speed-up.\r\n   */\n  this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n  /**\r\n   * This is used for creation of bendpoints by using dummy nodes and edges.\r\n   * Maps an LEdge to its dummy bendpoint path.\r\n   */\n  this.edgeToDummyNodes = new Map();\n  this.graphManager = new LGraphManager(this);\n  this.isLayoutFinished = false;\n  this.isSubLayout = false;\n  this.isRemoteUse = false;\n\n  if (isRemoteUse != null) {\n    this.isRemoteUse = isRemoteUse;\n  }\n}\n\nLayout.RANDOM_SEED = 1;\n\nLayout.prototype = Object.create(Emitter.prototype);\n\nLayout.prototype.getGraphManager = function () {\n  return this.graphManager;\n};\n\nLayout.prototype.getAllNodes = function () {\n  return this.graphManager.getAllNodes();\n};\n\nLayout.prototype.getAllEdges = function () {\n  return this.graphManager.getAllEdges();\n};\n\nLayout.prototype.getAllNodesToApplyGravitation = function () {\n  return this.graphManager.getAllNodesToApplyGravitation();\n};\n\nLayout.prototype.newGraphManager = function () {\n  var gm = new LGraphManager(this);\n  this.graphManager = gm;\n  return gm;\n};\n\nLayout.prototype.newGraph = function (vGraph) {\n  return new LGraph(null, this.graphManager, vGraph);\n};\n\nLayout.prototype.newNode = function (vNode) {\n  return new LNode(this.graphManager, vNode);\n};\n\nLayout.prototype.newEdge = function (vEdge) {\n  return new LEdge(null, null, vEdge);\n};\n\nLayout.prototype.checkLayoutSuccess = function () {\n  return this.graphManager.getRoot() == null || this.graphManager.getRoot().getNodes().length == 0 || this.graphManager.includesInvalidEdge();\n};\n\nLayout.prototype.runLayout = function () {\n  this.isLayoutFinished = false;\n\n  if (this.tilingPreLayout) {\n    this.tilingPreLayout();\n  }\n\n  this.initParameters();\n  var isLayoutSuccessfull;\n\n  if (this.checkLayoutSuccess()) {\n    isLayoutSuccessfull = false;\n  } else {\n    isLayoutSuccessfull = this.layout();\n  }\n\n  if (LayoutConstants.ANIMATE === 'during') {\n    // If this is a 'during' layout animation. Layout is not finished yet. \n    // We need to perform these in index.js when layout is really finished.\n    return false;\n  }\n\n  if (isLayoutSuccessfull) {\n    if (!this.isSubLayout) {\n      this.doPostLayout();\n    }\n  }\n\n  if (this.tilingPostLayout) {\n    this.tilingPostLayout();\n  }\n\n  this.isLayoutFinished = true;\n\n  return isLayoutSuccessfull;\n};\n\n/**\r\n * This method performs the operations required after layout.\r\n */\nLayout.prototype.doPostLayout = function () {\n  //assert !isSubLayout : \"Should not be called on sub-layout!\";\n  // Propagate geometric changes to v-level objects\n  if (!this.incremental) {\n    this.transform();\n  }\n  this.update();\n};\n\n/**\r\n * This method updates the geometry of the target graph according to\r\n * calculated layout.\r\n */\nLayout.prototype.update2 = function () {\n  // update bend points\n  if (this.createBendsAsNeeded) {\n    this.createBendpointsFromDummyNodes();\n\n    // reset all edges, since the topology has changed\n    this.graphManager.resetAllEdges();\n  }\n\n  // perform edge, node and root updates if layout is not called\n  // remotely\n  if (!this.isRemoteUse) {\n    // update all edges\n    var edge;\n    var allEdges = this.graphManager.getAllEdges();\n    for (var i = 0; i < allEdges.length; i++) {\n      edge = allEdges[i];\n      //      this.update(edge);\n    }\n\n    // recursively update nodes\n    var node;\n    var nodes = this.graphManager.getRoot().getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      node = nodes[i];\n      //      this.update(node);\n    }\n\n    // update root graph\n    this.update(this.graphManager.getRoot());\n  }\n};\n\nLayout.prototype.update = function (obj) {\n  if (obj == null) {\n    this.update2();\n  } else if (obj instanceof LNode) {\n    var node = obj;\n    if (node.getChild() != null) {\n      // since node is compound, recursively update child nodes\n      var nodes = node.getChild().getNodes();\n      for (var i = 0; i < nodes.length; i++) {\n        update(nodes[i]);\n      }\n    }\n\n    // if the l-level node is associated with a v-level graph object,\n    // then it is assumed that the v-level node implements the\n    // interface Updatable.\n    if (node.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vNode = node.vGraphObject;\n\n      // call the update method of the interface\n      vNode.update(node);\n    }\n  } else if (obj instanceof LEdge) {\n    var edge = obj;\n    // if the l-level edge is associated with a v-level graph object,\n    // then it is assumed that the v-level edge implements the\n    // interface Updatable.\n\n    if (edge.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vEdge = edge.vGraphObject;\n\n      // call the update method of the interface\n      vEdge.update(edge);\n    }\n  } else if (obj instanceof LGraph) {\n    var graph = obj;\n    // if the l-level graph is associated with a v-level graph object,\n    // then it is assumed that the v-level object implements the\n    // interface Updatable.\n\n    if (graph.vGraphObject != null) {\n      // cast to Updatable without any type check\n      var vGraph = graph.vGraphObject;\n\n      // call the update method of the interface\n      vGraph.update(graph);\n    }\n  }\n};\n\n/**\r\n * This method is used to set all layout parameters to default values\r\n * determined at compile time.\r\n */\nLayout.prototype.initParameters = function () {\n  if (!this.isSubLayout) {\n    this.layoutQuality = LayoutConstants.QUALITY;\n    this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;\n    this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;\n    this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;\n    this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;\n    this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;\n    this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;\n  }\n\n  if (this.animationDuringLayout) {\n    this.animationOnLayout = false;\n  }\n};\n\nLayout.prototype.transform = function (newLeftTop) {\n  if (newLeftTop == undefined) {\n    this.transform(new PointD(0, 0));\n  } else {\n    // create a transformation object (from Eclipse to layout). When an\n    // inverse transform is applied, we get upper-left coordinate of the\n    // drawing or the root graph at given input coordinate (some margins\n    // already included in calculation of left-top).\n\n    var trans = new Transform();\n    var leftTop = this.graphManager.getRoot().updateLeftTop();\n\n    if (leftTop != null) {\n      trans.setWorldOrgX(newLeftTop.x);\n      trans.setWorldOrgY(newLeftTop.y);\n\n      trans.setDeviceOrgX(leftTop.x);\n      trans.setDeviceOrgY(leftTop.y);\n\n      var nodes = this.getAllNodes();\n      var node;\n\n      for (var i = 0; i < nodes.length; i++) {\n        node = nodes[i];\n        node.transform(trans);\n      }\n    }\n  }\n};\n\nLayout.prototype.positionNodesRandomly = function (graph) {\n\n  if (graph == undefined) {\n    //assert !this.incremental;\n    this.positionNodesRandomly(this.getGraphManager().getRoot());\n    this.getGraphManager().getRoot().updateBounds(true);\n  } else {\n    var lNode;\n    var childGraph;\n\n    var nodes = graph.getNodes();\n    for (var i = 0; i < nodes.length; i++) {\n      lNode = nodes[i];\n      childGraph = lNode.getChild();\n\n      if (childGraph == null) {\n        lNode.scatter();\n      } else if (childGraph.getNodes().length == 0) {\n        lNode.scatter();\n      } else {\n        this.positionNodesRandomly(childGraph);\n        lNode.updateBounds();\n      }\n    }\n  }\n};\n\n/**\r\n * This method returns a list of trees where each tree is represented as a\r\n * list of l-nodes. The method returns a list of size 0 when:\r\n * - The graph is not flat or\r\n * - One of the component(s) of the graph is not a tree.\r\n */\nLayout.prototype.getFlatForest = function () {\n  var flatForest = [];\n  var isForest = true;\n\n  // Quick reference for all nodes in the graph manager associated with\n  // this layout. The list should not be changed.\n  var allNodes = this.graphManager.getRoot().getNodes();\n\n  // First be sure that the graph is flat\n  var isFlat = true;\n\n  for (var i = 0; i < allNodes.length; i++) {\n    if (allNodes[i].getChild() != null) {\n      isFlat = false;\n    }\n  }\n\n  // Return empty forest if the graph is not flat.\n  if (!isFlat) {\n    return flatForest;\n  }\n\n  // Run BFS for each component of the graph.\n\n  var visited = new Set();\n  var toBeVisited = [];\n  var parents = new Map();\n  var unProcessedNodes = [];\n\n  unProcessedNodes = unProcessedNodes.concat(allNodes);\n\n  // Each iteration of this loop finds a component of the graph and\n  // decides whether it is a tree or not. If it is a tree, adds it to the\n  // forest and continued with the next component.\n\n  while (unProcessedNodes.length > 0 && isForest) {\n    toBeVisited.push(unProcessedNodes[0]);\n\n    // Start the BFS. Each iteration of this loop visits a node in a\n    // BFS manner.\n    while (toBeVisited.length > 0 && isForest) {\n      //pool operation\n      var currentNode = toBeVisited[0];\n      toBeVisited.splice(0, 1);\n      visited.add(currentNode);\n\n      // Traverse all neighbors of this node\n      var neighborEdges = currentNode.getEdges();\n\n      for (var i = 0; i < neighborEdges.length; i++) {\n        var currentNeighbor = neighborEdges[i].getOtherEnd(currentNode);\n\n        // If BFS is not growing from this neighbor.\n        if (parents.get(currentNode) != currentNeighbor) {\n          // We haven't previously visited this neighbor.\n          if (!visited.has(currentNeighbor)) {\n            toBeVisited.push(currentNeighbor);\n            parents.set(currentNeighbor, currentNode);\n          }\n          // Since we have previously visited this neighbor and\n          // this neighbor is not parent of currentNode, given\n          // graph contains a component that is not tree, hence\n          // it is not a forest.\n          else {\n              isForest = false;\n              break;\n            }\n        }\n      }\n    }\n\n    // The graph contains a component that is not a tree. Empty\n    // previously found trees. The method will end.\n    if (!isForest) {\n      flatForest = [];\n    }\n    // Save currently visited nodes as a tree in our forest. Reset\n    // visited and parents lists. Continue with the next component of\n    // the graph, if any.\n    else {\n        var temp = [].concat(_toConsumableArray(visited));\n        flatForest.push(temp);\n        //flatForest = flatForest.concat(temp);\n        //unProcessedNodes.removeAll(visited);\n        for (var i = 0; i < temp.length; i++) {\n          var value = temp[i];\n          var index = unProcessedNodes.indexOf(value);\n          if (index > -1) {\n            unProcessedNodes.splice(index, 1);\n          }\n        }\n        visited = new Set();\n        parents = new Map();\n      }\n  }\n\n  return flatForest;\n};\n\n/**\r\n * This method creates dummy nodes (an l-level node with minimal dimensions)\r\n * for the given edge (one per bendpoint). The existing l-level structure\r\n * is updated accordingly.\r\n */\nLayout.prototype.createDummyNodesForBendpoints = function (edge) {\n  var dummyNodes = [];\n  var prev = edge.source;\n\n  var graph = this.graphManager.calcLowestCommonAncestor(edge.source, edge.target);\n\n  for (var i = 0; i < edge.bendpoints.length; i++) {\n    // create new dummy node\n    var dummyNode = this.newNode(null);\n    dummyNode.setRect(new Point(0, 0), new Dimension(1, 1));\n\n    graph.add(dummyNode);\n\n    // create new dummy edge between prev and dummy node\n    var dummyEdge = this.newEdge(null);\n    this.graphManager.add(dummyEdge, prev, dummyNode);\n\n    dummyNodes.add(dummyNode);\n    prev = dummyNode;\n  }\n\n  var dummyEdge = this.newEdge(null);\n  this.graphManager.add(dummyEdge, prev, edge.target);\n\n  this.edgeToDummyNodes.set(edge, dummyNodes);\n\n  // remove real edge from graph manager if it is inter-graph\n  if (edge.isInterGraph()) {\n    this.graphManager.remove(edge);\n  }\n  // else, remove the edge from the current graph\n  else {\n      graph.remove(edge);\n    }\n\n  return dummyNodes;\n};\n\n/**\r\n * This method creates bendpoints for edges from the dummy nodes\r\n * at l-level.\r\n */\nLayout.prototype.createBendpointsFromDummyNodes = function () {\n  var edges = [];\n  edges = edges.concat(this.graphManager.getAllEdges());\n  edges = [].concat(_toConsumableArray(this.edgeToDummyNodes.keys())).concat(edges);\n\n  for (var k = 0; k < edges.length; k++) {\n    var lEdge = edges[k];\n\n    if (lEdge.bendpoints.length > 0) {\n      var path = this.edgeToDummyNodes.get(lEdge);\n\n      for (var i = 0; i < path.length; i++) {\n        var dummyNode = path[i];\n        var p = new PointD(dummyNode.getCenterX(), dummyNode.getCenterY());\n\n        // update bendpoint's location according to dummy node\n        var ebp = lEdge.bendpoints.get(i);\n        ebp.x = p.x;\n        ebp.y = p.y;\n\n        // remove the dummy node, dummy edges incident with this\n        // dummy node is also removed (within the remove method)\n        dummyNode.getOwner().remove(dummyNode);\n      }\n\n      // add the real edge to graph\n      this.graphManager.add(lEdge, lEdge.source, lEdge.target);\n    }\n  }\n};\n\nLayout.transform = function (sliderValue, defaultValue, minDiv, maxMul) {\n  if (minDiv != undefined && maxMul != undefined) {\n    var value = defaultValue;\n\n    if (sliderValue <= 50) {\n      var minValue = defaultValue / minDiv;\n      value -= (defaultValue - minValue) / 50 * (50 - sliderValue);\n    } else {\n      var maxValue = defaultValue * maxMul;\n      value += (maxValue - defaultValue) / 50 * (sliderValue - 50);\n    }\n\n    return value;\n  } else {\n    var a, b;\n\n    if (sliderValue <= 50) {\n      a = 9.0 * defaultValue / 500.0;\n      b = defaultValue / 10.0;\n    } else {\n      a = 9.0 * defaultValue / 50.0;\n      b = -8 * defaultValue;\n    }\n\n    return a * sliderValue + b;\n  }\n};\n\n/**\r\n * This method finds and returns the center of the given nodes, assuming\r\n * that the given nodes form a tree in themselves.\r\n */\nLayout.findCenterOfTree = function (nodes) {\n  var list = [];\n  list = list.concat(nodes);\n\n  var removedNodes = [];\n  var remainingDegrees = new Map();\n  var foundCenter = false;\n  var centerNode = null;\n\n  if (list.length == 1 || list.length == 2) {\n    foundCenter = true;\n    centerNode = list[0];\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    var node = list[i];\n    var degree = node.getNeighborsList().size;\n    remainingDegrees.set(node, node.getNeighborsList().size);\n\n    if (degree == 1) {\n      removedNodes.push(node);\n    }\n  }\n\n  var tempList = [];\n  tempList = tempList.concat(removedNodes);\n\n  while (!foundCenter) {\n    var tempList2 = [];\n    tempList2 = tempList2.concat(tempList);\n    tempList = [];\n\n    for (var i = 0; i < list.length; i++) {\n      var node = list[i];\n\n      var index = list.indexOf(node);\n      if (index >= 0) {\n        list.splice(index, 1);\n      }\n\n      var neighbours = node.getNeighborsList();\n\n      neighbours.forEach(function (neighbour) {\n        if (removedNodes.indexOf(neighbour) < 0) {\n          var otherDegree = remainingDegrees.get(neighbour);\n          var newDegree = otherDegree - 1;\n\n          if (newDegree == 1) {\n            tempList.push(neighbour);\n          }\n\n          remainingDegrees.set(neighbour, newDegree);\n        }\n      });\n    }\n\n    removedNodes = removedNodes.concat(tempList);\n\n    if (list.length == 1 || list.length == 2) {\n      foundCenter = true;\n      centerNode = list[0];\n    }\n  }\n\n  return centerNode;\n};\n\n/**\r\n * During the coarsening process, this layout may be referenced by two graph managers\r\n * this setter function grants access to change the currently being used graph manager\r\n */\nLayout.prototype.setGraphManager = function (gm) {\n  this.graphManager = gm;\n};\n\nmodule.exports = Layout;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction RandomSeed() {}\n// adapted from: https://stackoverflow.com/a/19303725\nRandomSeed.seed = 1;\nRandomSeed.x = 0;\n\nRandomSeed.nextDouble = function () {\n  RandomSeed.x = Math.sin(RandomSeed.seed++) * 10000;\n  return RandomSeed.x - Math.floor(RandomSeed.x);\n};\n\nmodule.exports = RandomSeed;\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __nested_webpack_require_84109__) {\n\n\"use strict\";\n\n\nvar PointD = __nested_webpack_require_84109__(5);\n\nfunction Transform(x, y) {\n  this.lworldOrgX = 0.0;\n  this.lworldOrgY = 0.0;\n  this.ldeviceOrgX = 0.0;\n  this.ldeviceOrgY = 0.0;\n  this.lworldExtX = 1.0;\n  this.lworldExtY = 1.0;\n  this.ldeviceExtX = 1.0;\n  this.ldeviceExtY = 1.0;\n}\n\nTransform.prototype.getWorldOrgX = function () {\n  return this.lworldOrgX;\n};\n\nTransform.prototype.setWorldOrgX = function (wox) {\n  this.lworldOrgX = wox;\n};\n\nTransform.prototype.getWorldOrgY = function () {\n  return this.lworldOrgY;\n};\n\nTransform.prototype.setWorldOrgY = function (woy) {\n  this.lworldOrgY = woy;\n};\n\nTransform.prototype.getWorldExtX = function () {\n  return this.lworldExtX;\n};\n\nTransform.prototype.setWorldExtX = function (wex) {\n  this.lworldExtX = wex;\n};\n\nTransform.prototype.getWorldExtY = function () {\n  return this.lworldExtY;\n};\n\nTransform.prototype.setWorldExtY = function (wey) {\n  this.lworldExtY = wey;\n};\n\n/* Device related */\n\nTransform.prototype.getDeviceOrgX = function () {\n  return this.ldeviceOrgX;\n};\n\nTransform.prototype.setDeviceOrgX = function (dox) {\n  this.ldeviceOrgX = dox;\n};\n\nTransform.prototype.getDeviceOrgY = function () {\n  return this.ldeviceOrgY;\n};\n\nTransform.prototype.setDeviceOrgY = function (doy) {\n  this.ldeviceOrgY = doy;\n};\n\nTransform.prototype.getDeviceExtX = function () {\n  return this.ldeviceExtX;\n};\n\nTransform.prototype.setDeviceExtX = function (dex) {\n  this.ldeviceExtX = dex;\n};\n\nTransform.prototype.getDeviceExtY = function () {\n  return this.ldeviceExtY;\n};\n\nTransform.prototype.setDeviceExtY = function (dey) {\n  this.ldeviceExtY = dey;\n};\n\nTransform.prototype.transformX = function (x) {\n  var xDevice = 0.0;\n  var worldExtX = this.lworldExtX;\n  if (worldExtX != 0.0) {\n    xDevice = this.ldeviceOrgX + (x - this.lworldOrgX) * this.ldeviceExtX / worldExtX;\n  }\n\n  return xDevice;\n};\n\nTransform.prototype.transformY = function (y) {\n  var yDevice = 0.0;\n  var worldExtY = this.lworldExtY;\n  if (worldExtY != 0.0) {\n    yDevice = this.ldeviceOrgY + (y - this.lworldOrgY) * this.ldeviceExtY / worldExtY;\n  }\n\n  return yDevice;\n};\n\nTransform.prototype.inverseTransformX = function (x) {\n  var xWorld = 0.0;\n  var deviceExtX = this.ldeviceExtX;\n  if (deviceExtX != 0.0) {\n    xWorld = this.lworldOrgX + (x - this.ldeviceOrgX) * this.lworldExtX / deviceExtX;\n  }\n\n  return xWorld;\n};\n\nTransform.prototype.inverseTransformY = function (y) {\n  var yWorld = 0.0;\n  var deviceExtY = this.ldeviceExtY;\n  if (deviceExtY != 0.0) {\n    yWorld = this.lworldOrgY + (y - this.ldeviceOrgY) * this.lworldExtY / deviceExtY;\n  }\n  return yWorld;\n};\n\nTransform.prototype.inverseTransformPoint = function (inPoint) {\n  var outPoint = new PointD(this.inverseTransformX(inPoint.x), this.inverseTransformY(inPoint.y));\n  return outPoint;\n};\n\nmodule.exports = Transform;\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __nested_webpack_require_86996__) {\n\n\"use strict\";\n\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar Layout = __nested_webpack_require_86996__(15);\nvar FDLayoutConstants = __nested_webpack_require_86996__(4);\nvar LayoutConstants = __nested_webpack_require_86996__(0);\nvar IGeometry = __nested_webpack_require_86996__(8);\nvar IMath = __nested_webpack_require_86996__(9);\n\nfunction FDLayout() {\n  Layout.call(this);\n\n  this.useSmartIdealEdgeLengthCalculation = FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;\n  this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;\n  this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;\n  this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;\n  this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;\n  this.displacementThresholdPerNode = 3.0 * FDLayoutConstants.DEFAULT_EDGE_LENGTH / 100;\n  this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n  this.initialCoolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;\n  this.totalDisplacement = 0.0;\n  this.oldTotalDisplacement = 0.0;\n  this.maxIterations = FDLayoutConstants.MAX_ITERATIONS;\n}\n\nFDLayout.prototype = Object.create(Layout.prototype);\n\nfor (var prop in Layout) {\n  FDLayout[prop] = Layout[prop];\n}\n\nFDLayout.prototype.initParameters = function () {\n  Layout.prototype.initParameters.call(this, arguments);\n\n  this.totalIterations = 0;\n  this.notAnimatedIterations = 0;\n\n  this.useFRGridVariant = FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION;\n\n  this.grid = [];\n};\n\nFDLayout.prototype.calcIdealEdgeLengths = function () {\n  var edge;\n  var originalIdealLength;\n  var lcaDepth;\n  var source;\n  var target;\n  var sizeOfSourceInLca;\n  var sizeOfTargetInLca;\n\n  var allEdges = this.getGraphManager().getAllEdges();\n  for (var i = 0; i < allEdges.length; i++) {\n    edge = allEdges[i];\n\n    originalIdealLength = edge.idealLength;\n\n    if (edge.isInterGraph) {\n      source = edge.getSource();\n      target = edge.getTarget();\n\n      sizeOfSourceInLca = edge.getSourceInLca().getEstimatedSize();\n      sizeOfTargetInLca = edge.getTargetInLca().getEstimatedSize();\n\n      if (this.useSmartIdealEdgeLengthCalculation) {\n        edge.idealLength += sizeOfSourceInLca + sizeOfTargetInLca - 2 * LayoutConstants.SIMPLE_NODE_SIZE;\n      }\n\n      lcaDepth = edge.getLca().getInclusionTreeDepth();\n\n      edge.idealLength += originalIdealLength * FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR * (source.getInclusionTreeDepth() + target.getInclusionTreeDepth() - 2 * lcaDepth);\n    }\n  }\n};\n\nFDLayout.prototype.initSpringEmbedder = function () {\n\n  var s = this.getAllNodes().length;\n  if (this.incremental) {\n    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n      this.coolingFactor = Math.max(this.coolingFactor * FDLayoutConstants.COOLING_ADAPTATION_FACTOR, this.coolingFactor - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * this.coolingFactor * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n    }\n    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL;\n  } else {\n    if (s > FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {\n      this.coolingFactor = Math.max(FDLayoutConstants.COOLING_ADAPTATION_FACTOR, 1.0 - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));\n    } else {\n      this.coolingFactor = 1.0;\n    }\n    this.initialCoolingFactor = this.coolingFactor;\n    this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT;\n  }\n\n  this.maxIterations = Math.max(this.getAllNodes().length * 5, this.maxIterations);\n\n  // Reassign this attribute by using new constant value\n  this.displacementThresholdPerNode = 3.0 * FDLayoutConstants.DEFAULT_EDGE_LENGTH / 100;\n  this.totalDisplacementThreshold = this.displacementThresholdPerNode * this.getAllNodes().length;\n\n  this.repulsionRange = this.calcRepulsionRange();\n};\n\nFDLayout.prototype.calcSpringForces = function () {\n  var lEdges = this.getAllEdges();\n  var edge;\n\n  for (var i = 0; i < lEdges.length; i++) {\n    edge = lEdges[i];\n\n    this.calcSpringForce(edge, edge.idealLength);\n  }\n};\n\nFDLayout.prototype.calcRepulsionForces = function () {\n  var gridUpdateAllowed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var forceToNodeSurroundingUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var i, j;\n  var nodeA, nodeB;\n  var lNodes = this.getAllNodes();\n  var processedNodeSet;\n\n  if (this.useFRGridVariant) {\n    if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed) {\n      this.updateGrid();\n    }\n\n    processedNodeSet = new Set();\n\n    // calculate repulsion forces between each nodes and its surrounding\n    for (i = 0; i < lNodes.length; i++) {\n      nodeA = lNodes[i];\n      this.calculateRepulsionForceOfANode(nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate);\n      processedNodeSet.add(nodeA);\n    }\n  } else {\n    for (i = 0; i < lNodes.length; i++) {\n      nodeA = lNodes[i];\n\n      for (j = i + 1; j < lNodes.length; j++) {\n        nodeB = lNodes[j];\n\n        // If both nodes are not members of the same graph, skip.\n        if (nodeA.getOwner() != nodeB.getOwner()) {\n          continue;\n        }\n\n        this.calcRepulsionForce(nodeA, nodeB);\n      }\n    }\n  }\n};\n\nFDLayout.prototype.calcGravitationalForces = function () {\n  var node;\n  var lNodes = this.getAllNodesToApplyGravitation();\n\n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    this.calcGravitationalForce(node);\n  }\n};\n\nFDLayout.prototype.moveNodes = function () {\n  var lNodes = this.getAllNodes();\n  var node;\n\n  for (var i = 0; i < lNodes.length; i++) {\n    node = lNodes[i];\n    node.move();\n  }\n};\n\nFDLayout.prototype.calcSpringForce = function (edge, idealLength) {\n  var sourceNode = edge.getSource();\n  var targetNode = edge.getTarget();\n\n  var length;\n  var springForce;\n  var springForceX;\n  var springForceY;\n\n  // Update edge length\n  if (this.uniformLeafNodeSizes && sourceNode.getChild() == null && targetNode.getChild() == null) {\n    edge.updateLengthSimple();\n  } else {\n    edge.updateLength();\n\n    if (edge.isOverlapingSourceAndTarget) {\n      return;\n    }\n  }\n\n  length = edge.getLength();\n\n  if (length == 0) return;\n\n  // Calculate spring forces\n  springForce = edge.edgeElasticity * (length - idealLength);\n\n  // Project force onto x and y axes\n  springForceX = springForce * (edge.lengthX / length);\n  springForceY = springForce * (edge.lengthY / length);\n\n  // Apply forces on the end nodes\n  sourceNode.springForceX += springForceX;\n  sourceNode.springForceY += springForceY;\n  targetNode.springForceX -= springForceX;\n  targetNode.springForceY -= springForceY;\n};\n\nFDLayout.prototype.calcRepulsionForce = function (nodeA, nodeB) {\n  var rectA = nodeA.getRect();\n  var rectB = nodeB.getRect();\n  var overlapAmount = new Array(2);\n  var clipPoints = new Array(4);\n  var distanceX;\n  var distanceY;\n  var distanceSquared;\n  var distance;\n  var repulsionForce;\n  var repulsionForceX;\n  var repulsionForceY;\n\n  if (rectA.intersects(rectB)) // two nodes overlap\n    {\n      // calculate separation amount in x and y directions\n      IGeometry.calcSeparationAmount(rectA, rectB, overlapAmount, FDLayoutConstants.DEFAULT_EDGE_LENGTH / 2.0);\n\n      repulsionForceX = 2 * overlapAmount[0];\n      repulsionForceY = 2 * overlapAmount[1];\n\n      var childrenConstant = nodeA.noOfChildren * nodeB.noOfChildren / (nodeA.noOfChildren + nodeB.noOfChildren);\n\n      // Apply forces on the two nodes\n      nodeA.repulsionForceX -= childrenConstant * repulsionForceX;\n      nodeA.repulsionForceY -= childrenConstant * repulsionForceY;\n      nodeB.repulsionForceX += childrenConstant * repulsionForceX;\n      nodeB.repulsionForceY += childrenConstant * repulsionForceY;\n    } else // no overlap\n    {\n      // calculate distance\n\n      if (this.uniformLeafNodeSizes && nodeA.getChild() == null && nodeB.getChild() == null) // simply base repulsion on distance of node centers\n        {\n          distanceX = rectB.getCenterX() - rectA.getCenterX();\n          distanceY = rectB.getCenterY() - rectA.getCenterY();\n        } else // use clipping points\n        {\n          IGeometry.getIntersection(rectA, rectB, clipPoints);\n\n          distanceX = clipPoints[2] - clipPoints[0];\n          distanceY = clipPoints[3] - clipPoints[1];\n        }\n\n      // No repulsion range. FR grid variant should take care of this.\n      if (Math.abs(distanceX) < FDLayoutConstants.MIN_REPULSION_DIST) {\n        distanceX = IMath.sign(distanceX) * FDLayoutConstants.MIN_REPULSION_DIST;\n      }\n\n      if (Math.abs(distanceY) < FDLayoutConstants.MIN_REPULSION_DIST) {\n        distanceY = IMath.sign(distanceY) * FDLayoutConstants.MIN_REPULSION_DIST;\n      }\n\n      distanceSquared = distanceX * distanceX + distanceY * distanceY;\n      distance = Math.sqrt(distanceSquared);\n\n      // Here we use half of the nodes' repulsion values for backward compatibility\n      repulsionForce = (nodeA.nodeRepulsion / 2 + nodeB.nodeRepulsion / 2) * nodeA.noOfChildren * nodeB.noOfChildren / distanceSquared;\n\n      // Project force onto x and y axes\n      repulsionForceX = repulsionForce * distanceX / distance;\n      repulsionForceY = repulsionForce * distanceY / distance;\n\n      // Apply forces on the two nodes    \n      nodeA.repulsionForceX -= repulsionForceX;\n      nodeA.repulsionForceY -= repulsionForceY;\n      nodeB.repulsionForceX += repulsionForceX;\n      nodeB.repulsionForceY += repulsionForceY;\n    }\n};\n\nFDLayout.prototype.calcGravitationalForce = function (node) {\n  var ownerGraph;\n  var ownerCenterX;\n  var ownerCenterY;\n  var distanceX;\n  var distanceY;\n  var absDistanceX;\n  var absDistanceY;\n  var estimatedSize;\n  ownerGraph = node.getOwner();\n\n  ownerCenterX = (ownerGraph.getRight() + ownerGraph.getLeft()) / 2;\n  ownerCenterY = (ownerGraph.getTop() + ownerGraph.getBottom()) / 2;\n  distanceX = node.getCenterX() - ownerCenterX;\n  distanceY = node.getCenterY() - ownerCenterY;\n  absDistanceX = Math.abs(distanceX) + node.getWidth() / 2;\n  absDistanceY = Math.abs(distanceY) + node.getHeight() / 2;\n\n  if (node.getOwner() == this.graphManager.getRoot()) // in the root graph\n    {\n      estimatedSize = ownerGraph.getEstimatedSize() * this.gravityRangeFactor;\n\n      if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n        node.gravitationForceX = -this.gravityConstant * distanceX;\n        node.gravitationForceY = -this.gravityConstant * distanceY;\n      }\n    } else // inside a compound\n    {\n      estimatedSize = ownerGraph.getEstimatedSize() * this.compoundGravityRangeFactor;\n\n      if (absDistanceX > estimatedSize || absDistanceY > estimatedSize) {\n        node.gravitationForceX = -this.gravityConstant * distanceX * this.compoundGravityConstant;\n        node.gravitationForceY = -this.gravityConstant * distanceY * this.compoundGravityConstant;\n      }\n    }\n};\n\nFDLayout.prototype.isConverged = function () {\n  var converged;\n  var oscilating = false;\n\n  if (this.totalIterations > this.maxIterations / 3) {\n    oscilating = Math.abs(this.totalDisplacement - this.oldTotalDisplacement) < 2;\n  }\n\n  converged = this.totalDisplacement < this.totalDisplacementThreshold;\n\n  this.oldTotalDisplacement = this.totalDisplacement;\n\n  return converged || oscilating;\n};\n\nFDLayout.prototype.animate = function () {\n  if (this.animationDuringLayout && !this.isSubLayout) {\n    if (this.notAnimatedIterations == this.animationPeriod) {\n      this.update();\n      this.notAnimatedIterations = 0;\n    } else {\n      this.notAnimatedIterations++;\n    }\n  }\n};\n\n//This method calculates the number of children (weight) for all nodes\nFDLayout.prototype.calcNoOfChildrenForAllNodes = function () {\n  var node;\n  var allNodes = this.graphManager.getAllNodes();\n\n  for (var i = 0; i < allNodes.length; i++) {\n    node = allNodes[i];\n    node.noOfChildren = node.getNoOfChildren();\n  }\n};\n\n// -----------------------------------------------------------------------------\n// Section: FR-Grid Variant Repulsion Force Calculation\n// -----------------------------------------------------------------------------\n\nFDLayout.prototype.calcGrid = function (graph) {\n\n  var sizeX = 0;\n  var sizeY = 0;\n\n  sizeX = parseInt(Math.ceil((graph.getRight() - graph.getLeft()) / this.repulsionRange));\n  sizeY = parseInt(Math.ceil((graph.getBottom() - graph.getTop()) / this.repulsionRange));\n\n  var grid = new Array(sizeX);\n\n  for (var i = 0; i < sizeX; i++) {\n    grid[i] = new Array(sizeY);\n  }\n\n  for (var i = 0; i < sizeX; i++) {\n    for (var j = 0; j < sizeY; j++) {\n      grid[i][j] = new Array();\n    }\n  }\n\n  return grid;\n};\n\nFDLayout.prototype.addNodeToGrid = function (v, left, top) {\n\n  var startX = 0;\n  var finishX = 0;\n  var startY = 0;\n  var finishY = 0;\n\n  startX = parseInt(Math.floor((v.getRect().x - left) / this.repulsionRange));\n  finishX = parseInt(Math.floor((v.getRect().width + v.getRect().x - left) / this.repulsionRange));\n  startY = parseInt(Math.floor((v.getRect().y - top) / this.repulsionRange));\n  finishY = parseInt(Math.floor((v.getRect().height + v.getRect().y - top) / this.repulsionRange));\n\n  for (var i = startX; i <= finishX; i++) {\n    for (var j = startY; j <= finishY; j++) {\n      this.grid[i][j].push(v);\n      v.setGridCoordinates(startX, finishX, startY, finishY);\n    }\n  }\n};\n\nFDLayout.prototype.updateGrid = function () {\n  var i;\n  var nodeA;\n  var lNodes = this.getAllNodes();\n\n  this.grid = this.calcGrid(this.graphManager.getRoot());\n\n  // put all nodes to proper grid cells\n  for (i = 0; i < lNodes.length; i++) {\n    nodeA = lNodes[i];\n    this.addNodeToGrid(nodeA, this.graphManager.getRoot().getLeft(), this.graphManager.getRoot().getTop());\n  }\n};\n\nFDLayout.prototype.calculateRepulsionForceOfANode = function (nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate) {\n\n  if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 && gridUpdateAllowed || forceToNodeSurroundingUpdate) {\n    var surrounding = new Set();\n    nodeA.surrounding = new Array();\n    var nodeB;\n    var grid = this.grid;\n\n    for (var i = nodeA.startX - 1; i < nodeA.finishX + 2; i++) {\n      for (var j = nodeA.startY - 1; j < nodeA.finishY + 2; j++) {\n        if (!(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length)) {\n          for (var k = 0; k < grid[i][j].length; k++) {\n            nodeB = grid[i][j][k];\n\n            // If both nodes are not members of the same graph, \n            // or both nodes are the same, skip.\n            if (nodeA.getOwner() != nodeB.getOwner() || nodeA == nodeB) {\n              continue;\n            }\n\n            // check if the repulsion force between\n            // nodeA and nodeB has already been calculated\n            if (!processedNodeSet.has(nodeB) && !surrounding.has(nodeB)) {\n              var distanceX = Math.abs(nodeA.getCenterX() - nodeB.getCenterX()) - (nodeA.getWidth() / 2 + nodeB.getWidth() / 2);\n              var distanceY = Math.abs(nodeA.getCenterY() - nodeB.getCenterY()) - (nodeA.getHeight() / 2 + nodeB.getHeight() / 2);\n\n              // if the distance between nodeA and nodeB \n              // is less then calculation range\n              if (distanceX <= this.repulsionRange && distanceY <= this.repulsionRange) {\n                //then add nodeB to surrounding of nodeA\n                surrounding.add(nodeB);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    nodeA.surrounding = [].concat(_toConsumableArray(surrounding));\n  }\n  for (i = 0; i < nodeA.surrounding.length; i++) {\n    this.calcRepulsionForce(nodeA, nodeA.surrounding[i]);\n  }\n};\n\nFDLayout.prototype.calcRepulsionRange = function () {\n  return 0.0;\n};\n\nmodule.exports = FDLayout;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __nested_webpack_require_103214__) {\n\n\"use strict\";\n\n\nvar LEdge = __nested_webpack_require_103214__(1);\nvar FDLayoutConstants = __nested_webpack_require_103214__(4);\n\nfunction FDLayoutEdge(source, target, vEdge) {\n  LEdge.call(this, source, target, vEdge);\n\n  // Ideal length and elasticity value for this edge\n  this.idealLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;\n  this.edgeElasticity = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;\n}\n\nFDLayoutEdge.prototype = Object.create(LEdge.prototype);\n\nfor (var prop in LEdge) {\n  FDLayoutEdge[prop] = LEdge[prop];\n}\n\nmodule.exports = FDLayoutEdge;\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __nested_webpack_require_103820__) {\n\n\"use strict\";\n\n\nvar LNode = __nested_webpack_require_103820__(3);\nvar FDLayoutConstants = __nested_webpack_require_103820__(4);\n\nfunction FDLayoutNode(gm, loc, size, vNode) {\n  // alternative constructor is handled inside LNode\n  LNode.call(this, gm, loc, size, vNode);\n\n  // Repulsion value of this node\n  this.nodeRepulsion = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;\n\n  //Spring, repulsion and gravitational forces acting on this node\n  this.springForceX = 0;\n  this.springForceY = 0;\n  this.repulsionForceX = 0;\n  this.repulsionForceY = 0;\n  this.gravitationForceX = 0;\n  this.gravitationForceY = 0;\n  //Amount by which this node is to be moved in this iteration\n  this.displacementX = 0;\n  this.displacementY = 0;\n\n  //Start and finish grid coordinates that this node is fallen into\n  this.startX = 0;\n  this.finishX = 0;\n  this.startY = 0;\n  this.finishY = 0;\n\n  //Geometric neighbors of this node\n  this.surrounding = [];\n}\n\nFDLayoutNode.prototype = Object.create(LNode.prototype);\n\nfor (var prop in LNode) {\n  FDLayoutNode[prop] = LNode[prop];\n}\n\nFDLayoutNode.prototype.setGridCoordinates = function (_startX, _finishX, _startY, _finishY) {\n  this.startX = _startX;\n  this.finishX = _finishX;\n  this.startY = _startY;\n  this.finishY = _finishY;\n};\n\nmodule.exports = FDLayoutNode;\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction DimensionD(width, height) {\n  this.width = 0;\n  this.height = 0;\n  if (width !== null && height !== null) {\n    this.height = height;\n    this.width = width;\n  }\n}\n\nDimensionD.prototype.getWidth = function () {\n  return this.width;\n};\n\nDimensionD.prototype.setWidth = function (width) {\n  this.width = width;\n};\n\nDimensionD.prototype.getHeight = function () {\n  return this.height;\n};\n\nDimensionD.prototype.setHeight = function (height) {\n  this.height = height;\n};\n\nmodule.exports = DimensionD;\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __nested_webpack_require_105759__) {\n\n\"use strict\";\n\n\nvar UniqueIDGeneretor = __nested_webpack_require_105759__(14);\n\nfunction HashMap() {\n  this.map = {};\n  this.keys = [];\n}\n\nHashMap.prototype.put = function (key, value) {\n  var theId = UniqueIDGeneretor.createID(key);\n  if (!this.contains(theId)) {\n    this.map[theId] = value;\n    this.keys.push(key);\n  }\n};\n\nHashMap.prototype.contains = function (key) {\n  var theId = UniqueIDGeneretor.createID(key);\n  return this.map[key] != null;\n};\n\nHashMap.prototype.get = function (key) {\n  var theId = UniqueIDGeneretor.createID(key);\n  return this.map[theId];\n};\n\nHashMap.prototype.keySet = function () {\n  return this.keys;\n};\n\nmodule.exports = HashMap;\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __nested_webpack_require_106487__) {\n\n\"use strict\";\n\n\nvar UniqueIDGeneretor = __nested_webpack_require_106487__(14);\n\nfunction HashSet() {\n  this.set = {};\n}\n;\n\nHashSet.prototype.add = function (obj) {\n  var theId = UniqueIDGeneretor.createID(obj);\n  if (!this.contains(theId)) this.set[theId] = obj;\n};\n\nHashSet.prototype.remove = function (obj) {\n  delete this.set[UniqueIDGeneretor.createID(obj)];\n};\n\nHashSet.prototype.clear = function () {\n  this.set = {};\n};\n\nHashSet.prototype.contains = function (obj) {\n  return this.set[UniqueIDGeneretor.createID(obj)] == obj;\n};\n\nHashSet.prototype.isEmpty = function () {\n  return this.size() === 0;\n};\n\nHashSet.prototype.size = function () {\n  return Object.keys(this.set).length;\n};\n\n//concats this.set to the given list\nHashSet.prototype.addAllTo = function (list) {\n  var keys = Object.keys(this.set);\n  var length = keys.length;\n  for (var i = 0; i < length; i++) {\n    list.push(this.set[keys[i]]);\n  }\n};\n\nHashSet.prototype.size = function () {\n  return Object.keys(this.set).length;\n};\n\nHashSet.prototype.addAll = function (list) {\n  var s = list.length;\n  for (var i = 0; i < s; i++) {\n    var v = list[i];\n    this.add(v);\n  }\n};\n\nmodule.exports = HashSet;\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// Some matrix (1d and 2d array) operations\nfunction Matrix() {}\n\n/**\n * matrix multiplication\n * array1, array2 and result are 2d arrays\n */\nMatrix.multMat = function (array1, array2) {\n  var result = [];\n\n  for (var i = 0; i < array1.length; i++) {\n    result[i] = [];\n    for (var j = 0; j < array2[0].length; j++) {\n      result[i][j] = 0;\n      for (var k = 0; k < array1[0].length; k++) {\n        result[i][j] += array1[i][k] * array2[k][j];\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * matrix transpose\n * array and result are 2d arrays\n */\nMatrix.transpose = function (array) {\n  var result = [];\n\n  for (var i = 0; i < array[0].length; i++) {\n    result[i] = [];\n    for (var j = 0; j < array.length; j++) {\n      result[i][j] = array[j][i];\n    }\n  }\n\n  return result;\n};\n\n/**\n * multiply array with constant\n * array and result are 1d arrays\n */\nMatrix.multCons = function (array, constant) {\n  var result = [];\n\n  for (var i = 0; i < array.length; i++) {\n    result[i] = array[i] * constant;\n  }\n\n  return result;\n};\n\n/**\n * substract two arrays\n * array1, array2 and result are 1d arrays\n */\nMatrix.minusOp = function (array1, array2) {\n  var result = [];\n\n  for (var i = 0; i < array1.length; i++) {\n    result[i] = array1[i] - array2[i];\n  }\n\n  return result;\n};\n\n/**\n * dot product of two arrays with same size\n * array1 and array2 are 1d arrays\n */\nMatrix.dotProduct = function (array1, array2) {\n  var product = 0;\n\n  for (var i = 0; i < array1.length; i++) {\n    product += array1[i] * array2[i];\n  }\n\n  return product;\n};\n\n/**\n * magnitude of an array\n * array is 1d array\n */\nMatrix.mag = function (array) {\n  return Math.sqrt(this.dotProduct(array, array));\n};\n\n/**\n * normalization of an array\n * array and result are 1d array\n */\nMatrix.normalize = function (array) {\n  var result = [];\n  var magnitude = this.mag(array);\n\n  for (var i = 0; i < array.length; i++) {\n    result[i] = array[i] / magnitude;\n  }\n\n  return result;\n};\n\n/**\n * multiply an array with centering matrix\n * array and result are 1d array\n */\nMatrix.multGamma = function (array) {\n  var result = [];\n  var sum = 0;\n\n  for (var i = 0; i < array.length; i++) {\n    sum += array[i];\n  }\n\n  sum *= -1 / array.length;\n\n  for (var _i = 0; _i < array.length; _i++) {\n    result[_i] = sum + array[_i];\n  }\n  return result;\n};\n\n/**\n * a special matrix multiplication\n * result = 0.5 * C * INV * C^T * array\n * array and result are 1d, C and INV are 2d arrays\n */\nMatrix.multL = function (array, C, INV) {\n  var result = [];\n  var temp1 = [];\n  var temp2 = [];\n\n  // multiply by C^T\n  for (var i = 0; i < C[0].length; i++) {\n    var sum = 0;\n    for (var j = 0; j < C.length; j++) {\n      sum += -0.5 * C[j][i] * array[j];\n    }\n    temp1[i] = sum;\n  }\n  // multiply the result by INV\n  for (var _i2 = 0; _i2 < INV.length; _i2++) {\n    var _sum = 0;\n    for (var _j = 0; _j < INV.length; _j++) {\n      _sum += INV[_i2][_j] * temp1[_j];\n    }\n    temp2[_i2] = _sum;\n  }\n  // multiply the result by C\n  for (var _i3 = 0; _i3 < C.length; _i3++) {\n    var _sum2 = 0;\n    for (var _j2 = 0; _j2 < C[0].length; _j2++) {\n      _sum2 += C[_i3][_j2] * temp2[_j2];\n    }\n    result[_i3] = _sum2;\n  }\n\n  return result;\n};\n\nmodule.exports = Matrix;\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __nested_webpack_require_111039__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * A classic Quicksort algorithm with Hoare's partition\n * - Works also on LinkedList objects\n *\n * Copyright: i-Vis Research Group, Bilkent University, 2007 - present\n */\n\nvar LinkedList = __nested_webpack_require_111039__(11);\n\nvar Quicksort = function () {\n    function Quicksort(A, compareFunction) {\n        _classCallCheck(this, Quicksort);\n\n        if (compareFunction !== null || compareFunction !== undefined) this.compareFunction = this._defaultCompareFunction;\n\n        var length = void 0;\n        if (A instanceof LinkedList) length = A.size();else length = A.length;\n\n        this._quicksort(A, 0, length - 1);\n    }\n\n    _createClass(Quicksort, [{\n        key: '_quicksort',\n        value: function _quicksort(A, p, r) {\n            if (p < r) {\n                var q = this._partition(A, p, r);\n                this._quicksort(A, p, q);\n                this._quicksort(A, q + 1, r);\n            }\n        }\n    }, {\n        key: '_partition',\n        value: function _partition(A, p, r) {\n            var x = this._get(A, p);\n            var i = p;\n            var j = r;\n            while (true) {\n                while (this.compareFunction(x, this._get(A, j))) {\n                    j--;\n                }while (this.compareFunction(this._get(A, i), x)) {\n                    i++;\n                }if (i < j) {\n                    this._swap(A, i, j);\n                    i++;\n                    j--;\n                } else return j;\n            }\n        }\n    }, {\n        key: '_get',\n        value: function _get(object, index) {\n            if (object instanceof LinkedList) return object.get_object_at(index);else return object[index];\n        }\n    }, {\n        key: '_set',\n        value: function _set(object, index, value) {\n            if (object instanceof LinkedList) object.set_object_at(index, value);else object[index] = value;\n        }\n    }, {\n        key: '_swap',\n        value: function _swap(A, i, j) {\n            var temp = this._get(A, i);\n            this._set(A, i, this._get(A, j));\n            this._set(A, j, temp);\n        }\n    }, {\n        key: '_defaultCompareFunction',\n        value: function _defaultCompareFunction(a, b) {\n            return b > a;\n        }\n    }]);\n\n    return Quicksort;\n}();\n\nmodule.exports = Quicksort;\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// Singular Value Decomposition implementation\nfunction SVD() {};\n\n/* Below singular value decomposition (svd) code including hypot function is adopted from https://github.com/dragonfly-ai/JamaJS\n   Some changes are applied to make the code compatible with the fcose code and to make it independent from Jama.\n   Input matrix is changed to a 2D array instead of Jama matrix. Matrix dimensions are taken according to 2D array instead of using Jama functions.\n   An object that includes singular value components is created for return. \n   The types of input parameters of the hypot function are removed. \n   let is used instead of var for the variable initialization.\n*/\n/*\n                               Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright {yyyy} {name of copyright owner}\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nSVD.svd = function (A) {\n  this.U = null;\n  this.V = null;\n  this.s = null;\n  this.m = 0;\n  this.n = 0;\n  this.m = A.length;\n  this.n = A[0].length;\n  var nu = Math.min(this.m, this.n);\n  this.s = function (s) {\n    var a = [];\n    while (s-- > 0) {\n      a.push(0);\n    }return a;\n  }(Math.min(this.m + 1, this.n));\n  this.U = function (dims) {\n    var allocate = function allocate(dims) {\n      if (dims.length == 0) {\n        return 0;\n      } else {\n        var array = [];\n        for (var i = 0; i < dims[0]; i++) {\n          array.push(allocate(dims.slice(1)));\n        }\n        return array;\n      }\n    };\n    return allocate(dims);\n  }([this.m, nu]);\n  this.V = function (dims) {\n    var allocate = function allocate(dims) {\n      if (dims.length == 0) {\n        return 0;\n      } else {\n        var array = [];\n        for (var i = 0; i < dims[0]; i++) {\n          array.push(allocate(dims.slice(1)));\n        }\n        return array;\n      }\n    };\n    return allocate(dims);\n  }([this.n, this.n]);\n  var e = function (s) {\n    var a = [];\n    while (s-- > 0) {\n      a.push(0);\n    }return a;\n  }(this.n);\n  var work = function (s) {\n    var a = [];\n    while (s-- > 0) {\n      a.push(0);\n    }return a;\n  }(this.m);\n  var wantu = true;\n  var wantv = true;\n  var nct = Math.min(this.m - 1, this.n);\n  var nrt = Math.max(0, Math.min(this.n - 2, this.m));\n  for (var k = 0; k < Math.max(nct, nrt); k++) {\n    if (k < nct) {\n      this.s[k] = 0;\n      for (var i = k; i < this.m; i++) {\n        this.s[k] = SVD.hypot(this.s[k], A[i][k]);\n      }\n      ;\n      if (this.s[k] !== 0.0) {\n        if (A[k][k] < 0.0) {\n          this.s[k] = -this.s[k];\n        }\n        for (var _i = k; _i < this.m; _i++) {\n          A[_i][k] /= this.s[k];\n        }\n        ;\n        A[k][k] += 1.0;\n      }\n      this.s[k] = -this.s[k];\n    }\n    for (var j = k + 1; j < this.n; j++) {\n      if (function (lhs, rhs) {\n        return lhs && rhs;\n      }(k < nct, this.s[k] !== 0.0)) {\n        var t = 0;\n        for (var _i2 = k; _i2 < this.m; _i2++) {\n          t += A[_i2][k] * A[_i2][j];\n        }\n        ;\n        t = -t / A[k][k];\n        for (var _i3 = k; _i3 < this.m; _i3++) {\n          A[_i3][j] += t * A[_i3][k];\n        }\n        ;\n      }\n      e[j] = A[k][j];\n    }\n    ;\n    if (function (lhs, rhs) {\n      return lhs && rhs;\n    }(wantu, k < nct)) {\n      for (var _i4 = k; _i4 < this.m; _i4++) {\n        this.U[_i4][k] = A[_i4][k];\n      }\n      ;\n    }\n    if (k < nrt) {\n      e[k] = 0;\n      for (var _i5 = k + 1; _i5 < this.n; _i5++) {\n        e[k] = SVD.hypot(e[k], e[_i5]);\n      }\n      ;\n      if (e[k] !== 0.0) {\n        if (e[k + 1] < 0.0) {\n          e[k] = -e[k];\n        }\n        for (var _i6 = k + 1; _i6 < this.n; _i6++) {\n          e[_i6] /= e[k];\n        }\n        ;\n        e[k + 1] += 1.0;\n      }\n      e[k] = -e[k];\n      if (function (lhs, rhs) {\n        return lhs && rhs;\n      }(k + 1 < this.m, e[k] !== 0.0)) {\n        for (var _i7 = k + 1; _i7 < this.m; _i7++) {\n          work[_i7] = 0.0;\n        }\n        ;\n        for (var _j = k + 1; _j < this.n; _j++) {\n          for (var _i8 = k + 1; _i8 < this.m; _i8++) {\n            work[_i8] += e[_j] * A[_i8][_j];\n          }\n          ;\n        }\n        ;\n        for (var _j2 = k + 1; _j2 < this.n; _j2++) {\n          var _t = -e[_j2] / e[k + 1];\n          for (var _i9 = k + 1; _i9 < this.m; _i9++) {\n            A[_i9][_j2] += _t * work[_i9];\n          }\n          ;\n        }\n        ;\n      }\n      if (wantv) {\n        for (var _i10 = k + 1; _i10 < this.n; _i10++) {\n          this.V[_i10][k] = e[_i10];\n        };\n      }\n    }\n  };\n  var p = Math.min(this.n, this.m + 1);\n  if (nct < this.n) {\n    this.s[nct] = A[nct][nct];\n  }\n  if (this.m < p) {\n    this.s[p - 1] = 0.0;\n  }\n  if (nrt + 1 < p) {\n    e[nrt] = A[nrt][p - 1];\n  }\n  e[p - 1] = 0.0;\n  if (wantu) {\n    for (var _j3 = nct; _j3 < nu; _j3++) {\n      for (var _i11 = 0; _i11 < this.m; _i11++) {\n        this.U[_i11][_j3] = 0.0;\n      }\n      ;\n      this.U[_j3][_j3] = 1.0;\n    };\n    for (var _k = nct - 1; _k >= 0; _k--) {\n      if (this.s[_k] !== 0.0) {\n        for (var _j4 = _k + 1; _j4 < nu; _j4++) {\n          var _t2 = 0;\n          for (var _i12 = _k; _i12 < this.m; _i12++) {\n            _t2 += this.U[_i12][_k] * this.U[_i12][_j4];\n          };\n          _t2 = -_t2 / this.U[_k][_k];\n          for (var _i13 = _k; _i13 < this.m; _i13++) {\n            this.U[_i13][_j4] += _t2 * this.U[_i13][_k];\n          };\n        };\n        for (var _i14 = _k; _i14 < this.m; _i14++) {\n          this.U[_i14][_k] = -this.U[_i14][_k];\n        };\n        this.U[_k][_k] = 1.0 + this.U[_k][_k];\n        for (var _i15 = 0; _i15 < _k - 1; _i15++) {\n          this.U[_i15][_k] = 0.0;\n        };\n      } else {\n        for (var _i16 = 0; _i16 < this.m; _i16++) {\n          this.U[_i16][_k] = 0.0;\n        };\n        this.U[_k][_k] = 1.0;\n      }\n    };\n  }\n  if (wantv) {\n    for (var _k2 = this.n - 1; _k2 >= 0; _k2--) {\n      if (function (lhs, rhs) {\n        return lhs && rhs;\n      }(_k2 < nrt, e[_k2] !== 0.0)) {\n        for (var _j5 = _k2 + 1; _j5 < nu; _j5++) {\n          var _t3 = 0;\n          for (var _i17 = _k2 + 1; _i17 < this.n; _i17++) {\n            _t3 += this.V[_i17][_k2] * this.V[_i17][_j5];\n          };\n          _t3 = -_t3 / this.V[_k2 + 1][_k2];\n          for (var _i18 = _k2 + 1; _i18 < this.n; _i18++) {\n            this.V[_i18][_j5] += _t3 * this.V[_i18][_k2];\n          };\n        };\n      }\n      for (var _i19 = 0; _i19 < this.n; _i19++) {\n        this.V[_i19][_k2] = 0.0;\n      };\n      this.V[_k2][_k2] = 1.0;\n    };\n  }\n  var pp = p - 1;\n  var iter = 0;\n  var eps = Math.pow(2.0, -52.0);\n  var tiny = Math.pow(2.0, -966.0);\n  while (p > 0) {\n    var _k3 = void 0;\n    var kase = void 0;\n    for (_k3 = p - 2; _k3 >= -1; _k3--) {\n      if (_k3 === -1) {\n        break;\n      }\n      if (Math.abs(e[_k3]) <= tiny + eps * (Math.abs(this.s[_k3]) + Math.abs(this.s[_k3 + 1]))) {\n        e[_k3] = 0.0;\n        break;\n      }\n    };\n    if (_k3 === p - 2) {\n      kase = 4;\n    } else {\n      var ks = void 0;\n      for (ks = p - 1; ks >= _k3; ks--) {\n        if (ks === _k3) {\n          break;\n        }\n        var _t4 = (ks !== p ? Math.abs(e[ks]) : 0.0) + (ks !== _k3 + 1 ? Math.abs(e[ks - 1]) : 0.0);\n        if (Math.abs(this.s[ks]) <= tiny + eps * _t4) {\n          this.s[ks] = 0.0;\n          break;\n        }\n      };\n      if (ks === _k3) {\n        kase = 3;\n      } else if (ks === p - 1) {\n        kase = 1;\n      } else {\n        kase = 2;\n        _k3 = ks;\n      }\n    }\n    _k3++;\n    switch (kase) {\n      case 1:\n        {\n          var f = e[p - 2];\n          e[p - 2] = 0.0;\n          for (var _j6 = p - 2; _j6 >= _k3; _j6--) {\n            var _t5 = SVD.hypot(this.s[_j6], f);\n            var cs = this.s[_j6] / _t5;\n            var sn = f / _t5;\n            this.s[_j6] = _t5;\n            if (_j6 !== _k3) {\n              f = -sn * e[_j6 - 1];\n              e[_j6 - 1] = cs * e[_j6 - 1];\n            }\n            if (wantv) {\n              for (var _i20 = 0; _i20 < this.n; _i20++) {\n                _t5 = cs * this.V[_i20][_j6] + sn * this.V[_i20][p - 1];\n                this.V[_i20][p - 1] = -sn * this.V[_i20][_j6] + cs * this.V[_i20][p - 1];\n                this.V[_i20][_j6] = _t5;\n              };\n            }\n          };\n        };\n        break;\n      case 2:\n        {\n          var _f = e[_k3 - 1];\n          e[_k3 - 1] = 0.0;\n          for (var _j7 = _k3; _j7 < p; _j7++) {\n            var _t6 = SVD.hypot(this.s[_j7], _f);\n            var _cs = this.s[_j7] / _t6;\n            var _sn = _f / _t6;\n            this.s[_j7] = _t6;\n            _f = -_sn * e[_j7];\n            e[_j7] = _cs * e[_j7];\n            if (wantu) {\n              for (var _i21 = 0; _i21 < this.m; _i21++) {\n                _t6 = _cs * this.U[_i21][_j7] + _sn * this.U[_i21][_k3 - 1];\n                this.U[_i21][_k3 - 1] = -_sn * this.U[_i21][_j7] + _cs * this.U[_i21][_k3 - 1];\n                this.U[_i21][_j7] = _t6;\n              };\n            }\n          };\n        };\n        break;\n      case 3:\n        {\n          var scale = Math.max(Math.max(Math.max(Math.max(Math.abs(this.s[p - 1]), Math.abs(this.s[p - 2])), Math.abs(e[p - 2])), Math.abs(this.s[_k3])), Math.abs(e[_k3]));\n          var sp = this.s[p - 1] / scale;\n          var spm1 = this.s[p - 2] / scale;\n          var epm1 = e[p - 2] / scale;\n          var sk = this.s[_k3] / scale;\n          var ek = e[_k3] / scale;\n          var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n          var c = sp * epm1 * (sp * epm1);\n          var shift = 0.0;\n          if (function (lhs, rhs) {\n            return lhs || rhs;\n          }(b !== 0.0, c !== 0.0)) {\n            shift = Math.sqrt(b * b + c);\n            if (b < 0.0) {\n              shift = -shift;\n            }\n            shift = c / (b + shift);\n          }\n          var _f2 = (sk + sp) * (sk - sp) + shift;\n          var g = sk * ek;\n          for (var _j8 = _k3; _j8 < p - 1; _j8++) {\n            var _t7 = SVD.hypot(_f2, g);\n            var _cs2 = _f2 / _t7;\n            var _sn2 = g / _t7;\n            if (_j8 !== _k3) {\n              e[_j8 - 1] = _t7;\n            }\n            _f2 = _cs2 * this.s[_j8] + _sn2 * e[_j8];\n            e[_j8] = _cs2 * e[_j8] - _sn2 * this.s[_j8];\n            g = _sn2 * this.s[_j8 + 1];\n            this.s[_j8 + 1] = _cs2 * this.s[_j8 + 1];\n            if (wantv) {\n              for (var _i22 = 0; _i22 < this.n; _i22++) {\n                _t7 = _cs2 * this.V[_i22][_j8] + _sn2 * this.V[_i22][_j8 + 1];\n                this.V[_i22][_j8 + 1] = -_sn2 * this.V[_i22][_j8] + _cs2 * this.V[_i22][_j8 + 1];\n                this.V[_i22][_j8] = _t7;\n              };\n            }\n            _t7 = SVD.hypot(_f2, g);\n            _cs2 = _f2 / _t7;\n            _sn2 = g / _t7;\n            this.s[_j8] = _t7;\n            _f2 = _cs2 * e[_j8] + _sn2 * this.s[_j8 + 1];\n            this.s[_j8 + 1] = -_sn2 * e[_j8] + _cs2 * this.s[_j8 + 1];\n            g = _sn2 * e[_j8 + 1];\n            e[_j8 + 1] = _cs2 * e[_j8 + 1];\n            if (wantu && _j8 < this.m - 1) {\n              for (var _i23 = 0; _i23 < this.m; _i23++) {\n                _t7 = _cs2 * this.U[_i23][_j8] + _sn2 * this.U[_i23][_j8 + 1];\n                this.U[_i23][_j8 + 1] = -_sn2 * this.U[_i23][_j8] + _cs2 * this.U[_i23][_j8 + 1];\n                this.U[_i23][_j8] = _t7;\n              };\n            }\n          };\n          e[p - 2] = _f2;\n          iter = iter + 1;\n        };\n        break;\n      case 4:\n        {\n          if (this.s[_k3] <= 0.0) {\n            this.s[_k3] = this.s[_k3] < 0.0 ? -this.s[_k3] : 0.0;\n            if (wantv) {\n              for (var _i24 = 0; _i24 <= pp; _i24++) {\n                this.V[_i24][_k3] = -this.V[_i24][_k3];\n              };\n            }\n          }\n          while (_k3 < pp) {\n            if (this.s[_k3] >= this.s[_k3 + 1]) {\n              break;\n            }\n            var _t8 = this.s[_k3];\n            this.s[_k3] = this.s[_k3 + 1];\n            this.s[_k3 + 1] = _t8;\n            if (wantv && _k3 < this.n - 1) {\n              for (var _i25 = 0; _i25 < this.n; _i25++) {\n                _t8 = this.V[_i25][_k3 + 1];\n                this.V[_i25][_k3 + 1] = this.V[_i25][_k3];\n                this.V[_i25][_k3] = _t8;\n              };\n            }\n            if (wantu && _k3 < this.m - 1) {\n              for (var _i26 = 0; _i26 < this.m; _i26++) {\n                _t8 = this.U[_i26][_k3 + 1];\n                this.U[_i26][_k3 + 1] = this.U[_i26][_k3];\n                this.U[_i26][_k3] = _t8;\n              };\n            }\n            _k3++;\n          };\n          iter = 0;\n          p--;\n        };\n        break;\n    }\n  };\n  var result = { U: this.U, V: this.V, S: this.s };\n  return result;\n};\n\n// sqrt(a^2 + b^2) without under/overflow.\nSVD.hypot = function (a, b) {\n  var r = void 0;\n  if (Math.abs(a) > Math.abs(b)) {\n    r = b / a;\n    r = Math.abs(a) * Math.sqrt(1 + r * r);\n  } else if (b != 0) {\n    r = a / b;\n    r = Math.abs(b) * Math.sqrt(1 + r * r);\n  } else {\n    r = 0.0;\n  }\n  return r;\n};\n\nmodule.exports = SVD;\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n *   Needleman-Wunsch algorithm is an procedure to compute the optimal global alignment of two string\n *   sequences by S.B.Needleman and C.D.Wunsch (1970).\n *\n *   Aside from the inputs, you can assign the scores for,\n *   - Match: The two characters at the current index are same.\n *   - Mismatch: The two characters at the current index are different.\n *   - Insertion/Deletion(gaps): The best alignment involves one letter aligning to a gap in the other string.\n */\n\nvar NeedlemanWunsch = function () {\n    function NeedlemanWunsch(sequence1, sequence2) {\n        var match_score = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n        var mismatch_penalty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n        var gap_penalty = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;\n\n        _classCallCheck(this, NeedlemanWunsch);\n\n        this.sequence1 = sequence1;\n        this.sequence2 = sequence2;\n        this.match_score = match_score;\n        this.mismatch_penalty = mismatch_penalty;\n        this.gap_penalty = gap_penalty;\n\n        // Just the remove redundancy\n        this.iMax = sequence1.length + 1;\n        this.jMax = sequence2.length + 1;\n\n        // Grid matrix of scores\n        this.grid = new Array(this.iMax);\n        for (var i = 0; i < this.iMax; i++) {\n            this.grid[i] = new Array(this.jMax);\n\n            for (var j = 0; j < this.jMax; j++) {\n                this.grid[i][j] = 0;\n            }\n        }\n\n        // Traceback matrix (2D array, each cell is an array of boolean values for [`Diag`, `Up`, `Left`] positions)\n        this.tracebackGrid = new Array(this.iMax);\n        for (var _i = 0; _i < this.iMax; _i++) {\n            this.tracebackGrid[_i] = new Array(this.jMax);\n\n            for (var _j = 0; _j < this.jMax; _j++) {\n                this.tracebackGrid[_i][_j] = [null, null, null];\n            }\n        }\n\n        // The aligned sequences (return multiple possibilities)\n        this.alignments = [];\n\n        // Final alignment score\n        this.score = -1;\n\n        // Calculate scores and tracebacks\n        this.computeGrids();\n    }\n\n    _createClass(NeedlemanWunsch, [{\n        key: \"getScore\",\n        value: function getScore() {\n            return this.score;\n        }\n    }, {\n        key: \"getAlignments\",\n        value: function getAlignments() {\n            return this.alignments;\n        }\n\n        // Main dynamic programming procedure\n\n    }, {\n        key: \"computeGrids\",\n        value: function computeGrids() {\n            // Fill in the first row\n            for (var j = 1; j < this.jMax; j++) {\n                this.grid[0][j] = this.grid[0][j - 1] + this.gap_penalty;\n                this.tracebackGrid[0][j] = [false, false, true];\n            }\n\n            // Fill in the first column\n            for (var i = 1; i < this.iMax; i++) {\n                this.grid[i][0] = this.grid[i - 1][0] + this.gap_penalty;\n                this.tracebackGrid[i][0] = [false, true, false];\n            }\n\n            // Fill the rest of the grid\n            for (var _i2 = 1; _i2 < this.iMax; _i2++) {\n                for (var _j2 = 1; _j2 < this.jMax; _j2++) {\n                    // Find the max score(s) among [`Diag`, `Up`, `Left`]\n                    var diag = void 0;\n                    if (this.sequence1[_i2 - 1] === this.sequence2[_j2 - 1]) diag = this.grid[_i2 - 1][_j2 - 1] + this.match_score;else diag = this.grid[_i2 - 1][_j2 - 1] + this.mismatch_penalty;\n\n                    var up = this.grid[_i2 - 1][_j2] + this.gap_penalty;\n                    var left = this.grid[_i2][_j2 - 1] + this.gap_penalty;\n\n                    // If there exists multiple max values, capture them for multiple paths\n                    var maxOf = [diag, up, left];\n                    var indices = this.arrayAllMaxIndexes(maxOf);\n\n                    // Update Grids\n                    this.grid[_i2][_j2] = maxOf[indices[0]];\n                    this.tracebackGrid[_i2][_j2] = [indices.includes(0), indices.includes(1), indices.includes(2)];\n                }\n            }\n\n            // Update alignment score\n            this.score = this.grid[this.iMax - 1][this.jMax - 1];\n        }\n\n        // Gets all possible valid sequence combinations\n\n    }, {\n        key: \"alignmentTraceback\",\n        value: function alignmentTraceback() {\n            var inProcessAlignments = [];\n\n            inProcessAlignments.push({ pos: [this.sequence1.length, this.sequence2.length],\n                seq1: \"\",\n                seq2: \"\"\n            });\n\n            while (inProcessAlignments[0]) {\n                var current = inProcessAlignments[0];\n                var directions = this.tracebackGrid[current.pos[0]][current.pos[1]];\n\n                if (directions[0]) {\n                    inProcessAlignments.push({ pos: [current.pos[0] - 1, current.pos[1] - 1],\n                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                    });\n                }\n                if (directions[1]) {\n                    inProcessAlignments.push({ pos: [current.pos[0] - 1, current.pos[1]],\n                        seq1: this.sequence1[current.pos[0] - 1] + current.seq1,\n                        seq2: '-' + current.seq2\n                    });\n                }\n                if (directions[2]) {\n                    inProcessAlignments.push({ pos: [current.pos[0], current.pos[1] - 1],\n                        seq1: '-' + current.seq1,\n                        seq2: this.sequence2[current.pos[1] - 1] + current.seq2\n                    });\n                }\n\n                if (current.pos[0] === 0 && current.pos[1] === 0) this.alignments.push({ sequence1: current.seq1,\n                    sequence2: current.seq2\n                });\n\n                inProcessAlignments.shift();\n            }\n\n            return this.alignments;\n        }\n\n        // Helper Functions\n\n    }, {\n        key: \"getAllIndexes\",\n        value: function getAllIndexes(arr, val) {\n            var indexes = [],\n                i = -1;\n            while ((i = arr.indexOf(val, i + 1)) !== -1) {\n                indexes.push(i);\n            }\n            return indexes;\n        }\n    }, {\n        key: \"arrayAllMaxIndexes\",\n        value: function arrayAllMaxIndexes(array) {\n            return this.getAllIndexes(array, Math.max.apply(null, array));\n        }\n    }]);\n\n    return NeedlemanWunsch;\n}();\n\nmodule.exports = NeedlemanWunsch;\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __nested_webpack_require_145732__) {\n\n\"use strict\";\n\n\nvar layoutBase = function layoutBase() {\n  return;\n};\n\nlayoutBase.FDLayout = __nested_webpack_require_145732__(18);\nlayoutBase.FDLayoutConstants = __nested_webpack_require_145732__(4);\nlayoutBase.FDLayoutEdge = __nested_webpack_require_145732__(19);\nlayoutBase.FDLayoutNode = __nested_webpack_require_145732__(20);\nlayoutBase.DimensionD = __nested_webpack_require_145732__(21);\nlayoutBase.HashMap = __nested_webpack_require_145732__(22);\nlayoutBase.HashSet = __nested_webpack_require_145732__(23);\nlayoutBase.IGeometry = __nested_webpack_require_145732__(8);\nlayoutBase.IMath = __nested_webpack_require_145732__(9);\nlayoutBase.Integer = __nested_webpack_require_145732__(10);\nlayoutBase.Point = __nested_webpack_require_145732__(12);\nlayoutBase.PointD = __nested_webpack_require_145732__(5);\nlayoutBase.RandomSeed = __nested_webpack_require_145732__(16);\nlayoutBase.RectangleD = __nested_webpack_require_145732__(13);\nlayoutBase.Transform = __nested_webpack_require_145732__(17);\nlayoutBase.UniqueIDGeneretor = __nested_webpack_require_145732__(14);\nlayoutBase.Quicksort = __nested_webpack_require_145732__(25);\nlayoutBase.LinkedList = __nested_webpack_require_145732__(11);\nlayoutBase.LGraphObject = __nested_webpack_require_145732__(2);\nlayoutBase.LGraph = __nested_webpack_require_145732__(6);\nlayoutBase.LEdge = __nested_webpack_require_145732__(1);\nlayoutBase.LGraphManager = __nested_webpack_require_145732__(7);\nlayoutBase.LNode = __nested_webpack_require_145732__(3);\nlayoutBase.Layout = __nested_webpack_require_145732__(15);\nlayoutBase.LayoutConstants = __nested_webpack_require_145732__(0);\nlayoutBase.NeedlemanWunsch = __nested_webpack_require_145732__(27);\nlayoutBase.Matrix = __nested_webpack_require_145732__(24);\nlayoutBase.SVD = __nested_webpack_require_145732__(26);\n\nmodule.exports = layoutBase;\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction Emitter() {\n  this.listeners = [];\n}\n\nvar p = Emitter.prototype;\n\np.addListener = function (event, callback) {\n  this.listeners.push({\n    event: event,\n    callback: callback\n  });\n};\n\np.removeListener = function (event, callback) {\n  for (var i = this.listeners.length; i >= 0; i--) {\n    var l = this.listeners[i];\n\n    if (l.event === event && l.callback === callback) {\n      this.listeners.splice(i, 1);\n    }\n  }\n};\n\np.emit = function (event, data) {\n  for (var i = 0; i < this.listeners.length; i++) {\n    var l = this.listeners[i];\n\n    if (event === l.event) {\n      l.callback(data);\n    }\n  }\n};\n\nmodule.exports = Emitter;\n\n/***/ })\n/******/ ]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlLWZjb3NlL25vZGVfbW9kdWxlcy9sYXlvdXQtYmFzZS9sYXlvdXQtYmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLElBQUksSUFBeUQ7QUFDN0Q7QUFDQSxNQUFNLEVBSzJCO0FBQ2pDLENBQUM7QUFDRCxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsOEJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLDhCQUFtQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QjtBQUNBO0FBQ0EsVUFBVSw4QkFBbUIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QixlQUFlLDhCQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0Esb0NBQW9DLDRCQUE0QjtBQUNoRSwwQ0FBMEM7QUFDMUMsV0FBVyw4QkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQixrQ0FBa0M7QUFDL0Q7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQSxpQkFBaUIsOEJBQW1CLENBQUMsOEJBQW1CO0FBQ3hELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBLGlDQUFpQywrQkFBbUI7O0FBRXBEOzs7QUFHQSxtQkFBbUIsK0JBQW1CO0FBQ3RDLGdCQUFnQiwrQkFBbUI7QUFDbkMsWUFBWSwrQkFBbUI7O0FBRS9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsK0JBQW1COztBQUVwRDs7O0FBR0EsbUJBQW1CLCtCQUFtQjtBQUN0QyxjQUFjLCtCQUFtQjtBQUNqQyxpQkFBaUIsK0JBQW1CO0FBQ3BDLHNCQUFzQiwrQkFBbUI7QUFDekMsaUJBQWlCLCtCQUFtQjtBQUNwQyxhQUFhLCtCQUFtQjs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUdBQXFHO0FBQ3JHOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7O0FBRXBEOzs7QUFHQSxzQkFBc0IsZ0NBQW1COztBQUV6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7O0FBRXBEOzs7QUFHQSxtQkFBbUIsZ0NBQW1CO0FBQ3RDLGNBQWMsZ0NBQW1CO0FBQ2pDLHNCQUFzQixnQ0FBbUI7QUFDekMsb0JBQW9CLGdDQUFtQjtBQUN2QyxZQUFZLGdDQUFtQjtBQUMvQixZQUFZLGdDQUFtQjtBQUMvQixpQkFBaUIsZ0NBQW1CO0FBQ3BDLFlBQVksZ0NBQW1CO0FBQy9CLGlCQUFpQixnQ0FBbUI7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGdDQUFtQjs7QUFFcEQ7OztBQUdBO0FBQ0EsWUFBWSxnQ0FBbUI7O0FBRS9CO0FBQ0EsV0FBVyxnQ0FBbUIsS0FBSztBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsZ0NBQW1COztBQUVwRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksZ0NBQW1COztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBLHFHQUFxRyxxQkFBcUIsbUJBQW1COztBQUU3STs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxnQ0FBbUI7O0FBRXBEOzs7QUFHQSxtQ0FBbUMsMEJBQTBCLDBDQUEwQyxnQkFBZ0IsT0FBTyxvQkFBb0IsZUFBZSxPQUFPOztBQUV4SyxzQkFBc0IsZ0NBQW1CO0FBQ3pDLG9CQUFvQixnQ0FBbUI7QUFDdkMsWUFBWSxnQ0FBbUI7QUFDL0IsWUFBWSxnQ0FBbUI7QUFDL0IsYUFBYSxnQ0FBbUI7QUFDaEMsYUFBYSxnQ0FBbUI7QUFDaEMsZ0JBQWdCLGdDQUFtQjtBQUNuQyxjQUFjLGdDQUFtQjs7QUFFakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQSw4Q0FBOEM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0Msc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLE9BQU87O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw4QkFBOEIsY0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsYUFBYTtBQUMxQyxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUM7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixlQUFlO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQyx5QkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQSwrQkFBK0IsVUFBVTtBQUN6QztBQUNBLDhCQUE4QixlQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixlQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsMkJBQTJCLGVBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsVUFBVTtBQUN6QztBQUNBO0FBQ0EsT0FBTztBQUNQLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0EsbUNBQW1DLGVBQWU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGVBQWU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBUztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGFBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsWUFBWTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQSxpQ0FBaUMsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsK0RBQStELHlEQUF5RCxxRUFBcUUsNkRBQTZELHdCQUF3Qjs7QUFFampCLGtEQUFrRCwwQ0FBMEM7O0FBRTVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsZUFBZTtBQUN2Qzs7QUFFQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0I7QUFDekM7O0FBRUEsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsaUJBQWlCO0FBQy9DLGtDQUFrQyxpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBLG1JQUFtSTs7QUFFbkk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQSx5RkFBeUY7QUFDekY7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQ7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsaUNBQW1CO0FBQ3pDLCtCQUErQixpQ0FBbUI7QUFDbEQsMEJBQTBCLGlDQUFtQjtBQUM3QywwQkFBMEIsaUNBQW1CO0FBQzdDLHdCQUF3QixpQ0FBbUI7QUFDM0MscUJBQXFCLGlDQUFtQjtBQUN4QyxxQkFBcUIsaUNBQW1CO0FBQ3hDLHVCQUF1QixpQ0FBbUI7QUFDMUMsbUJBQW1CLGlDQUFtQjtBQUN0QyxxQkFBcUIsaUNBQW1CO0FBQ3hDLG1CQUFtQixpQ0FBbUI7QUFDdEMsb0JBQW9CLGlDQUFtQjtBQUN2Qyx3QkFBd0IsaUNBQW1CO0FBQzNDLHdCQUF3QixpQ0FBbUI7QUFDM0MsdUJBQXVCLGlDQUFtQjtBQUMxQywrQkFBK0IsaUNBQW1CO0FBQ2xELHVCQUF1QixpQ0FBbUI7QUFDMUMsd0JBQXdCLGlDQUFtQjtBQUMzQywwQkFBMEIsaUNBQW1CO0FBQzdDLG9CQUFvQixpQ0FBbUI7QUFDdkMsbUJBQW1CLGlDQUFtQjtBQUN0QywyQkFBMkIsaUNBQW1CO0FBQzlDLG1CQUFtQixpQ0FBbUI7QUFDdEMsb0JBQW9CLGlDQUFtQjtBQUN2Qyw2QkFBNkIsaUNBQW1CO0FBQ2hELDZCQUE2QixpQ0FBbUI7QUFDaEQsb0JBQW9CLGlDQUFtQjtBQUN2QyxpQkFBaUIsaUNBQW1COztBQUVwQzs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQiwyQkFBMkI7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViY2xpLWRlbW8vLi9ub2RlX21vZHVsZXMvY3l0b3NjYXBlLWZjb3NlL25vZGVfbW9kdWxlcy9sYXlvdXQtYmFzZS9sYXlvdXQtYmFzZS5qcz85Y2UwIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcImxheW91dEJhc2VcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wibGF5b3V0QmFzZVwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBpZGVudGl0eSBmdW5jdGlvbiBmb3IgY2FsbGluZyBoYXJtb255IGltcG9ydHMgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uaSA9IGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB2YWx1ZTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gXHRcdFx0XHRnZXQ6IGdldHRlclxuLyoqKioqKi8gXHRcdFx0fSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDI4KTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gTGF5b3V0Q29uc3RhbnRzKCkge31cblxuLyoqXHJcbiAqIExheW91dCBRdWFsaXR5OiAwOmRyYWZ0LCAxOmRlZmF1bHQsIDI6cHJvb2ZcclxuICovXG5MYXlvdXRDb25zdGFudHMuUVVBTElUWSA9IDE7XG5cbi8qKlxyXG4gKiBEZWZhdWx0IHBhcmFtZXRlcnNcclxuICovXG5MYXlvdXRDb25zdGFudHMuREVGQVVMVF9DUkVBVEVfQkVORFNfQVNfTkVFREVEID0gZmFsc2U7XG5MYXlvdXRDb25zdGFudHMuREVGQVVMVF9JTkNSRU1FTlRBTCA9IGZhbHNlO1xuTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQU5JTUFUSU9OX09OX0xBWU9VVCA9IHRydWU7XG5MYXlvdXRDb25zdGFudHMuREVGQVVMVF9BTklNQVRJT05fRFVSSU5HX0xBWU9VVCA9IGZhbHNlO1xuTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQU5JTUFUSU9OX1BFUklPRCA9IDUwO1xuTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfVU5JRk9STV9MRUFGX05PREVfU0laRVMgPSBmYWxzZTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFNlY3Rpb246IEdlbmVyYWwgb3RoZXIgY29uc3RhbnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLypcclxuICogTWFyZ2lucyBvZiBhIGdyYXBoIHRvIGJlIGFwcGxpZWQgb24gYm91ZGluZyByZWN0YW5nbGUgb2YgaXRzIGNvbnRlbnRzLiBXZVxyXG4gKiBhc3N1bWUgbWFyZ2lucyBvbiBhbGwgZm91ciBzaWRlcyB0byBiZSB1bmlmb3JtLlxyXG4gKi9cbkxheW91dENvbnN0YW50cy5ERUZBVUxUX0dSQVBIX01BUkdJTiA9IDE1O1xuXG4vKlxyXG4gKiBXaGV0aGVyIHRvIGNvbnNpZGVyIGxhYmVscyBpbiBub2RlIGRpbWVuc2lvbnMgb3Igbm90XHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLk5PREVfRElNRU5TSU9OU19JTkNMVURFX0xBQkVMUyA9IGZhbHNlO1xuXG4vKlxyXG4gKiBEZWZhdWx0IGRpbWVuc2lvbiBvZiBhIG5vbi1jb21wb3VuZCBub2RlLlxyXG4gKi9cbkxheW91dENvbnN0YW50cy5TSU1QTEVfTk9ERV9TSVpFID0gNDA7XG5cbi8qXHJcbiAqIERlZmF1bHQgZGltZW5zaW9uIG9mIGEgbm9uLWNvbXBvdW5kIG5vZGUuXHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLlNJTVBMRV9OT0RFX0hBTEZfU0laRSA9IExheW91dENvbnN0YW50cy5TSU1QTEVfTk9ERV9TSVpFIC8gMjtcblxuLypcclxuICogRW1wdHkgY29tcG91bmQgbm9kZSBzaXplLiBXaGVuIGEgY29tcG91bmQgbm9kZSBpcyBlbXB0eSwgaXRzIGJvdGhcclxuICogZGltZW5zaW9ucyBzaG91bGQgYmUgb2YgdGhpcyB2YWx1ZS5cclxuICovXG5MYXlvdXRDb25zdGFudHMuRU1QVFlfQ09NUE9VTkRfTk9ERV9TSVpFID0gNDA7XG5cbi8qXHJcbiAqIE1pbmltdW0gbGVuZ3RoIHRoYXQgYW4gZWRnZSBzaG91bGQgdGFrZSBkdXJpbmcgbGF5b3V0XHJcbiAqL1xuTGF5b3V0Q29uc3RhbnRzLk1JTl9FREdFX0xFTkdUSCA9IDE7XG5cbi8qXHJcbiAqIFdvcmxkIGJvdW5kYXJpZXMgdGhhdCBsYXlvdXQgb3BlcmF0ZXMgb25cclxuICovXG5MYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlkgPSAxMDAwMDAwO1xuXG4vKlxyXG4gKiBXb3JsZCBib3VuZGFyaWVzIHRoYXQgcmFuZG9tIHBvc2l0aW9uaW5nIGNhbiBiZSBwZXJmb3JtZWQgd2l0aFxyXG4gKi9cbkxheW91dENvbnN0YW50cy5JTklUSUFMX1dPUkxEX0JPVU5EQVJZID0gTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZIC8gMTAwMDtcblxuLypcclxuICogQ29vcmRpbmF0ZXMgb2YgdGhlIHdvcmxkIGNlbnRlclxyXG4gKi9cbkxheW91dENvbnN0YW50cy5XT1JMRF9DRU5URVJfWCA9IDEyMDA7XG5MYXlvdXRDb25zdGFudHMuV09STERfQ0VOVEVSX1kgPSA5MDA7XG5cbm1vZHVsZS5leHBvcnRzID0gTGF5b3V0Q29uc3RhbnRzO1xuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIExHcmFwaE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgSUdlb21ldHJ5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbnZhciBJTWF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbmZ1bmN0aW9uIExFZGdlKHNvdXJjZSwgdGFyZ2V0LCB2RWRnZSkge1xuICBMR3JhcGhPYmplY3QuY2FsbCh0aGlzLCB2RWRnZSk7XG5cbiAgdGhpcy5pc092ZXJsYXBpbmdTb3VyY2VBbmRUYXJnZXQgPSBmYWxzZTtcbiAgdGhpcy52R3JhcGhPYmplY3QgPSB2RWRnZTtcbiAgdGhpcy5iZW5kcG9pbnRzID0gW107XG4gIHRoaXMuc291cmNlID0gc291cmNlO1xuICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbn1cblxuTEVkZ2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMR3JhcGhPYmplY3QucHJvdG90eXBlKTtcblxuZm9yICh2YXIgcHJvcCBpbiBMR3JhcGhPYmplY3QpIHtcbiAgTEVkZ2VbcHJvcF0gPSBMR3JhcGhPYmplY3RbcHJvcF07XG59XG5cbkxFZGdlLnByb3RvdHlwZS5nZXRTb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnNvdXJjZTtcbn07XG5cbkxFZGdlLnByb3RvdHlwZS5nZXRUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnRhcmdldDtcbn07XG5cbkxFZGdlLnByb3RvdHlwZS5pc0ludGVyR3JhcGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmlzSW50ZXJHcmFwaDtcbn07XG5cbkxFZGdlLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxlbmd0aDtcbn07XG5cbkxFZGdlLnByb3RvdHlwZS5pc092ZXJsYXBpbmdTb3VyY2VBbmRUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmlzT3ZlcmxhcGluZ1NvdXJjZUFuZFRhcmdldDtcbn07XG5cbkxFZGdlLnByb3RvdHlwZS5nZXRCZW5kcG9pbnRzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5iZW5kcG9pbnRzO1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmdldExjYSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGNhO1xufTtcblxuTEVkZ2UucHJvdG90eXBlLmdldFNvdXJjZUluTGNhID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zb3VyY2VJbkxjYTtcbn07XG5cbkxFZGdlLnByb3RvdHlwZS5nZXRUYXJnZXRJbkxjYSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudGFyZ2V0SW5MY2E7XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuZ2V0T3RoZXJFbmQgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAodGhpcy5zb3VyY2UgPT09IG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy50YXJnZXQ7XG4gIH0gZWxzZSBpZiAodGhpcy50YXJnZXQgPT09IG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2U7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgXCJOb2RlIGlzIG5vdCBpbmNpZGVudCB3aXRoIHRoaXMgZWRnZVwiO1xuICB9XG59O1xuXG5MRWRnZS5wcm90b3R5cGUuZ2V0T3RoZXJFbmRJbkdyYXBoID0gZnVuY3Rpb24gKG5vZGUsIGdyYXBoKSB7XG4gIHZhciBvdGhlckVuZCA9IHRoaXMuZ2V0T3RoZXJFbmQobm9kZSk7XG4gIHZhciByb290ID0gZ3JhcGguZ2V0R3JhcGhNYW5hZ2VyKCkuZ2V0Um9vdCgpO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKG90aGVyRW5kLmdldE93bmVyKCkgPT0gZ3JhcGgpIHtcbiAgICAgIHJldHVybiBvdGhlckVuZDtcbiAgICB9XG5cbiAgICBpZiAob3RoZXJFbmQuZ2V0T3duZXIoKSA9PSByb290KSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBvdGhlckVuZCA9IG90aGVyRW5kLmdldE93bmVyKCkuZ2V0UGFyZW50KCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbkxFZGdlLnByb3RvdHlwZS51cGRhdGVMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjbGlwUG9pbnRDb29yZGluYXRlcyA9IG5ldyBBcnJheSg0KTtcblxuICB0aGlzLmlzT3ZlcmxhcGluZ1NvdXJjZUFuZFRhcmdldCA9IElHZW9tZXRyeS5nZXRJbnRlcnNlY3Rpb24odGhpcy50YXJnZXQuZ2V0UmVjdCgpLCB0aGlzLnNvdXJjZS5nZXRSZWN0KCksIGNsaXBQb2ludENvb3JkaW5hdGVzKTtcblxuICBpZiAoIXRoaXMuaXNPdmVybGFwaW5nU291cmNlQW5kVGFyZ2V0KSB7XG4gICAgdGhpcy5sZW5ndGhYID0gY2xpcFBvaW50Q29vcmRpbmF0ZXNbMF0gLSBjbGlwUG9pbnRDb29yZGluYXRlc1syXTtcbiAgICB0aGlzLmxlbmd0aFkgPSBjbGlwUG9pbnRDb29yZGluYXRlc1sxXSAtIGNsaXBQb2ludENvb3JkaW5hdGVzWzNdO1xuXG4gICAgaWYgKE1hdGguYWJzKHRoaXMubGVuZ3RoWCkgPCAxLjApIHtcbiAgICAgIHRoaXMubGVuZ3RoWCA9IElNYXRoLnNpZ24odGhpcy5sZW5ndGhYKTtcbiAgICB9XG5cbiAgICBpZiAoTWF0aC5hYnModGhpcy5sZW5ndGhZKSA8IDEuMCkge1xuICAgICAgdGhpcy5sZW5ndGhZID0gSU1hdGguc2lnbih0aGlzLmxlbmd0aFkpO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5zcXJ0KHRoaXMubGVuZ3RoWCAqIHRoaXMubGVuZ3RoWCArIHRoaXMubGVuZ3RoWSAqIHRoaXMubGVuZ3RoWSk7XG4gIH1cbn07XG5cbkxFZGdlLnByb3RvdHlwZS51cGRhdGVMZW5ndGhTaW1wbGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubGVuZ3RoWCA9IHRoaXMudGFyZ2V0LmdldENlbnRlclgoKSAtIHRoaXMuc291cmNlLmdldENlbnRlclgoKTtcbiAgdGhpcy5sZW5ndGhZID0gdGhpcy50YXJnZXQuZ2V0Q2VudGVyWSgpIC0gdGhpcy5zb3VyY2UuZ2V0Q2VudGVyWSgpO1xuXG4gIGlmIChNYXRoLmFicyh0aGlzLmxlbmd0aFgpIDwgMS4wKSB7XG4gICAgdGhpcy5sZW5ndGhYID0gSU1hdGguc2lnbih0aGlzLmxlbmd0aFgpO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKHRoaXMubGVuZ3RoWSkgPCAxLjApIHtcbiAgICB0aGlzLmxlbmd0aFkgPSBJTWF0aC5zaWduKHRoaXMubGVuZ3RoWSk7XG4gIH1cblxuICB0aGlzLmxlbmd0aCA9IE1hdGguc3FydCh0aGlzLmxlbmd0aFggKiB0aGlzLmxlbmd0aFggKyB0aGlzLmxlbmd0aFkgKiB0aGlzLmxlbmd0aFkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMRWRnZTtcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIExHcmFwaE9iamVjdCh2R3JhcGhPYmplY3QpIHtcbiAgdGhpcy52R3JhcGhPYmplY3QgPSB2R3JhcGhPYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTEdyYXBoT2JqZWN0O1xuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIExHcmFwaE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG52YXIgSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xudmFyIFJlY3RhbmdsZUQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbnZhciBMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIFJhbmRvbVNlZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcbnZhciBQb2ludEQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG5mdW5jdGlvbiBMTm9kZShnbSwgbG9jLCBzaXplLCB2Tm9kZSkge1xuICAvL0FsdGVybmF0aXZlIGNvbnN0cnVjdG9yIDEgOiBMTm9kZShMR3JhcGhNYW5hZ2VyIGdtLCBQb2ludCBsb2MsIERpbWVuc2lvbiBzaXplLCBPYmplY3Qgdk5vZGUpXG4gIGlmIChzaXplID09IG51bGwgJiYgdk5vZGUgPT0gbnVsbCkge1xuICAgIHZOb2RlID0gbG9jO1xuICB9XG5cbiAgTEdyYXBoT2JqZWN0LmNhbGwodGhpcywgdk5vZGUpO1xuXG4gIC8vQWx0ZXJuYXRpdmUgY29uc3RydWN0b3IgMiA6IExOb2RlKExheW91dCBsYXlvdXQsIE9iamVjdCB2Tm9kZSlcbiAgaWYgKGdtLmdyYXBoTWFuYWdlciAhPSBudWxsKSBnbSA9IGdtLmdyYXBoTWFuYWdlcjtcblxuICB0aGlzLmVzdGltYXRlZFNpemUgPSBJbnRlZ2VyLk1JTl9WQUxVRTtcbiAgdGhpcy5pbmNsdXNpb25UcmVlRGVwdGggPSBJbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdGhpcy52R3JhcGhPYmplY3QgPSB2Tm9kZTtcbiAgdGhpcy5lZGdlcyA9IFtdO1xuICB0aGlzLmdyYXBoTWFuYWdlciA9IGdtO1xuXG4gIGlmIChzaXplICE9IG51bGwgJiYgbG9jICE9IG51bGwpIHRoaXMucmVjdCA9IG5ldyBSZWN0YW5nbGVEKGxvYy54LCBsb2MueSwgc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO2Vsc2UgdGhpcy5yZWN0ID0gbmV3IFJlY3RhbmdsZUQoKTtcbn1cblxuTE5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMR3JhcGhPYmplY3QucHJvdG90eXBlKTtcbmZvciAodmFyIHByb3AgaW4gTEdyYXBoT2JqZWN0KSB7XG4gIExOb2RlW3Byb3BdID0gTEdyYXBoT2JqZWN0W3Byb3BdO1xufVxuXG5MTm9kZS5wcm90b3R5cGUuZ2V0RWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmVkZ2VzO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldENoaWxkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jaGlsZDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRPd25lciA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gIGlmICh0aGlzLm93bmVyICE9IG51bGwpIHtcbiAgLy8gICAgaWYgKCEodGhpcy5vd25lciA9PSBudWxsIHx8IHRoaXMub3duZXIuZ2V0Tm9kZXMoKS5pbmRleE9mKHRoaXMpID4gLTEpKSB7XG4gIC8vICAgICAgdGhyb3cgXCJhc3NlcnQgZmFpbGVkXCI7XG4gIC8vICAgIH1cbiAgLy8gIH1cblxuICByZXR1cm4gdGhpcy5vd25lcjtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVjdC53aWR0aDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5zZXRXaWR0aCA9IGZ1bmN0aW9uICh3aWR0aCkge1xuICB0aGlzLnJlY3Qud2lkdGggPSB3aWR0aDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlY3QuaGVpZ2h0O1xufTtcblxuTE5vZGUucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQpIHtcbiAgdGhpcy5yZWN0LmhlaWdodCA9IGhlaWdodDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRDZW50ZXJYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWN0LnggKyB0aGlzLnJlY3Qud2lkdGggLyAyO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldENlbnRlclkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlY3QueSArIHRoaXMucmVjdC5oZWlnaHQgLyAyO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldENlbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBQb2ludEQodGhpcy5yZWN0LnggKyB0aGlzLnJlY3Qud2lkdGggLyAyLCB0aGlzLnJlY3QueSArIHRoaXMucmVjdC5oZWlnaHQgLyAyKTtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRMb2NhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBQb2ludEQodGhpcy5yZWN0LngsIHRoaXMucmVjdC55KTtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRSZWN0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWN0O1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldERpYWdvbmFsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMucmVjdC53aWR0aCAqIHRoaXMucmVjdC53aWR0aCArIHRoaXMucmVjdC5oZWlnaHQgKiB0aGlzLnJlY3QuaGVpZ2h0KTtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBoYWxmIHRoZSBkaWFnb25hbCBsZW5ndGggb2YgdGhpcyBub2RlLlxuICovXG5MTm9kZS5wcm90b3R5cGUuZ2V0SGFsZlRoZURpYWdvbmFsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMucmVjdC5oZWlnaHQgKiB0aGlzLnJlY3QuaGVpZ2h0ICsgdGhpcy5yZWN0LndpZHRoICogdGhpcy5yZWN0LndpZHRoKSAvIDI7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuc2V0UmVjdCA9IGZ1bmN0aW9uICh1cHBlckxlZnQsIGRpbWVuc2lvbikge1xuICB0aGlzLnJlY3QueCA9IHVwcGVyTGVmdC54O1xuICB0aGlzLnJlY3QueSA9IHVwcGVyTGVmdC55O1xuICB0aGlzLnJlY3Qud2lkdGggPSBkaW1lbnNpb24ud2lkdGg7XG4gIHRoaXMucmVjdC5oZWlnaHQgPSBkaW1lbnNpb24uaGVpZ2h0O1xufTtcblxuTE5vZGUucHJvdG90eXBlLnNldENlbnRlciA9IGZ1bmN0aW9uIChjeCwgY3kpIHtcbiAgdGhpcy5yZWN0LnggPSBjeCAtIHRoaXMucmVjdC53aWR0aCAvIDI7XG4gIHRoaXMucmVjdC55ID0gY3kgLSB0aGlzLnJlY3QuaGVpZ2h0IC8gMjtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5zZXRMb2NhdGlvbiA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gIHRoaXMucmVjdC54ID0geDtcbiAgdGhpcy5yZWN0LnkgPSB5O1xufTtcblxuTE5vZGUucHJvdG90eXBlLm1vdmVCeSA9IGZ1bmN0aW9uIChkeCwgZHkpIHtcbiAgdGhpcy5yZWN0LnggKz0gZHg7XG4gIHRoaXMucmVjdC55ICs9IGR5O1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldEVkZ2VMaXN0VG9Ob2RlID0gZnVuY3Rpb24gKHRvKSB7XG4gIHZhciBlZGdlTGlzdCA9IFtdO1xuICB2YXIgZWRnZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHNlbGYuZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuXG4gICAgaWYgKGVkZ2UudGFyZ2V0ID09IHRvKSB7XG4gICAgICBpZiAoZWRnZS5zb3VyY2UgIT0gc2VsZikgdGhyb3cgXCJJbmNvcnJlY3QgZWRnZSBzb3VyY2UhXCI7XG5cbiAgICAgIGVkZ2VMaXN0LnB1c2goZWRnZSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZWRnZUxpc3Q7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0RWRnZXNCZXR3ZWVuID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIHZhciBlZGdlTGlzdCA9IFtdO1xuICB2YXIgZWRnZTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYuZWRnZXMuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkge1xuXG4gICAgaWYgKCEoZWRnZS5zb3VyY2UgPT0gc2VsZiB8fCBlZGdlLnRhcmdldCA9PSBzZWxmKSkgdGhyb3cgXCJJbmNvcnJlY3QgZWRnZSBzb3VyY2UgYW5kL29yIHRhcmdldFwiO1xuXG4gICAgaWYgKGVkZ2UudGFyZ2V0ID09IG90aGVyIHx8IGVkZ2Uuc291cmNlID09IG90aGVyKSB7XG4gICAgICBlZGdlTGlzdC5wdXNoKGVkZ2UpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGVkZ2VMaXN0O1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldE5laWdoYm9yc0xpc3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBuZWlnaGJvcnMgPSBuZXcgU2V0KCk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLmVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcblxuICAgIGlmIChlZGdlLnNvdXJjZSA9PSBzZWxmKSB7XG4gICAgICBuZWlnaGJvcnMuYWRkKGVkZ2UudGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVkZ2UudGFyZ2V0ICE9IHNlbGYpIHtcbiAgICAgICAgdGhyb3cgXCJJbmNvcnJlY3QgaW5jaWRlbmN5IVwiO1xuICAgICAgfVxuXG4gICAgICBuZWlnaGJvcnMuYWRkKGVkZ2Uuc291cmNlKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBuZWlnaGJvcnM7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUud2l0aENoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgd2l0aE5laWdoYm9yc0xpc3QgPSBuZXcgU2V0KCk7XG4gIHZhciBjaGlsZE5vZGU7XG4gIHZhciBjaGlsZHJlbjtcblxuICB3aXRoTmVpZ2hib3JzTGlzdC5hZGQodGhpcyk7XG5cbiAgaWYgKHRoaXMuY2hpbGQgIT0gbnVsbCkge1xuICAgIHZhciBub2RlcyA9IHRoaXMuY2hpbGQuZ2V0Tm9kZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZE5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGNoaWxkcmVuID0gY2hpbGROb2RlLndpdGhDaGlsZHJlbigpO1xuICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB3aXRoTmVpZ2hib3JzTGlzdC5hZGQobm9kZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd2l0aE5laWdoYm9yc0xpc3Q7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0Tm9PZkNoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9PZkNoaWxkcmVuID0gMDtcbiAgdmFyIGNoaWxkTm9kZTtcblxuICBpZiAodGhpcy5jaGlsZCA9PSBudWxsKSB7XG4gICAgbm9PZkNoaWxkcmVuID0gMTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbm9kZXMgPSB0aGlzLmNoaWxkLmdldE5vZGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGROb2RlID0gbm9kZXNbaV07XG5cbiAgICAgIG5vT2ZDaGlsZHJlbiArPSBjaGlsZE5vZGUuZ2V0Tm9PZkNoaWxkcmVuKCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG5vT2ZDaGlsZHJlbiA9PSAwKSB7XG4gICAgbm9PZkNoaWxkcmVuID0gMTtcbiAgfVxuICByZXR1cm4gbm9PZkNoaWxkcmVuO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmdldEVzdGltYXRlZFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmVzdGltYXRlZFNpemUgPT0gSW50ZWdlci5NSU5fVkFMVUUpIHtcbiAgICB0aHJvdyBcImFzc2VydCBmYWlsZWRcIjtcbiAgfVxuICByZXR1cm4gdGhpcy5lc3RpbWF0ZWRTaXplO1xufTtcblxuTE5vZGUucHJvdG90eXBlLmNhbGNFc3RpbWF0ZWRTaXplID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5jaGlsZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVkU2l6ZSA9ICh0aGlzLnJlY3Qud2lkdGggKyB0aGlzLnJlY3QuaGVpZ2h0KSAvIDI7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5lc3RpbWF0ZWRTaXplID0gdGhpcy5jaGlsZC5jYWxjRXN0aW1hdGVkU2l6ZSgpO1xuICAgIHRoaXMucmVjdC53aWR0aCA9IHRoaXMuZXN0aW1hdGVkU2l6ZTtcbiAgICB0aGlzLnJlY3QuaGVpZ2h0ID0gdGhpcy5lc3RpbWF0ZWRTaXplO1xuXG4gICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVkU2l6ZTtcbiAgfVxufTtcblxuTE5vZGUucHJvdG90eXBlLnNjYXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciByYW5kb21DZW50ZXJYO1xuICB2YXIgcmFuZG9tQ2VudGVyWTtcblxuICB2YXIgbWluWCA9IC1MYXlvdXRDb25zdGFudHMuSU5JVElBTF9XT1JMRF9CT1VOREFSWTtcbiAgdmFyIG1heFggPSBMYXlvdXRDb25zdGFudHMuSU5JVElBTF9XT1JMRF9CT1VOREFSWTtcbiAgcmFuZG9tQ2VudGVyWCA9IExheW91dENvbnN0YW50cy5XT1JMRF9DRU5URVJfWCArIFJhbmRvbVNlZWQubmV4dERvdWJsZSgpICogKG1heFggLSBtaW5YKSArIG1pblg7XG5cbiAgdmFyIG1pblkgPSAtTGF5b3V0Q29uc3RhbnRzLklOSVRJQUxfV09STERfQk9VTkRBUlk7XG4gIHZhciBtYXhZID0gTGF5b3V0Q29uc3RhbnRzLklOSVRJQUxfV09STERfQk9VTkRBUlk7XG4gIHJhbmRvbUNlbnRlclkgPSBMYXlvdXRDb25zdGFudHMuV09STERfQ0VOVEVSX1kgKyBSYW5kb21TZWVkLm5leHREb3VibGUoKSAqIChtYXhZIC0gbWluWSkgKyBtaW5ZO1xuXG4gIHRoaXMucmVjdC54ID0gcmFuZG9tQ2VudGVyWDtcbiAgdGhpcy5yZWN0LnkgPSByYW5kb21DZW50ZXJZO1xufTtcblxuTE5vZGUucHJvdG90eXBlLnVwZGF0ZUJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuZ2V0Q2hpbGQoKSA9PSBudWxsKSB7XG4gICAgdGhyb3cgXCJhc3NlcnQgZmFpbGVkXCI7XG4gIH1cbiAgaWYgKHRoaXMuZ2V0Q2hpbGQoKS5nZXROb2RlcygpLmxlbmd0aCAhPSAwKSB7XG4gICAgLy8gd3JhcCB0aGUgY2hpbGRyZW4gbm9kZXMgYnkgcmUtYXJyYW5naW5nIHRoZSBib3VuZGFyaWVzXG4gICAgdmFyIGNoaWxkR3JhcGggPSB0aGlzLmdldENoaWxkKCk7XG4gICAgY2hpbGRHcmFwaC51cGRhdGVCb3VuZHModHJ1ZSk7XG5cbiAgICB0aGlzLnJlY3QueCA9IGNoaWxkR3JhcGguZ2V0TGVmdCgpO1xuICAgIHRoaXMucmVjdC55ID0gY2hpbGRHcmFwaC5nZXRUb3AoKTtcblxuICAgIHRoaXMuc2V0V2lkdGgoY2hpbGRHcmFwaC5nZXRSaWdodCgpIC0gY2hpbGRHcmFwaC5nZXRMZWZ0KCkpO1xuICAgIHRoaXMuc2V0SGVpZ2h0KGNoaWxkR3JhcGguZ2V0Qm90dG9tKCkgLSBjaGlsZEdyYXBoLmdldFRvcCgpKTtcblxuICAgIC8vIFVwZGF0ZSBjb21wb3VuZCBib3VuZHMgY29uc2lkZXJpbmcgaXRzIGxhYmVsIHByb3BlcnRpZXMgICAgXG4gICAgaWYgKExheW91dENvbnN0YW50cy5OT0RFX0RJTUVOU0lPTlNfSU5DTFVERV9MQUJFTFMpIHtcblxuICAgICAgdmFyIHdpZHRoID0gY2hpbGRHcmFwaC5nZXRSaWdodCgpIC0gY2hpbGRHcmFwaC5nZXRMZWZ0KCk7XG4gICAgICB2YXIgaGVpZ2h0ID0gY2hpbGRHcmFwaC5nZXRCb3R0b20oKSAtIGNoaWxkR3JhcGguZ2V0VG9wKCk7XG5cbiAgICAgIGlmICh0aGlzLmxhYmVsV2lkdGgpIHtcbiAgICAgICAgaWYgKHRoaXMubGFiZWxQb3NIb3Jpem9udGFsID09IFwibGVmdFwiKSB7XG4gICAgICAgICAgdGhpcy5yZWN0LnggLT0gdGhpcy5sYWJlbFdpZHRoO1xuICAgICAgICAgIHRoaXMuc2V0V2lkdGgod2lkdGggKyB0aGlzLmxhYmVsV2lkdGgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGFiZWxQb3NIb3Jpem9udGFsID09IFwiY2VudGVyXCIgJiYgdGhpcy5sYWJlbFdpZHRoID4gd2lkdGgpIHtcbiAgICAgICAgICB0aGlzLnJlY3QueCAtPSAodGhpcy5sYWJlbFdpZHRoIC0gd2lkdGgpIC8gMjtcbiAgICAgICAgICB0aGlzLnNldFdpZHRoKHRoaXMubGFiZWxXaWR0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5sYWJlbFBvc0hvcml6b250YWwgPT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgdGhpcy5zZXRXaWR0aCh3aWR0aCArIHRoaXMubGFiZWxXaWR0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubGFiZWxIZWlnaHQpIHtcbiAgICAgICAgaWYgKHRoaXMubGFiZWxQb3NWZXJ0aWNhbCA9PSBcInRvcFwiKSB7XG4gICAgICAgICAgdGhpcy5yZWN0LnkgLT0gdGhpcy5sYWJlbEhlaWdodDtcbiAgICAgICAgICB0aGlzLnNldEhlaWdodChoZWlnaHQgKyB0aGlzLmxhYmVsSGVpZ2h0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxhYmVsUG9zVmVydGljYWwgPT0gXCJjZW50ZXJcIiAmJiB0aGlzLmxhYmVsSGVpZ2h0ID4gaGVpZ2h0KSB7XG4gICAgICAgICAgdGhpcy5yZWN0LnkgLT0gKHRoaXMubGFiZWxIZWlnaHQgLSBoZWlnaHQpIC8gMjtcbiAgICAgICAgICB0aGlzLnNldEhlaWdodCh0aGlzLmxhYmVsSGVpZ2h0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxhYmVsUG9zVmVydGljYWwgPT0gXCJib3R0b21cIikge1xuICAgICAgICAgIHRoaXMuc2V0SGVpZ2h0KGhlaWdodCArIHRoaXMubGFiZWxIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0SW5jbHVzaW9uVHJlZURlcHRoID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5pbmNsdXNpb25UcmVlRGVwdGggPT0gSW50ZWdlci5NQVhfVkFMVUUpIHtcbiAgICB0aHJvdyBcImFzc2VydCBmYWlsZWRcIjtcbiAgfVxuICByZXR1cm4gdGhpcy5pbmNsdXNpb25UcmVlRGVwdGg7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKHRyYW5zKSB7XG4gIHZhciBsZWZ0ID0gdGhpcy5yZWN0Lng7XG5cbiAgaWYgKGxlZnQgPiBMYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlkpIHtcbiAgICBsZWZ0ID0gTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZO1xuICB9IGVsc2UgaWYgKGxlZnQgPCAtTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZKSB7XG4gICAgbGVmdCA9IC1MYXlvdXRDb25zdGFudHMuV09STERfQk9VTkRBUlk7XG4gIH1cblxuICB2YXIgdG9wID0gdGhpcy5yZWN0Lnk7XG5cbiAgaWYgKHRvcCA+IExheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWSkge1xuICAgIHRvcCA9IExheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWTtcbiAgfSBlbHNlIGlmICh0b3AgPCAtTGF5b3V0Q29uc3RhbnRzLldPUkxEX0JPVU5EQVJZKSB7XG4gICAgdG9wID0gLUxheW91dENvbnN0YW50cy5XT1JMRF9CT1VOREFSWTtcbiAgfVxuXG4gIHZhciBsZWZ0VG9wID0gbmV3IFBvaW50RChsZWZ0LCB0b3ApO1xuICB2YXIgdkxlZnRUb3AgPSB0cmFucy5pbnZlcnNlVHJhbnNmb3JtUG9pbnQobGVmdFRvcCk7XG5cbiAgdGhpcy5zZXRMb2NhdGlvbih2TGVmdFRvcC54LCB2TGVmdFRvcC55KTtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5yZWN0Lng7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0UmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlY3QueCArIHRoaXMucmVjdC53aWR0aDtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRUb3AgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlY3QueTtcbn07XG5cbkxOb2RlLnByb3RvdHlwZS5nZXRCb3R0b20gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJlY3QueSArIHRoaXMucmVjdC5oZWlnaHQ7XG59O1xuXG5MTm9kZS5wcm90b3R5cGUuZ2V0UGFyZW50ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5vd25lciA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gdGhpcy5vd25lci5nZXRQYXJlbnQoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTE5vZGU7XG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgTGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuZnVuY3Rpb24gRkRMYXlvdXRDb25zdGFudHMoKSB7fVxuXG4vL0ZETGF5b3V0Q29uc3RhbnRzIGluaGVyaXRzIHN0YXRpYyBwcm9wcyBpbiBMYXlvdXRDb25zdGFudHNcbmZvciAodmFyIHByb3AgaW4gTGF5b3V0Q29uc3RhbnRzKSB7XG4gIEZETGF5b3V0Q29uc3RhbnRzW3Byb3BdID0gTGF5b3V0Q29uc3RhbnRzW3Byb3BdO1xufVxuXG5GRExheW91dENvbnN0YW50cy5NQVhfSVRFUkFUSU9OUyA9IDI1MDA7XG5cbkZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggPSA1MDtcbkZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfU1BSSU5HX1NUUkVOR1RIID0gMC40NTtcbkZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfUkVQVUxTSU9OX1NUUkVOR1RIID0gNDUwMC4wO1xuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1NUUkVOR1RIID0gMC40O1xuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1NUUkVOR1RIID0gMS4wO1xuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1JBTkdFX0ZBQ1RPUiA9IDMuODtcbkZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ09NUE9VTkRfR1JBVklUWV9SQU5HRV9GQUNUT1IgPSAxLjU7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX1VTRV9TTUFSVF9JREVBTF9FREdFX0xFTkdUSF9DQUxDVUxBVElPTiA9IHRydWU7XG5GRExheW91dENvbnN0YW50cy5ERUZBVUxUX1VTRV9TTUFSVF9SRVBVTFNJT05fUkFOR0VfQ0FMQ1VMQVRJT04gPSB0cnVlO1xuRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT09MSU5HX0ZBQ1RPUl9JTkNSRU1FTlRBTCA9IDAuMztcbkZETGF5b3V0Q29uc3RhbnRzLkNPT0xJTkdfQURBUFRBVElPTl9GQUNUT1IgPSAwLjMzO1xuRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9MT1dFUl9OT0RFX0xJTUlUID0gMTAwMDtcbkZETGF5b3V0Q29uc3RhbnRzLkFEQVBUQVRJT05fVVBQRVJfTk9ERV9MSU1JVCA9IDUwMDA7XG5GRExheW91dENvbnN0YW50cy5NQVhfTk9ERV9ESVNQTEFDRU1FTlRfSU5DUkVNRU5UQUwgPSAxMDAuMDtcbkZETGF5b3V0Q29uc3RhbnRzLk1BWF9OT0RFX0RJU1BMQUNFTUVOVCA9IEZETGF5b3V0Q29uc3RhbnRzLk1BWF9OT0RFX0RJU1BMQUNFTUVOVF9JTkNSRU1FTlRBTCAqIDM7XG5GRExheW91dENvbnN0YW50cy5NSU5fUkVQVUxTSU9OX0RJU1QgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIIC8gMTAuMDtcbkZETGF5b3V0Q29uc3RhbnRzLkNPTlZFUkdFTkNFX0NIRUNLX1BFUklPRCA9IDEwMDtcbkZETGF5b3V0Q29uc3RhbnRzLlBFUl9MRVZFTF9JREVBTF9FREdFX0xFTkdUSF9GQUNUT1IgPSAwLjE7XG5GRExheW91dENvbnN0YW50cy5NSU5fRURHRV9MRU5HVEggPSAxO1xuRkRMYXlvdXRDb25zdGFudHMuR1JJRF9DQUxDVUxBVElPTl9DSEVDS19QRVJJT0QgPSAxMDtcblxubW9kdWxlLmV4cG9ydHMgPSBGRExheW91dENvbnN0YW50cztcblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIFBvaW50RCh4LCB5KSB7XG4gIGlmICh4ID09IG51bGwgJiYgeSA9PSBudWxsKSB7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICB9IGVsc2Uge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfVxufVxuXG5Qb2ludEQucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLng7XG59O1xuXG5Qb2ludEQucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnk7XG59O1xuXG5Qb2ludEQucHJvdG90eXBlLnNldFggPSBmdW5jdGlvbiAoeCkge1xuICB0aGlzLnggPSB4O1xufTtcblxuUG9pbnRELnByb3RvdHlwZS5zZXRZID0gZnVuY3Rpb24gKHkpIHtcbiAgdGhpcy55ID0geTtcbn07XG5cblBvaW50RC5wcm90b3R5cGUuZ2V0RGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChwdCkge1xuICByZXR1cm4gbmV3IERpbWVuc2lvbkQodGhpcy54IC0gcHQueCwgdGhpcy55IC0gcHQueSk7XG59O1xuXG5Qb2ludEQucHJvdG90eXBlLmdldENvcHkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgUG9pbnREKHRoaXMueCwgdGhpcy55KTtcbn07XG5cblBvaW50RC5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24gKGRpbSkge1xuICB0aGlzLnggKz0gZGltLndpZHRoO1xuICB0aGlzLnkgKz0gZGltLmhlaWdodDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50RDtcblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBMR3JhcGhPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xudmFyIEludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbnZhciBMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIExHcmFwaE1hbmFnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xudmFyIExOb2RlID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbnZhciBMRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgUmVjdGFuZ2xlRCA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xudmFyIFBvaW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG52YXIgTGlua2VkTGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG5mdW5jdGlvbiBMR3JhcGgocGFyZW50LCBvYmoyLCB2R3JhcGgpIHtcbiAgTEdyYXBoT2JqZWN0LmNhbGwodGhpcywgdkdyYXBoKTtcbiAgdGhpcy5lc3RpbWF0ZWRTaXplID0gSW50ZWdlci5NSU5fVkFMVUU7XG4gIHRoaXMubWFyZ2luID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBUEhfTUFSR0lOO1xuICB0aGlzLmVkZ2VzID0gW107XG4gIHRoaXMubm9kZXMgPSBbXTtcbiAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLnBhcmVudCA9IHBhcmVudDtcblxuICBpZiAob2JqMiAhPSBudWxsICYmIG9iajIgaW5zdGFuY2VvZiBMR3JhcGhNYW5hZ2VyKSB7XG4gICAgdGhpcy5ncmFwaE1hbmFnZXIgPSBvYmoyO1xuICB9IGVsc2UgaWYgKG9iajIgIT0gbnVsbCAmJiBvYmoyIGluc3RhbmNlb2YgTGF5b3V0KSB7XG4gICAgdGhpcy5ncmFwaE1hbmFnZXIgPSBvYmoyLmdyYXBoTWFuYWdlcjtcbiAgfVxufVxuXG5MR3JhcGgucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMR3JhcGhPYmplY3QucHJvdG90eXBlKTtcbmZvciAodmFyIHByb3AgaW4gTEdyYXBoT2JqZWN0KSB7XG4gIExHcmFwaFtwcm9wXSA9IExHcmFwaE9iamVjdFtwcm9wXTtcbn1cblxuTEdyYXBoLnByb3RvdHlwZS5nZXROb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZXM7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmdldEVkZ2VzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5lZGdlcztcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0R3JhcGhNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ncmFwaE1hbmFnZXI7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmdldFBhcmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucGFyZW50O1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5nZXRMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sZWZ0O1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5nZXRSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmlnaHQ7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmdldFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudG9wO1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5nZXRCb3R0b20gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmJvdHRvbTtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuaXNDb25uZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmlzQ29ubmVjdGVkO1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAob2JqMSwgc291cmNlTm9kZSwgdGFyZ2V0Tm9kZSkge1xuICBpZiAoc291cmNlTm9kZSA9PSBudWxsICYmIHRhcmdldE5vZGUgPT0gbnVsbCkge1xuICAgIHZhciBuZXdOb2RlID0gb2JqMTtcbiAgICBpZiAodGhpcy5ncmFwaE1hbmFnZXIgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgXCJHcmFwaCBoYXMgbm8gZ3JhcGggbWdyIVwiO1xuICAgIH1cbiAgICBpZiAodGhpcy5nZXROb2RlcygpLmluZGV4T2YobmV3Tm9kZSkgPiAtMSkge1xuICAgICAgdGhyb3cgXCJOb2RlIGFscmVhZHkgaW4gZ3JhcGghXCI7XG4gICAgfVxuICAgIG5ld05vZGUub3duZXIgPSB0aGlzO1xuICAgIHRoaXMuZ2V0Tm9kZXMoKS5wdXNoKG5ld05vZGUpO1xuXG4gICAgcmV0dXJuIG5ld05vZGU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5ld0VkZ2UgPSBvYmoxO1xuICAgIGlmICghKHRoaXMuZ2V0Tm9kZXMoKS5pbmRleE9mKHNvdXJjZU5vZGUpID4gLTEgJiYgdGhpcy5nZXROb2RlcygpLmluZGV4T2YodGFyZ2V0Tm9kZSkgPiAtMSkpIHtcbiAgICAgIHRocm93IFwiU291cmNlIG9yIHRhcmdldCBub3QgaW4gZ3JhcGghXCI7XG4gICAgfVxuXG4gICAgaWYgKCEoc291cmNlTm9kZS5vd25lciA9PSB0YXJnZXROb2RlLm93bmVyICYmIHNvdXJjZU5vZGUub3duZXIgPT0gdGhpcykpIHtcbiAgICAgIHRocm93IFwiQm90aCBvd25lcnMgbXVzdCBiZSB0aGlzIGdyYXBoIVwiO1xuICAgIH1cblxuICAgIGlmIChzb3VyY2VOb2RlLm93bmVyICE9IHRhcmdldE5vZGUub3duZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIHNldCBzb3VyY2UgYW5kIHRhcmdldFxuICAgIG5ld0VkZ2Uuc291cmNlID0gc291cmNlTm9kZTtcbiAgICBuZXdFZGdlLnRhcmdldCA9IHRhcmdldE5vZGU7XG5cbiAgICAvLyBzZXQgYXMgaW50cmEtZ3JhcGggZWRnZVxuICAgIG5ld0VkZ2UuaXNJbnRlckdyYXBoID0gZmFsc2U7XG5cbiAgICAvLyBhZGQgdG8gZ3JhcGggZWRnZSBsaXN0XG4gICAgdGhpcy5nZXRFZGdlcygpLnB1c2gobmV3RWRnZSk7XG5cbiAgICAvLyBhZGQgdG8gaW5jaWRlbmN5IGxpc3RzXG4gICAgc291cmNlTm9kZS5lZGdlcy5wdXNoKG5ld0VkZ2UpO1xuXG4gICAgaWYgKHRhcmdldE5vZGUgIT0gc291cmNlTm9kZSkge1xuICAgICAgdGFyZ2V0Tm9kZS5lZGdlcy5wdXNoKG5ld0VkZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdFZGdlO1xuICB9XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIG5vZGUgPSBvYmo7XG4gIGlmIChvYmogaW5zdGFuY2VvZiBMTm9kZSkge1xuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiTm9kZSBpcyBudWxsIVwiO1xuICAgIH1cbiAgICBpZiAoIShub2RlLm93bmVyICE9IG51bGwgJiYgbm9kZS5vd25lciA9PSB0aGlzKSkge1xuICAgICAgdGhyb3cgXCJPd25lciBncmFwaCBpcyBpbnZhbGlkIVwiO1xuICAgIH1cbiAgICBpZiAodGhpcy5ncmFwaE1hbmFnZXIgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgXCJPd25lciBncmFwaCBtYW5hZ2VyIGlzIGludmFsaWQhXCI7XG4gICAgfVxuICAgIC8vIHJlbW92ZSBpbmNpZGVudCBlZGdlcyBmaXJzdCAobWFrZSBhIGNvcHkgdG8gZG8gaXQgc2FmZWx5KVxuICAgIHZhciBlZGdlc1RvQmVSZW1vdmVkID0gbm9kZS5lZGdlcy5zbGljZSgpO1xuICAgIHZhciBlZGdlO1xuICAgIHZhciBzID0gZWRnZXNUb0JlUmVtb3ZlZC5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgIGVkZ2UgPSBlZGdlc1RvQmVSZW1vdmVkW2ldO1xuXG4gICAgICBpZiAoZWRnZS5pc0ludGVyR3JhcGgpIHtcbiAgICAgICAgdGhpcy5ncmFwaE1hbmFnZXIucmVtb3ZlKGVkZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRnZS5zb3VyY2Uub3duZXIucmVtb3ZlKGVkZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5vdyB0aGUgbm9kZSBpdHNlbGZcbiAgICB2YXIgaW5kZXggPSB0aGlzLm5vZGVzLmluZGV4T2Yobm9kZSk7XG4gICAgaWYgKGluZGV4ID09IC0xKSB7XG4gICAgICB0aHJvdyBcIk5vZGUgbm90IGluIG93bmVyIG5vZGUgbGlzdCFcIjtcbiAgICB9XG5cbiAgICB0aGlzLm5vZGVzLnNwbGljZShpbmRleCwgMSk7XG4gIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTEVkZ2UpIHtcbiAgICB2YXIgZWRnZSA9IG9iajtcbiAgICBpZiAoZWRnZSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBcIkVkZ2UgaXMgbnVsbCFcIjtcbiAgICB9XG4gICAgaWYgKCEoZWRnZS5zb3VyY2UgIT0gbnVsbCAmJiBlZGdlLnRhcmdldCAhPSBudWxsKSkge1xuICAgICAgdGhyb3cgXCJTb3VyY2UgYW5kL29yIHRhcmdldCBpcyBudWxsIVwiO1xuICAgIH1cbiAgICBpZiAoIShlZGdlLnNvdXJjZS5vd25lciAhPSBudWxsICYmIGVkZ2UudGFyZ2V0Lm93bmVyICE9IG51bGwgJiYgZWRnZS5zb3VyY2Uub3duZXIgPT0gdGhpcyAmJiBlZGdlLnRhcmdldC5vd25lciA9PSB0aGlzKSkge1xuICAgICAgdGhyb3cgXCJTb3VyY2UgYW5kL29yIHRhcmdldCBvd25lciBpcyBpbnZhbGlkIVwiO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VJbmRleCA9IGVkZ2Uuc291cmNlLmVkZ2VzLmluZGV4T2YoZWRnZSk7XG4gICAgdmFyIHRhcmdldEluZGV4ID0gZWRnZS50YXJnZXQuZWRnZXMuaW5kZXhPZihlZGdlKTtcbiAgICBpZiAoIShzb3VyY2VJbmRleCA+IC0xICYmIHRhcmdldEluZGV4ID4gLTEpKSB7XG4gICAgICB0aHJvdyBcIlNvdXJjZSBhbmQvb3IgdGFyZ2V0IGRvZXNuJ3Qga25vdyB0aGlzIGVkZ2UhXCI7XG4gICAgfVxuXG4gICAgZWRnZS5zb3VyY2UuZWRnZXMuc3BsaWNlKHNvdXJjZUluZGV4LCAxKTtcblxuICAgIGlmIChlZGdlLnRhcmdldCAhPSBlZGdlLnNvdXJjZSkge1xuICAgICAgZWRnZS50YXJnZXQuZWRnZXMuc3BsaWNlKHRhcmdldEluZGV4LCAxKTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSBlZGdlLnNvdXJjZS5vd25lci5nZXRFZGdlcygpLmluZGV4T2YoZWRnZSk7XG4gICAgaWYgKGluZGV4ID09IC0xKSB7XG4gICAgICB0aHJvdyBcIk5vdCBpbiBvd25lcidzIGVkZ2UgbGlzdCFcIjtcbiAgICB9XG5cbiAgICBlZGdlLnNvdXJjZS5vd25lci5nZXRFZGdlcygpLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbn07XG5cbkxHcmFwaC5wcm90b3R5cGUudXBkYXRlTGVmdFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRvcCA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgbGVmdCA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgbm9kZVRvcDtcbiAgdmFyIG5vZGVMZWZ0O1xuICB2YXIgbWFyZ2luO1xuXG4gIHZhciBub2RlcyA9IHRoaXMuZ2V0Tm9kZXMoKTtcbiAgdmFyIHMgPSBub2Rlcy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICB2YXIgbE5vZGUgPSBub2Rlc1tpXTtcbiAgICBub2RlVG9wID0gbE5vZGUuZ2V0VG9wKCk7XG4gICAgbm9kZUxlZnQgPSBsTm9kZS5nZXRMZWZ0KCk7XG5cbiAgICBpZiAodG9wID4gbm9kZVRvcCkge1xuICAgICAgdG9wID0gbm9kZVRvcDtcbiAgICB9XG5cbiAgICBpZiAobGVmdCA+IG5vZGVMZWZ0KSB7XG4gICAgICBsZWZ0ID0gbm9kZUxlZnQ7XG4gICAgfVxuICB9XG5cbiAgLy8gRG8gd2UgaGF2ZSBhbnkgbm9kZXMgaW4gdGhpcyBncmFwaD9cbiAgaWYgKHRvcCA9PSBJbnRlZ2VyLk1BWF9WQUxVRSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKG5vZGVzWzBdLmdldFBhcmVudCgpLnBhZGRpbmdMZWZ0ICE9IHVuZGVmaW5lZCkge1xuICAgIG1hcmdpbiA9IG5vZGVzWzBdLmdldFBhcmVudCgpLnBhZGRpbmdMZWZ0O1xuICB9IGVsc2Uge1xuICAgIG1hcmdpbiA9IHRoaXMubWFyZ2luO1xuICB9XG5cbiAgdGhpcy5sZWZ0ID0gbGVmdCAtIG1hcmdpbjtcbiAgdGhpcy50b3AgPSB0b3AgLSBtYXJnaW47XG5cbiAgLy8gQXBwbHkgdGhlIG1hcmdpbnMgYW5kIHJldHVybiB0aGUgcmVzdWx0XG4gIHJldHVybiBuZXcgUG9pbnQodGhpcy5sZWZ0LCB0aGlzLnRvcCk7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLnVwZGF0ZUJvdW5kcyA9IGZ1bmN0aW9uIChyZWN1cnNpdmUpIHtcbiAgLy8gY2FsY3VsYXRlIGJvdW5kc1xuICB2YXIgbGVmdCA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgcmlnaHQgPSAtSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciB0b3AgPSBJbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdmFyIGJvdHRvbSA9IC1JbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdmFyIG5vZGVMZWZ0O1xuICB2YXIgbm9kZVJpZ2h0O1xuICB2YXIgbm9kZVRvcDtcbiAgdmFyIG5vZGVCb3R0b207XG4gIHZhciBtYXJnaW47XG5cbiAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcztcbiAgdmFyIHMgPSBub2Rlcy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgdmFyIGxOb2RlID0gbm9kZXNbaV07XG5cbiAgICBpZiAocmVjdXJzaXZlICYmIGxOb2RlLmNoaWxkICE9IG51bGwpIHtcbiAgICAgIGxOb2RlLnVwZGF0ZUJvdW5kcygpO1xuICAgIH1cbiAgICBub2RlTGVmdCA9IGxOb2RlLmdldExlZnQoKTtcbiAgICBub2RlUmlnaHQgPSBsTm9kZS5nZXRSaWdodCgpO1xuICAgIG5vZGVUb3AgPSBsTm9kZS5nZXRUb3AoKTtcbiAgICBub2RlQm90dG9tID0gbE5vZGUuZ2V0Qm90dG9tKCk7XG5cbiAgICBpZiAobGVmdCA+IG5vZGVMZWZ0KSB7XG4gICAgICBsZWZ0ID0gbm9kZUxlZnQ7XG4gICAgfVxuXG4gICAgaWYgKHJpZ2h0IDwgbm9kZVJpZ2h0KSB7XG4gICAgICByaWdodCA9IG5vZGVSaWdodDtcbiAgICB9XG5cbiAgICBpZiAodG9wID4gbm9kZVRvcCkge1xuICAgICAgdG9wID0gbm9kZVRvcDtcbiAgICB9XG5cbiAgICBpZiAoYm90dG9tIDwgbm9kZUJvdHRvbSkge1xuICAgICAgYm90dG9tID0gbm9kZUJvdHRvbTtcbiAgICB9XG4gIH1cblxuICB2YXIgYm91bmRpbmdSZWN0ID0gbmV3IFJlY3RhbmdsZUQobGVmdCwgdG9wLCByaWdodCAtIGxlZnQsIGJvdHRvbSAtIHRvcCk7XG4gIGlmIChsZWZ0ID09IEludGVnZXIuTUFYX1ZBTFVFKSB7XG4gICAgdGhpcy5sZWZ0ID0gdGhpcy5wYXJlbnQuZ2V0TGVmdCgpO1xuICAgIHRoaXMucmlnaHQgPSB0aGlzLnBhcmVudC5nZXRSaWdodCgpO1xuICAgIHRoaXMudG9wID0gdGhpcy5wYXJlbnQuZ2V0VG9wKCk7XG4gICAgdGhpcy5ib3R0b20gPSB0aGlzLnBhcmVudC5nZXRCb3R0b20oKTtcbiAgfVxuXG4gIGlmIChub2Rlc1swXS5nZXRQYXJlbnQoKS5wYWRkaW5nTGVmdCAhPSB1bmRlZmluZWQpIHtcbiAgICBtYXJnaW4gPSBub2Rlc1swXS5nZXRQYXJlbnQoKS5wYWRkaW5nTGVmdDtcbiAgfSBlbHNlIHtcbiAgICBtYXJnaW4gPSB0aGlzLm1hcmdpbjtcbiAgfVxuXG4gIHRoaXMubGVmdCA9IGJvdW5kaW5nUmVjdC54IC0gbWFyZ2luO1xuICB0aGlzLnJpZ2h0ID0gYm91bmRpbmdSZWN0LnggKyBib3VuZGluZ1JlY3Qud2lkdGggKyBtYXJnaW47XG4gIHRoaXMudG9wID0gYm91bmRpbmdSZWN0LnkgLSBtYXJnaW47XG4gIHRoaXMuYm90dG9tID0gYm91bmRpbmdSZWN0LnkgKyBib3VuZGluZ1JlY3QuaGVpZ2h0ICsgbWFyZ2luO1xufTtcblxuTEdyYXBoLmNhbGN1bGF0ZUJvdW5kcyA9IGZ1bmN0aW9uIChub2Rlcykge1xuICB2YXIgbGVmdCA9IEludGVnZXIuTUFYX1ZBTFVFO1xuICB2YXIgcmlnaHQgPSAtSW50ZWdlci5NQVhfVkFMVUU7XG4gIHZhciB0b3AgPSBJbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdmFyIGJvdHRvbSA9IC1JbnRlZ2VyLk1BWF9WQUxVRTtcbiAgdmFyIG5vZGVMZWZ0O1xuICB2YXIgbm9kZVJpZ2h0O1xuICB2YXIgbm9kZVRvcDtcbiAgdmFyIG5vZGVCb3R0b207XG5cbiAgdmFyIHMgPSBub2Rlcy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICB2YXIgbE5vZGUgPSBub2Rlc1tpXTtcbiAgICBub2RlTGVmdCA9IGxOb2RlLmdldExlZnQoKTtcbiAgICBub2RlUmlnaHQgPSBsTm9kZS5nZXRSaWdodCgpO1xuICAgIG5vZGVUb3AgPSBsTm9kZS5nZXRUb3AoKTtcbiAgICBub2RlQm90dG9tID0gbE5vZGUuZ2V0Qm90dG9tKCk7XG5cbiAgICBpZiAobGVmdCA+IG5vZGVMZWZ0KSB7XG4gICAgICBsZWZ0ID0gbm9kZUxlZnQ7XG4gICAgfVxuXG4gICAgaWYgKHJpZ2h0IDwgbm9kZVJpZ2h0KSB7XG4gICAgICByaWdodCA9IG5vZGVSaWdodDtcbiAgICB9XG5cbiAgICBpZiAodG9wID4gbm9kZVRvcCkge1xuICAgICAgdG9wID0gbm9kZVRvcDtcbiAgICB9XG5cbiAgICBpZiAoYm90dG9tIDwgbm9kZUJvdHRvbSkge1xuICAgICAgYm90dG9tID0gbm9kZUJvdHRvbTtcbiAgICB9XG4gIH1cblxuICB2YXIgYm91bmRpbmdSZWN0ID0gbmV3IFJlY3RhbmdsZUQobGVmdCwgdG9wLCByaWdodCAtIGxlZnQsIGJvdHRvbSAtIHRvcCk7XG5cbiAgcmV0dXJuIGJvdW5kaW5nUmVjdDtcbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0SW5jbHVzaW9uVHJlZURlcHRoID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcyA9PSB0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0SW5jbHVzaW9uVHJlZURlcHRoKCk7XG4gIH1cbn07XG5cbkxHcmFwaC5wcm90b3R5cGUuZ2V0RXN0aW1hdGVkU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuZXN0aW1hdGVkU2l6ZSA9PSBJbnRlZ2VyLk1JTl9WQUxVRSkge1xuICAgIHRocm93IFwiYXNzZXJ0IGZhaWxlZFwiO1xuICB9XG4gIHJldHVybiB0aGlzLmVzdGltYXRlZFNpemU7XG59O1xuXG5MR3JhcGgucHJvdG90eXBlLmNhbGNFc3RpbWF0ZWRTaXplID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2l6ZSA9IDA7XG4gIHZhciBub2RlcyA9IHRoaXMubm9kZXM7XG4gIHZhciBzID0gbm9kZXMubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgdmFyIGxOb2RlID0gbm9kZXNbaV07XG4gICAgc2l6ZSArPSBsTm9kZS5jYWxjRXN0aW1hdGVkU2l6ZSgpO1xuICB9XG5cbiAgaWYgKHNpemUgPT0gMCkge1xuICAgIHRoaXMuZXN0aW1hdGVkU2l6ZSA9IExheW91dENvbnN0YW50cy5FTVBUWV9DT01QT1VORF9OT0RFX1NJWkU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5lc3RpbWF0ZWRTaXplID0gc2l6ZSAvIE1hdGguc3FydCh0aGlzLm5vZGVzLmxlbmd0aCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lc3RpbWF0ZWRTaXplO1xufTtcblxuTEdyYXBoLnByb3RvdHlwZS51cGRhdGVDb25uZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHRoaXMubm9kZXMubGVuZ3RoID09IDApIHtcbiAgICB0aGlzLmlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcXVldWUgPSBuZXcgTGlua2VkTGlzdCgpO1xuICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgdmFyIGN1cnJlbnROb2RlID0gdGhpcy5ub2Rlc1swXTtcbiAgdmFyIG5laWdoYm9yRWRnZXM7XG4gIHZhciBjdXJyZW50TmVpZ2hib3I7XG4gIHZhciBjaGlsZHJlbk9mTm9kZSA9IGN1cnJlbnROb2RlLndpdGhDaGlsZHJlbigpO1xuICBjaGlsZHJlbk9mTm9kZS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcXVldWUucHVzaChub2RlKTtcbiAgICB2aXNpdGVkLmFkZChub2RlKTtcbiAgfSk7XG5cbiAgd2hpbGUgKHF1ZXVlLmxlbmd0aCAhPT0gMCkge1xuICAgIGN1cnJlbnROb2RlID0gcXVldWUuc2hpZnQoKTtcblxuICAgIC8vIFRyYXZlcnNlIGFsbCBuZWlnaGJvcnMgb2YgdGhpcyBub2RlXG4gICAgbmVpZ2hib3JFZGdlcyA9IGN1cnJlbnROb2RlLmdldEVkZ2VzKCk7XG4gICAgdmFyIHNpemUgPSBuZWlnaGJvckVkZ2VzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgdmFyIG5laWdoYm9yRWRnZSA9IG5laWdoYm9yRWRnZXNbaV07XG4gICAgICBjdXJyZW50TmVpZ2hib3IgPSBuZWlnaGJvckVkZ2UuZ2V0T3RoZXJFbmRJbkdyYXBoKGN1cnJlbnROb2RlLCB0aGlzKTtcblxuICAgICAgLy8gQWRkIHVudmlzaXRlZCBuZWlnaGJvcnMgdG8gdGhlIGxpc3QgdG8gdmlzaXRcbiAgICAgIGlmIChjdXJyZW50TmVpZ2hib3IgIT0gbnVsbCAmJiAhdmlzaXRlZC5oYXMoY3VycmVudE5laWdoYm9yKSkge1xuICAgICAgICB2YXIgY2hpbGRyZW5PZk5laWdoYm9yID0gY3VycmVudE5laWdoYm9yLndpdGhDaGlsZHJlbigpO1xuXG4gICAgICAgIGNoaWxkcmVuT2ZOZWlnaGJvci5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgcXVldWUucHVzaChub2RlKTtcbiAgICAgICAgICB2aXNpdGVkLmFkZChub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuXG4gIGlmICh2aXNpdGVkLnNpemUgPj0gdGhpcy5ub2Rlcy5sZW5ndGgpIHtcbiAgICB2YXIgbm9PZlZpc2l0ZWRJblRoaXNHcmFwaCA9IDA7XG5cbiAgICB2aXNpdGVkLmZvckVhY2goZnVuY3Rpb24gKHZpc2l0ZWROb2RlKSB7XG4gICAgICBpZiAodmlzaXRlZE5vZGUub3duZXIgPT0gc2VsZikge1xuICAgICAgICBub09mVmlzaXRlZEluVGhpc0dyYXBoKys7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAobm9PZlZpc2l0ZWRJblRoaXNHcmFwaCA9PSB0aGlzLm5vZGVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5pc0Nvbm5lY3RlZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExHcmFwaDtcblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBMR3JhcGg7XG52YXIgTEVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG5mdW5jdGlvbiBMR3JhcGhNYW5hZ2VyKGxheW91dCkge1xuICBMR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpOyAvLyBJdCBtYXkgYmUgYmV0dGVyIHRvIGluaXRpbGl6ZSB0aGlzIG91dCBvZiB0aGlzIGZ1bmN0aW9uIGJ1dCBpdCBnaXZlcyBhbiBlcnJvciAoUmlnaHQtaGFuZCBzaWRlIG9mICdpbnN0YW5jZW9mJyBpcyBub3QgY2FsbGFibGUpIG5vdy5cbiAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG5cbiAgdGhpcy5ncmFwaHMgPSBbXTtcbiAgdGhpcy5lZGdlcyA9IFtdO1xufVxuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5hZGRSb290ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbmdyYXBoID0gdGhpcy5sYXlvdXQubmV3R3JhcGgoKTtcbiAgdmFyIG5ub2RlID0gdGhpcy5sYXlvdXQubmV3Tm9kZShudWxsKTtcbiAgdmFyIHJvb3QgPSB0aGlzLmFkZChuZ3JhcGgsIG5ub2RlKTtcbiAgdGhpcy5zZXRSb290R3JhcGgocm9vdCk7XG4gIHJldHVybiB0aGlzLnJvb3RHcmFwaDtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChuZXdHcmFwaCwgcGFyZW50Tm9kZSwgbmV3RWRnZSwgc291cmNlTm9kZSwgdGFyZ2V0Tm9kZSkge1xuICAvL3RoZXJlIGFyZSBqdXN0IDIgcGFyYW1ldGVycyBhcmUgcGFzc2VkIHRoZW4gaXQgYWRkcyBhbiBMR3JhcGggZWxzZSBpdCBhZGRzIGFuIExFZGdlXG4gIGlmIChuZXdFZGdlID09IG51bGwgJiYgc291cmNlTm9kZSA9PSBudWxsICYmIHRhcmdldE5vZGUgPT0gbnVsbCkge1xuICAgIGlmIChuZXdHcmFwaCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBcIkdyYXBoIGlzIG51bGwhXCI7XG4gICAgfVxuICAgIGlmIChwYXJlbnROb2RlID09IG51bGwpIHtcbiAgICAgIHRocm93IFwiUGFyZW50IG5vZGUgaXMgbnVsbCFcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ3JhcGhzLmluZGV4T2YobmV3R3JhcGgpID4gLTEpIHtcbiAgICAgIHRocm93IFwiR3JhcGggYWxyZWFkeSBpbiB0aGlzIGdyYXBoIG1nciFcIjtcbiAgICB9XG5cbiAgICB0aGlzLmdyYXBocy5wdXNoKG5ld0dyYXBoKTtcblxuICAgIGlmIChuZXdHcmFwaC5wYXJlbnQgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgXCJBbHJlYWR5IGhhcyBhIHBhcmVudCFcIjtcbiAgICB9XG4gICAgaWYgKHBhcmVudE5vZGUuY2hpbGQgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgXCJBbHJlYWR5IGhhcyBhIGNoaWxkIVwiO1xuICAgIH1cblxuICAgIG5ld0dyYXBoLnBhcmVudCA9IHBhcmVudE5vZGU7XG4gICAgcGFyZW50Tm9kZS5jaGlsZCA9IG5ld0dyYXBoO1xuXG4gICAgcmV0dXJuIG5ld0dyYXBoO1xuICB9IGVsc2Uge1xuICAgIC8vY2hhbmdlIHRoZSBvcmRlciBvZiB0aGUgcGFyYW1ldGVyc1xuICAgIHRhcmdldE5vZGUgPSBuZXdFZGdlO1xuICAgIHNvdXJjZU5vZGUgPSBwYXJlbnROb2RlO1xuICAgIG5ld0VkZ2UgPSBuZXdHcmFwaDtcbiAgICB2YXIgc291cmNlR3JhcGggPSBzb3VyY2VOb2RlLmdldE93bmVyKCk7XG4gICAgdmFyIHRhcmdldEdyYXBoID0gdGFyZ2V0Tm9kZS5nZXRPd25lcigpO1xuXG4gICAgaWYgKCEoc291cmNlR3JhcGggIT0gbnVsbCAmJiBzb3VyY2VHcmFwaC5nZXRHcmFwaE1hbmFnZXIoKSA9PSB0aGlzKSkge1xuICAgICAgdGhyb3cgXCJTb3VyY2Ugbm90IGluIHRoaXMgZ3JhcGggbWdyIVwiO1xuICAgIH1cbiAgICBpZiAoISh0YXJnZXRHcmFwaCAhPSBudWxsICYmIHRhcmdldEdyYXBoLmdldEdyYXBoTWFuYWdlcigpID09IHRoaXMpKSB7XG4gICAgICB0aHJvdyBcIlRhcmdldCBub3QgaW4gdGhpcyBncmFwaCBtZ3IhXCI7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZUdyYXBoID09IHRhcmdldEdyYXBoKSB7XG4gICAgICBuZXdFZGdlLmlzSW50ZXJHcmFwaCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHNvdXJjZUdyYXBoLmFkZChuZXdFZGdlLCBzb3VyY2VOb2RlLCB0YXJnZXROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3RWRnZS5pc0ludGVyR3JhcGggPSB0cnVlO1xuXG4gICAgICAvLyBzZXQgc291cmNlIGFuZCB0YXJnZXRcbiAgICAgIG5ld0VkZ2Uuc291cmNlID0gc291cmNlTm9kZTtcbiAgICAgIG5ld0VkZ2UudGFyZ2V0ID0gdGFyZ2V0Tm9kZTtcblxuICAgICAgLy8gYWRkIGVkZ2UgdG8gaW50ZXItZ3JhcGggZWRnZSBsaXN0XG4gICAgICBpZiAodGhpcy5lZGdlcy5pbmRleE9mKG5ld0VkZ2UpID4gLTEpIHtcbiAgICAgICAgdGhyb3cgXCJFZGdlIGFscmVhZHkgaW4gaW50ZXItZ3JhcGggZWRnZSBsaXN0IVwiO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVkZ2VzLnB1c2gobmV3RWRnZSk7XG5cbiAgICAgIC8vIGFkZCBlZGdlIHRvIHNvdXJjZSBhbmQgdGFyZ2V0IGluY2lkZW5jeSBsaXN0c1xuICAgICAgaWYgKCEobmV3RWRnZS5zb3VyY2UgIT0gbnVsbCAmJiBuZXdFZGdlLnRhcmdldCAhPSBudWxsKSkge1xuICAgICAgICB0aHJvdyBcIkVkZ2Ugc291cmNlIGFuZC9vciB0YXJnZXQgaXMgbnVsbCFcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKCEobmV3RWRnZS5zb3VyY2UuZWRnZXMuaW5kZXhPZihuZXdFZGdlKSA9PSAtMSAmJiBuZXdFZGdlLnRhcmdldC5lZGdlcy5pbmRleE9mKG5ld0VkZ2UpID09IC0xKSkge1xuICAgICAgICB0aHJvdyBcIkVkZ2UgYWxyZWFkeSBpbiBzb3VyY2UgYW5kL29yIHRhcmdldCBpbmNpZGVuY3kgbGlzdCFcIjtcbiAgICAgIH1cblxuICAgICAgbmV3RWRnZS5zb3VyY2UuZWRnZXMucHVzaChuZXdFZGdlKTtcbiAgICAgIG5ld0VkZ2UudGFyZ2V0LmVkZ2VzLnB1c2gobmV3RWRnZSk7XG5cbiAgICAgIHJldHVybiBuZXdFZGdlO1xuICAgIH1cbiAgfVxufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGxPYmopIHtcbiAgaWYgKGxPYmogaW5zdGFuY2VvZiBMR3JhcGgpIHtcbiAgICB2YXIgZ3JhcGggPSBsT2JqO1xuICAgIGlmIChncmFwaC5nZXRHcmFwaE1hbmFnZXIoKSAhPSB0aGlzKSB7XG4gICAgICB0aHJvdyBcIkdyYXBoIG5vdCBpbiB0aGlzIGdyYXBoIG1nclwiO1xuICAgIH1cbiAgICBpZiAoIShncmFwaCA9PSB0aGlzLnJvb3RHcmFwaCB8fCBncmFwaC5wYXJlbnQgIT0gbnVsbCAmJiBncmFwaC5wYXJlbnQuZ3JhcGhNYW5hZ2VyID09IHRoaXMpKSB7XG4gICAgICB0aHJvdyBcIkludmFsaWQgcGFyZW50IG5vZGUhXCI7XG4gICAgfVxuXG4gICAgLy8gZmlyc3QgdGhlIGVkZ2VzIChtYWtlIGEgY29weSB0byBkbyBpdCBzYWZlbHkpXG4gICAgdmFyIGVkZ2VzVG9CZVJlbW92ZWQgPSBbXTtcblxuICAgIGVkZ2VzVG9CZVJlbW92ZWQgPSBlZGdlc1RvQmVSZW1vdmVkLmNvbmNhdChncmFwaC5nZXRFZGdlcygpKTtcblxuICAgIHZhciBlZGdlO1xuICAgIHZhciBzID0gZWRnZXNUb0JlUmVtb3ZlZC5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgIGVkZ2UgPSBlZGdlc1RvQmVSZW1vdmVkW2ldO1xuICAgICAgZ3JhcGgucmVtb3ZlKGVkZ2UpO1xuICAgIH1cblxuICAgIC8vIHRoZW4gdGhlIG5vZGVzIChtYWtlIGEgY29weSB0byBkbyBpdCBzYWZlbHkpXG4gICAgdmFyIG5vZGVzVG9CZVJlbW92ZWQgPSBbXTtcblxuICAgIG5vZGVzVG9CZVJlbW92ZWQgPSBub2Rlc1RvQmVSZW1vdmVkLmNvbmNhdChncmFwaC5nZXROb2RlcygpKTtcblxuICAgIHZhciBub2RlO1xuICAgIHMgPSBub2Rlc1RvQmVSZW1vdmVkLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgbm9kZSA9IG5vZGVzVG9CZVJlbW92ZWRbaV07XG4gICAgICBncmFwaC5yZW1vdmUobm9kZSk7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgZ3JhcGggaXMgdGhlIHJvb3RcbiAgICBpZiAoZ3JhcGggPT0gdGhpcy5yb290R3JhcGgpIHtcbiAgICAgIHRoaXMuc2V0Um9vdEdyYXBoKG51bGwpO1xuICAgIH1cblxuICAgIC8vIG5vdyByZW1vdmUgdGhlIGdyYXBoIGl0c2VsZlxuICAgIHZhciBpbmRleCA9IHRoaXMuZ3JhcGhzLmluZGV4T2YoZ3JhcGgpO1xuICAgIHRoaXMuZ3JhcGhzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAvLyBhbHNvIHJlc2V0IHRoZSBwYXJlbnQgb2YgdGhlIGdyYXBoXG4gICAgZ3JhcGgucGFyZW50ID0gbnVsbDtcbiAgfSBlbHNlIGlmIChsT2JqIGluc3RhbmNlb2YgTEVkZ2UpIHtcbiAgICBlZGdlID0gbE9iajtcbiAgICBpZiAoZWRnZSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBcIkVkZ2UgaXMgbnVsbCFcIjtcbiAgICB9XG4gICAgaWYgKCFlZGdlLmlzSW50ZXJHcmFwaCkge1xuICAgICAgdGhyb3cgXCJOb3QgYW4gaW50ZXItZ3JhcGggZWRnZSFcIjtcbiAgICB9XG4gICAgaWYgKCEoZWRnZS5zb3VyY2UgIT0gbnVsbCAmJiBlZGdlLnRhcmdldCAhPSBudWxsKSkge1xuICAgICAgdGhyb3cgXCJTb3VyY2UgYW5kL29yIHRhcmdldCBpcyBudWxsIVwiO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBlZGdlIGZyb20gc291cmNlIGFuZCB0YXJnZXQgbm9kZXMnIGluY2lkZW5jeSBsaXN0c1xuXG4gICAgaWYgKCEoZWRnZS5zb3VyY2UuZWRnZXMuaW5kZXhPZihlZGdlKSAhPSAtMSAmJiBlZGdlLnRhcmdldC5lZGdlcy5pbmRleE9mKGVkZ2UpICE9IC0xKSkge1xuICAgICAgdGhyb3cgXCJTb3VyY2UgYW5kL29yIHRhcmdldCBkb2Vzbid0IGtub3cgdGhpcyBlZGdlIVwiO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IGVkZ2Uuc291cmNlLmVkZ2VzLmluZGV4T2YoZWRnZSk7XG4gICAgZWRnZS5zb3VyY2UuZWRnZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICBpbmRleCA9IGVkZ2UudGFyZ2V0LmVkZ2VzLmluZGV4T2YoZWRnZSk7XG4gICAgZWRnZS50YXJnZXQuZWRnZXMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgIC8vIHJlbW92ZSBlZGdlIGZyb20gb3duZXIgZ3JhcGggbWFuYWdlcidzIGludGVyLWdyYXBoIGVkZ2UgbGlzdFxuXG4gICAgaWYgKCEoZWRnZS5zb3VyY2Uub3duZXIgIT0gbnVsbCAmJiBlZGdlLnNvdXJjZS5vd25lci5nZXRHcmFwaE1hbmFnZXIoKSAhPSBudWxsKSkge1xuICAgICAgdGhyb3cgXCJFZGdlIG93bmVyIGdyYXBoIG9yIG93bmVyIGdyYXBoIG1hbmFnZXIgaXMgbnVsbCFcIjtcbiAgICB9XG4gICAgaWYgKGVkZ2Uuc291cmNlLm93bmVyLmdldEdyYXBoTWFuYWdlcigpLmVkZ2VzLmluZGV4T2YoZWRnZSkgPT0gLTEpIHtcbiAgICAgIHRocm93IFwiTm90IGluIG93bmVyIGdyYXBoIG1hbmFnZXIncyBlZGdlIGxpc3QhXCI7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gZWRnZS5zb3VyY2Uub3duZXIuZ2V0R3JhcGhNYW5hZ2VyKCkuZWRnZXMuaW5kZXhPZihlZGdlKTtcbiAgICBlZGdlLnNvdXJjZS5vd25lci5nZXRHcmFwaE1hbmFnZXIoKS5lZGdlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucm9vdEdyYXBoLnVwZGF0ZUJvdW5kcyh0cnVlKTtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmdldEdyYXBocyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ3JhcGhzO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuZ2V0QWxsTm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmFsbE5vZGVzID09IG51bGwpIHtcbiAgICB2YXIgbm9kZUxpc3QgPSBbXTtcbiAgICB2YXIgZ3JhcGhzID0gdGhpcy5nZXRHcmFwaHMoKTtcbiAgICB2YXIgcyA9IGdyYXBocy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgIG5vZGVMaXN0ID0gbm9kZUxpc3QuY29uY2F0KGdyYXBoc1tpXS5nZXROb2RlcygpKTtcbiAgICB9XG4gICAgdGhpcy5hbGxOb2RlcyA9IG5vZGVMaXN0O1xuICB9XG4gIHJldHVybiB0aGlzLmFsbE5vZGVzO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUucmVzZXRBbGxOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5hbGxOb2RlcyA9IG51bGw7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5yZXNldEFsbEVkZ2VzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmFsbEVkZ2VzID0gbnVsbDtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLnJlc2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24gPSBudWxsO1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuZ2V0QWxsRWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmFsbEVkZ2VzID09IG51bGwpIHtcbiAgICB2YXIgZWRnZUxpc3QgPSBbXTtcbiAgICB2YXIgZ3JhcGhzID0gdGhpcy5nZXRHcmFwaHMoKTtcbiAgICB2YXIgcyA9IGdyYXBocy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFwaHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGVkZ2VMaXN0ID0gZWRnZUxpc3QuY29uY2F0KGdyYXBoc1tpXS5nZXRFZGdlcygpKTtcbiAgICB9XG5cbiAgICBlZGdlTGlzdCA9IGVkZ2VMaXN0LmNvbmNhdCh0aGlzLmVkZ2VzKTtcblxuICAgIHRoaXMuYWxsRWRnZXMgPSBlZGdlTGlzdDtcbiAgfVxuICByZXR1cm4gdGhpcy5hbGxFZGdlcztcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmdldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5hbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbjtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLnNldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uID0gZnVuY3Rpb24gKG5vZGVMaXN0KSB7XG4gIGlmICh0aGlzLmFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uICE9IG51bGwpIHtcbiAgICB0aHJvdyBcImFzc2VydCBmYWlsZWRcIjtcbiAgfVxuXG4gIHRoaXMuYWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24gPSBub2RlTGlzdDtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmdldFJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJvb3RHcmFwaDtcbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLnNldFJvb3RHcmFwaCA9IGZ1bmN0aW9uIChncmFwaCkge1xuICBpZiAoZ3JhcGguZ2V0R3JhcGhNYW5hZ2VyKCkgIT0gdGhpcykge1xuICAgIHRocm93IFwiUm9vdCBub3QgaW4gdGhpcyBncmFwaCBtZ3IhXCI7XG4gIH1cblxuICB0aGlzLnJvb3RHcmFwaCA9IGdyYXBoO1xuICAvLyByb290IGdyYXBoIG11c3QgaGF2ZSBhIHJvb3Qgbm9kZSBhc3NvY2lhdGVkIHdpdGggaXQgZm9yIGNvbnZlbmllbmNlXG4gIGlmIChncmFwaC5wYXJlbnQgPT0gbnVsbCkge1xuICAgIGdyYXBoLnBhcmVudCA9IHRoaXMubGF5b3V0Lm5ld05vZGUoXCJSb290IG5vZGVcIik7XG4gIH1cbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmdldExheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGF5b3V0O1xufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuaXNPbmVBbmNlc3Rvck9mT3RoZXIgPSBmdW5jdGlvbiAoZmlyc3ROb2RlLCBzZWNvbmROb2RlKSB7XG4gIGlmICghKGZpcnN0Tm9kZSAhPSBudWxsICYmIHNlY29uZE5vZGUgIT0gbnVsbCkpIHtcbiAgICB0aHJvdyBcImFzc2VydCBmYWlsZWRcIjtcbiAgfVxuXG4gIGlmIChmaXJzdE5vZGUgPT0gc2Vjb25kTm9kZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIElzIHNlY29uZCBub2RlIGFuIGFuY2VzdG9yIG9mIHRoZSBmaXJzdCBvbmU/XG4gIHZhciBvd25lckdyYXBoID0gZmlyc3ROb2RlLmdldE93bmVyKCk7XG4gIHZhciBwYXJlbnROb2RlO1xuXG4gIGRvIHtcbiAgICBwYXJlbnROb2RlID0gb3duZXJHcmFwaC5nZXRQYXJlbnQoKTtcblxuICAgIGlmIChwYXJlbnROb2RlID09IG51bGwpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChwYXJlbnROb2RlID09IHNlY29uZE5vZGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIG93bmVyR3JhcGggPSBwYXJlbnROb2RlLmdldE93bmVyKCk7XG4gICAgaWYgKG93bmVyR3JhcGggPT0gbnVsbCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9IHdoaWxlICh0cnVlKTtcbiAgLy8gSXMgZmlyc3Qgbm9kZSBhbiBhbmNlc3RvciBvZiB0aGUgc2Vjb25kIG9uZT9cbiAgb3duZXJHcmFwaCA9IHNlY29uZE5vZGUuZ2V0T3duZXIoKTtcblxuICBkbyB7XG4gICAgcGFyZW50Tm9kZSA9IG93bmVyR3JhcGguZ2V0UGFyZW50KCk7XG5cbiAgICBpZiAocGFyZW50Tm9kZSA9PSBudWxsKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAocGFyZW50Tm9kZSA9PSBmaXJzdE5vZGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIG93bmVyR3JhcGggPSBwYXJlbnROb2RlLmdldE93bmVyKCk7XG4gICAgaWYgKG93bmVyR3JhcGggPT0gbnVsbCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9IHdoaWxlICh0cnVlKTtcblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5jYWxjTG93ZXN0Q29tbW9uQW5jZXN0b3JzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZWRnZTtcbiAgdmFyIHNvdXJjZU5vZGU7XG4gIHZhciB0YXJnZXROb2RlO1xuICB2YXIgc291cmNlQW5jZXN0b3JHcmFwaDtcbiAgdmFyIHRhcmdldEFuY2VzdG9yR3JhcGg7XG5cbiAgdmFyIGVkZ2VzID0gdGhpcy5nZXRBbGxFZGdlcygpO1xuICB2YXIgcyA9IGVkZ2VzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICBlZGdlID0gZWRnZXNbaV07XG5cbiAgICBzb3VyY2VOb2RlID0gZWRnZS5zb3VyY2U7XG4gICAgdGFyZ2V0Tm9kZSA9IGVkZ2UudGFyZ2V0O1xuICAgIGVkZ2UubGNhID0gbnVsbDtcbiAgICBlZGdlLnNvdXJjZUluTGNhID0gc291cmNlTm9kZTtcbiAgICBlZGdlLnRhcmdldEluTGNhID0gdGFyZ2V0Tm9kZTtcblxuICAgIGlmIChzb3VyY2VOb2RlID09IHRhcmdldE5vZGUpIHtcbiAgICAgIGVkZ2UubGNhID0gc291cmNlTm9kZS5nZXRPd25lcigpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgc291cmNlQW5jZXN0b3JHcmFwaCA9IHNvdXJjZU5vZGUuZ2V0T3duZXIoKTtcblxuICAgIHdoaWxlIChlZGdlLmxjYSA9PSBudWxsKSB7XG4gICAgICBlZGdlLnRhcmdldEluTGNhID0gdGFyZ2V0Tm9kZTtcbiAgICAgIHRhcmdldEFuY2VzdG9yR3JhcGggPSB0YXJnZXROb2RlLmdldE93bmVyKCk7XG5cbiAgICAgIHdoaWxlIChlZGdlLmxjYSA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0YXJnZXRBbmNlc3RvckdyYXBoID09IHNvdXJjZUFuY2VzdG9yR3JhcGgpIHtcbiAgICAgICAgICBlZGdlLmxjYSA9IHRhcmdldEFuY2VzdG9yR3JhcGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGFyZ2V0QW5jZXN0b3JHcmFwaCA9PSB0aGlzLnJvb3RHcmFwaCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVkZ2UubGNhICE9IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBcImFzc2VydCBmYWlsZWRcIjtcbiAgICAgICAgfVxuICAgICAgICBlZGdlLnRhcmdldEluTGNhID0gdGFyZ2V0QW5jZXN0b3JHcmFwaC5nZXRQYXJlbnQoKTtcbiAgICAgICAgdGFyZ2V0QW5jZXN0b3JHcmFwaCA9IGVkZ2UudGFyZ2V0SW5MY2EuZ2V0T3duZXIoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNvdXJjZUFuY2VzdG9yR3JhcGggPT0gdGhpcy5yb290R3JhcGgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChlZGdlLmxjYSA9PSBudWxsKSB7XG4gICAgICAgIGVkZ2Uuc291cmNlSW5MY2EgPSBzb3VyY2VBbmNlc3RvckdyYXBoLmdldFBhcmVudCgpO1xuICAgICAgICBzb3VyY2VBbmNlc3RvckdyYXBoID0gZWRnZS5zb3VyY2VJbkxjYS5nZXRPd25lcigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlZGdlLmxjYSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBcImFzc2VydCBmYWlsZWRcIjtcbiAgICB9XG4gIH1cbn07XG5cbkxHcmFwaE1hbmFnZXIucHJvdG90eXBlLmNhbGNMb3dlc3RDb21tb25BbmNlc3RvciA9IGZ1bmN0aW9uIChmaXJzdE5vZGUsIHNlY29uZE5vZGUpIHtcbiAgaWYgKGZpcnN0Tm9kZSA9PSBzZWNvbmROb2RlKSB7XG4gICAgcmV0dXJuIGZpcnN0Tm9kZS5nZXRPd25lcigpO1xuICB9XG4gIHZhciBmaXJzdE93bmVyR3JhcGggPSBmaXJzdE5vZGUuZ2V0T3duZXIoKTtcblxuICBkbyB7XG4gICAgaWYgKGZpcnN0T3duZXJHcmFwaCA9PSBudWxsKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIHNlY29uZE93bmVyR3JhcGggPSBzZWNvbmROb2RlLmdldE93bmVyKCk7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoc2Vjb25kT3duZXJHcmFwaCA9PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2Vjb25kT3duZXJHcmFwaCA9PSBmaXJzdE93bmVyR3JhcGgpIHtcbiAgICAgICAgcmV0dXJuIHNlY29uZE93bmVyR3JhcGg7XG4gICAgICB9XG4gICAgICBzZWNvbmRPd25lckdyYXBoID0gc2Vjb25kT3duZXJHcmFwaC5nZXRQYXJlbnQoKS5nZXRPd25lcigpO1xuICAgIH0gd2hpbGUgKHRydWUpO1xuXG4gICAgZmlyc3RPd25lckdyYXBoID0gZmlyc3RPd25lckdyYXBoLmdldFBhcmVudCgpLmdldE93bmVyKCk7XG4gIH0gd2hpbGUgKHRydWUpO1xuXG4gIHJldHVybiBmaXJzdE93bmVyR3JhcGg7XG59O1xuXG5MR3JhcGhNYW5hZ2VyLnByb3RvdHlwZS5jYWxjSW5jbHVzaW9uVHJlZURlcHRocyA9IGZ1bmN0aW9uIChncmFwaCwgZGVwdGgpIHtcbiAgaWYgKGdyYXBoID09IG51bGwgJiYgZGVwdGggPT0gbnVsbCkge1xuICAgIGdyYXBoID0gdGhpcy5yb290R3JhcGg7XG4gICAgZGVwdGggPSAxO1xuICB9XG4gIHZhciBub2RlO1xuXG4gIHZhciBub2RlcyA9IGdyYXBoLmdldE5vZGVzKCk7XG4gIHZhciBzID0gbm9kZXMubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICBub2RlLmluY2x1c2lvblRyZWVEZXB0aCA9IGRlcHRoO1xuXG4gICAgaWYgKG5vZGUuY2hpbGQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5jYWxjSW5jbHVzaW9uVHJlZURlcHRocyhub2RlLmNoaWxkLCBkZXB0aCArIDEpO1xuICAgIH1cbiAgfVxufTtcblxuTEdyYXBoTWFuYWdlci5wcm90b3R5cGUuaW5jbHVkZXNJbnZhbGlkRWRnZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVkZ2U7XG4gIHZhciBlZGdlc1RvUmVtb3ZlID0gW107XG5cbiAgdmFyIHMgPSB0aGlzLmVkZ2VzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICBlZGdlID0gdGhpcy5lZGdlc1tpXTtcblxuICAgIGlmICh0aGlzLmlzT25lQW5jZXN0b3JPZk90aGVyKGVkZ2Uuc291cmNlLCBlZGdlLnRhcmdldCkpIHtcbiAgICAgIGVkZ2VzVG9SZW1vdmUucHVzaChlZGdlKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZW1vdmUgaW52YWxpZCBlZGdlcyBmcm9tIGdyYXBoIG1hbmFnZXJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlc1RvUmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5yZW1vdmUoZWRnZXNUb1JlbW92ZVtpXSk7XG4gIH1cblxuICAvLyBJbnZhbGlkIGVkZ2VzIGFyZSBjbGVhcmVkLCBzbyByZXR1cm4gZmFsc2VcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMR3JhcGhNYW5hZ2VyO1xuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBUaGlzIGNsYXNzIG1haW50YWlucyBhIGxpc3Qgb2Ygc3RhdGljIGdlb21ldHJ5IHJlbGF0ZWQgdXRpbGl0eSBtZXRob2RzLlxuICpcbiAqXG4gKiBDb3B5cmlnaHQ6IGktVmlzIFJlc2VhcmNoIEdyb3VwLCBCaWxrZW50IFVuaXZlcnNpdHksIDIwMDcgLSBwcmVzZW50XG4gKi9cblxudmFyIFBvaW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cbmZ1bmN0aW9uIElHZW9tZXRyeSgpIHt9XG5cbi8qKlxuICogVGhpcyBtZXRob2QgY2FsY3VsYXRlcyAqaGFsZiogdGhlIGFtb3VudCBpbiB4IGFuZCB5IGRpcmVjdGlvbnMgb2YgdGhlIHR3b1xuICogaW5wdXQgcmVjdGFuZ2xlcyBuZWVkZWQgdG8gc2VwYXJhdGUgdGhlbSBrZWVwaW5nIHRoZWlyIHJlc3BlY3RpdmVcbiAqIHBvc2l0aW9uaW5nLCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGluIHRoZSBpbnB1dCBhcnJheS4gQW4gaW5wdXRcbiAqIHNlcGFyYXRpb24gYnVmZmVyIGFkZGVkIHRvIHRoZSBhbW91bnQgaW4gYm90aCBkaXJlY3Rpb25zLiBXZSBhc3N1bWUgdGhhdFxuICogdGhlIHR3byByZWN0YW5nbGVzIGRvIGludGVyc2VjdC5cbiAqL1xuSUdlb21ldHJ5LmNhbGNTZXBhcmF0aW9uQW1vdW50ID0gZnVuY3Rpb24gKHJlY3RBLCByZWN0Qiwgb3ZlcmxhcEFtb3VudCwgc2VwYXJhdGlvbkJ1ZmZlcikge1xuICBpZiAoIXJlY3RBLmludGVyc2VjdHMocmVjdEIpKSB7XG4gICAgdGhyb3cgXCJhc3NlcnQgZmFpbGVkXCI7XG4gIH1cblxuICB2YXIgZGlyZWN0aW9ucyA9IG5ldyBBcnJheSgyKTtcblxuICB0aGlzLmRlY2lkZURpcmVjdGlvbnNGb3JPdmVybGFwcGluZ05vZGVzKHJlY3RBLCByZWN0QiwgZGlyZWN0aW9ucyk7XG5cbiAgb3ZlcmxhcEFtb3VudFswXSA9IE1hdGgubWluKHJlY3RBLmdldFJpZ2h0KCksIHJlY3RCLmdldFJpZ2h0KCkpIC0gTWF0aC5tYXgocmVjdEEueCwgcmVjdEIueCk7XG4gIG92ZXJsYXBBbW91bnRbMV0gPSBNYXRoLm1pbihyZWN0QS5nZXRCb3R0b20oKSwgcmVjdEIuZ2V0Qm90dG9tKCkpIC0gTWF0aC5tYXgocmVjdEEueSwgcmVjdEIueSk7XG5cbiAgLy8gdXBkYXRlIHRoZSBvdmVybGFwcGluZyBhbW91bnRzIGZvciB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICBpZiAocmVjdEEuZ2V0WCgpIDw9IHJlY3RCLmdldFgoKSAmJiByZWN0QS5nZXRSaWdodCgpID49IHJlY3RCLmdldFJpZ2h0KCkpIHtcbiAgICAvKiBDYXNlIHguMTpcbiAgICAqXG4gICAgKiByZWN0QVxuICAgICogXHR8ICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgKiBcdHwgICAgICAgIF9fX19fX19fXyAgICAgIHxcbiAgICAqIFx0fCAgICAgICAgfCAgICAgICB8ICAgICAgfFxuICAgICogXHR8X19fX19fX198X19fX19fX3xfX19fX198XG4gICAgKiBcdFx0XHQgfCAgICAgICB8XG4gICAgKiAgICAgICAgICAgfCAgICAgICB8XG4gICAgKiAgICAgICAgcmVjdEJcbiAgICAqL1xuICAgIG92ZXJsYXBBbW91bnRbMF0gKz0gTWF0aC5taW4ocmVjdEIuZ2V0WCgpIC0gcmVjdEEuZ2V0WCgpLCByZWN0QS5nZXRSaWdodCgpIC0gcmVjdEIuZ2V0UmlnaHQoKSk7XG4gIH0gZWxzZSBpZiAocmVjdEIuZ2V0WCgpIDw9IHJlY3RBLmdldFgoKSAmJiByZWN0Qi5nZXRSaWdodCgpID49IHJlY3RBLmdldFJpZ2h0KCkpIHtcbiAgICAvKiBDYXNlIHguMjpcbiAgICAqXG4gICAgKiByZWN0QlxuICAgICogXHR8ICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgKiBcdHwgICAgICAgIF9fX19fX19fXyAgICAgIHxcbiAgICAqIFx0fCAgICAgICAgfCAgICAgICB8ICAgICAgfFxuICAgICogXHR8X19fX19fX198X19fX19fX3xfX19fX198XG4gICAgKiBcdFx0XHQgfCAgICAgICB8XG4gICAgKiAgICAgICAgICAgfCAgICAgICB8XG4gICAgKiAgICAgICAgcmVjdEFcbiAgICAqL1xuICAgIG92ZXJsYXBBbW91bnRbMF0gKz0gTWF0aC5taW4ocmVjdEEuZ2V0WCgpIC0gcmVjdEIuZ2V0WCgpLCByZWN0Qi5nZXRSaWdodCgpIC0gcmVjdEEuZ2V0UmlnaHQoKSk7XG4gIH1cbiAgaWYgKHJlY3RBLmdldFkoKSA8PSByZWN0Qi5nZXRZKCkgJiYgcmVjdEEuZ2V0Qm90dG9tKCkgPj0gcmVjdEIuZ2V0Qm90dG9tKCkpIHtcbiAgICAvKiBDYXNlIHkuMTpcbiAgICAgKiAgICAgICAgICBfX19fX19fXyByZWN0QVxuICAgICAqICAgICAgICAgfFxuICAgICAqICAgICAgICAgfFxuICAgICAqICAgX19fX19ffF9fX18gIHJlY3RCXG4gICAgICogICAgICAgICB8ICAgIHxcbiAgICAgKiAgICAgICAgIHwgICAgfFxuICAgICAqICAgX19fX19ffF9fX198XG4gICAgICogICAgICAgICB8XG4gICAgICogICAgICAgICB8XG4gICAgICogICAgICAgICB8X19fX19fX19cbiAgICAgKlxuICAgICAqL1xuICAgIG92ZXJsYXBBbW91bnRbMV0gKz0gTWF0aC5taW4ocmVjdEIuZ2V0WSgpIC0gcmVjdEEuZ2V0WSgpLCByZWN0QS5nZXRCb3R0b20oKSAtIHJlY3RCLmdldEJvdHRvbSgpKTtcbiAgfSBlbHNlIGlmIChyZWN0Qi5nZXRZKCkgPD0gcmVjdEEuZ2V0WSgpICYmIHJlY3RCLmdldEJvdHRvbSgpID49IHJlY3RBLmdldEJvdHRvbSgpKSB7XG4gICAgLyogQ2FzZSB5LjI6XG4gICAgKiAgICAgICAgICBfX19fX19fXyByZWN0QlxuICAgICogICAgICAgICB8XG4gICAgKiAgICAgICAgIHxcbiAgICAqICAgX19fX19ffF9fX18gIHJlY3RBXG4gICAgKiAgICAgICAgIHwgICAgfFxuICAgICogICAgICAgICB8ICAgIHxcbiAgICAqICAgX19fX19ffF9fX198XG4gICAgKiAgICAgICAgIHxcbiAgICAqICAgICAgICAgfFxuICAgICogICAgICAgICB8X19fX19fX19cbiAgICAqXG4gICAgKi9cbiAgICBvdmVybGFwQW1vdW50WzFdICs9IE1hdGgubWluKHJlY3RBLmdldFkoKSAtIHJlY3RCLmdldFkoKSwgcmVjdEIuZ2V0Qm90dG9tKCkgLSByZWN0QS5nZXRCb3R0b20oKSk7XG4gIH1cblxuICAvLyBmaW5kIHNsb3BlIG9mIHRoZSBsaW5lIHBhc3NlcyB0d28gY2VudGVyc1xuICB2YXIgc2xvcGUgPSBNYXRoLmFicygocmVjdEIuZ2V0Q2VudGVyWSgpIC0gcmVjdEEuZ2V0Q2VudGVyWSgpKSAvIChyZWN0Qi5nZXRDZW50ZXJYKCkgLSByZWN0QS5nZXRDZW50ZXJYKCkpKTtcbiAgLy8gaWYgY2VudGVycyBhcmUgb3ZlcmxhcHBlZFxuICBpZiAocmVjdEIuZ2V0Q2VudGVyWSgpID09PSByZWN0QS5nZXRDZW50ZXJZKCkgJiYgcmVjdEIuZ2V0Q2VudGVyWCgpID09PSByZWN0QS5nZXRDZW50ZXJYKCkpIHtcbiAgICAvLyBhc3N1bWUgdGhlIHNsb3BlIGlzIDEgKDQ1IGRlZ3JlZSlcbiAgICBzbG9wZSA9IDEuMDtcbiAgfVxuXG4gIHZhciBtb3ZlQnlZID0gc2xvcGUgKiBvdmVybGFwQW1vdW50WzBdO1xuICB2YXIgbW92ZUJ5WCA9IG92ZXJsYXBBbW91bnRbMV0gLyBzbG9wZTtcbiAgaWYgKG92ZXJsYXBBbW91bnRbMF0gPCBtb3ZlQnlYKSB7XG4gICAgbW92ZUJ5WCA9IG92ZXJsYXBBbW91bnRbMF07XG4gIH0gZWxzZSB7XG4gICAgbW92ZUJ5WSA9IG92ZXJsYXBBbW91bnRbMV07XG4gIH1cbiAgLy8gcmV0dXJuIGhhbGYgdGhlIGFtb3VudCBzbyB0aGF0IGlmIGVhY2ggcmVjdGFuZ2xlIGlzIG1vdmVkIGJ5IHRoZXNlXG4gIC8vIGFtb3VudHMgaW4gb3Bwb3NpdGUgZGlyZWN0aW9ucywgb3ZlcmxhcCB3aWxsIGJlIHJlc29sdmVkXG4gIG92ZXJsYXBBbW91bnRbMF0gPSAtMSAqIGRpcmVjdGlvbnNbMF0gKiAobW92ZUJ5WCAvIDIgKyBzZXBhcmF0aW9uQnVmZmVyKTtcbiAgb3ZlcmxhcEFtb3VudFsxXSA9IC0xICogZGlyZWN0aW9uc1sxXSAqIChtb3ZlQnlZIC8gMiArIHNlcGFyYXRpb25CdWZmZXIpO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBkZWNpZGVzIHRoZSBzZXBhcmF0aW9uIGRpcmVjdGlvbiBvZiBvdmVybGFwcGluZyBub2Rlc1xuICpcbiAqIGlmIGRpcmVjdGlvbnNbMF0gPSAtMSwgdGhlbiByZWN0QSBnb2VzIGxlZnRcbiAqIGlmIGRpcmVjdGlvbnNbMF0gPSAxLCAgdGhlbiByZWN0QSBnb2VzIHJpZ2h0XG4gKiBpZiBkaXJlY3Rpb25zWzFdID0gLTEsIHRoZW4gcmVjdEEgZ29lcyB1cFxuICogaWYgZGlyZWN0aW9uc1sxXSA9IDEsICB0aGVuIHJlY3RBIGdvZXMgZG93blxuICovXG5JR2VvbWV0cnkuZGVjaWRlRGlyZWN0aW9uc0Zvck92ZXJsYXBwaW5nTm9kZXMgPSBmdW5jdGlvbiAocmVjdEEsIHJlY3RCLCBkaXJlY3Rpb25zKSB7XG4gIGlmIChyZWN0QS5nZXRDZW50ZXJYKCkgPCByZWN0Qi5nZXRDZW50ZXJYKCkpIHtcbiAgICBkaXJlY3Rpb25zWzBdID0gLTE7XG4gIH0gZWxzZSB7XG4gICAgZGlyZWN0aW9uc1swXSA9IDE7XG4gIH1cblxuICBpZiAocmVjdEEuZ2V0Q2VudGVyWSgpIDwgcmVjdEIuZ2V0Q2VudGVyWSgpKSB7XG4gICAgZGlyZWN0aW9uc1sxXSA9IC0xO1xuICB9IGVsc2Uge1xuICAgIGRpcmVjdGlvbnNbMV0gPSAxO1xuICB9XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGNhbGN1bGF0ZXMgdGhlIGludGVyc2VjdGlvbiAoY2xpcHBpbmcpIHBvaW50cyBvZiB0aGUgdHdvXG4gKiBpbnB1dCByZWN0YW5nbGVzIHdpdGggbGluZSBzZWdtZW50IGRlZmluZWQgYnkgdGhlIGNlbnRlcnMgb2YgdGhlc2UgdHdvXG4gKiByZWN0YW5nbGVzLiBUaGUgY2xpcHBpbmcgcG9pbnRzIGFyZSBzYXZlZCBpbiB0aGUgaW5wdXQgZG91YmxlIGFycmF5IGFuZFxuICogd2hldGhlciBvciBub3QgdGhlIHR3byByZWN0YW5nbGVzIG92ZXJsYXAgaXMgcmV0dXJuZWQuXG4gKi9cbklHZW9tZXRyeS5nZXRJbnRlcnNlY3Rpb24yID0gZnVuY3Rpb24gKHJlY3RBLCByZWN0QiwgcmVzdWx0KSB7XG4gIC8vcmVzdWx0WzAtMV0gd2lsbCBjb250YWluIGNsaXBQb2ludCBvZiByZWN0QSwgcmVzdWx0WzItM10gd2lsbCBjb250YWluIGNsaXBQb2ludCBvZiByZWN0QlxuICB2YXIgcDF4ID0gcmVjdEEuZ2V0Q2VudGVyWCgpO1xuICB2YXIgcDF5ID0gcmVjdEEuZ2V0Q2VudGVyWSgpO1xuICB2YXIgcDJ4ID0gcmVjdEIuZ2V0Q2VudGVyWCgpO1xuICB2YXIgcDJ5ID0gcmVjdEIuZ2V0Q2VudGVyWSgpO1xuXG4gIC8vaWYgdHdvIHJlY3RhbmdsZXMgaW50ZXJzZWN0LCB0aGVuIGNsaXBwaW5nIHBvaW50cyBhcmUgY2VudGVyc1xuICBpZiAocmVjdEEuaW50ZXJzZWN0cyhyZWN0QikpIHtcbiAgICByZXN1bHRbMF0gPSBwMXg7XG4gICAgcmVzdWx0WzFdID0gcDF5O1xuICAgIHJlc3VsdFsyXSA9IHAyeDtcbiAgICByZXN1bHRbM10gPSBwMnk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy92YXJpYWJsZXMgZm9yIHJlY3RBXG4gIHZhciB0b3BMZWZ0QXggPSByZWN0QS5nZXRYKCk7XG4gIHZhciB0b3BMZWZ0QXkgPSByZWN0QS5nZXRZKCk7XG4gIHZhciB0b3BSaWdodEF4ID0gcmVjdEEuZ2V0UmlnaHQoKTtcbiAgdmFyIGJvdHRvbUxlZnRBeCA9IHJlY3RBLmdldFgoKTtcbiAgdmFyIGJvdHRvbUxlZnRBeSA9IHJlY3RBLmdldEJvdHRvbSgpO1xuICB2YXIgYm90dG9tUmlnaHRBeCA9IHJlY3RBLmdldFJpZ2h0KCk7XG4gIHZhciBoYWxmV2lkdGhBID0gcmVjdEEuZ2V0V2lkdGhIYWxmKCk7XG4gIHZhciBoYWxmSGVpZ2h0QSA9IHJlY3RBLmdldEhlaWdodEhhbGYoKTtcbiAgLy92YXJpYWJsZXMgZm9yIHJlY3RCXG4gIHZhciB0b3BMZWZ0QnggPSByZWN0Qi5nZXRYKCk7XG4gIHZhciB0b3BMZWZ0QnkgPSByZWN0Qi5nZXRZKCk7XG4gIHZhciB0b3BSaWdodEJ4ID0gcmVjdEIuZ2V0UmlnaHQoKTtcbiAgdmFyIGJvdHRvbUxlZnRCeCA9IHJlY3RCLmdldFgoKTtcbiAgdmFyIGJvdHRvbUxlZnRCeSA9IHJlY3RCLmdldEJvdHRvbSgpO1xuICB2YXIgYm90dG9tUmlnaHRCeCA9IHJlY3RCLmdldFJpZ2h0KCk7XG4gIHZhciBoYWxmV2lkdGhCID0gcmVjdEIuZ2V0V2lkdGhIYWxmKCk7XG4gIHZhciBoYWxmSGVpZ2h0QiA9IHJlY3RCLmdldEhlaWdodEhhbGYoKTtcblxuICAvL2ZsYWcgd2hldGhlciBjbGlwcGluZyBwb2ludHMgYXJlIGZvdW5kXG4gIHZhciBjbGlwUG9pbnRBRm91bmQgPSBmYWxzZTtcbiAgdmFyIGNsaXBQb2ludEJGb3VuZCA9IGZhbHNlO1xuXG4gIC8vIGxpbmUgaXMgdmVydGljYWxcbiAgaWYgKHAxeCA9PT0gcDJ4KSB7XG4gICAgaWYgKHAxeSA+IHAyeSkge1xuICAgICAgcmVzdWx0WzBdID0gcDF4O1xuICAgICAgcmVzdWx0WzFdID0gdG9wTGVmdEF5O1xuICAgICAgcmVzdWx0WzJdID0gcDJ4O1xuICAgICAgcmVzdWx0WzNdID0gYm90dG9tTGVmdEJ5O1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAocDF5IDwgcDJ5KSB7XG4gICAgICByZXN1bHRbMF0gPSBwMXg7XG4gICAgICByZXN1bHRbMV0gPSBib3R0b21MZWZ0QXk7XG4gICAgICByZXN1bHRbMl0gPSBwMng7XG4gICAgICByZXN1bHRbM10gPSB0b3BMZWZ0Qnk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vbm90IGxpbmUsIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICAvLyBsaW5lIGlzIGhvcml6b250YWxcbiAgZWxzZSBpZiAocDF5ID09PSBwMnkpIHtcbiAgICAgIGlmIChwMXggPiBwMngpIHtcbiAgICAgICAgcmVzdWx0WzBdID0gdG9wTGVmdEF4O1xuICAgICAgICByZXN1bHRbMV0gPSBwMXk7XG4gICAgICAgIHJlc3VsdFsyXSA9IHRvcFJpZ2h0Qng7XG4gICAgICAgIHJlc3VsdFszXSA9IHAyeTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChwMXggPCBwMngpIHtcbiAgICAgICAgcmVzdWx0WzBdID0gdG9wUmlnaHRBeDtcbiAgICAgICAgcmVzdWx0WzFdID0gcDF5O1xuICAgICAgICByZXN1bHRbMl0gPSB0b3BMZWZ0Qng7XG4gICAgICAgIHJlc3VsdFszXSA9IHAyeTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9ub3QgdmFsaWQgbGluZSwgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vc2xvcGVzIG9mIHJlY3RBJ3MgYW5kIHJlY3RCJ3MgZGlhZ29uYWxzXG4gICAgICB2YXIgc2xvcGVBID0gcmVjdEEuaGVpZ2h0IC8gcmVjdEEud2lkdGg7XG4gICAgICB2YXIgc2xvcGVCID0gcmVjdEIuaGVpZ2h0IC8gcmVjdEIud2lkdGg7XG5cbiAgICAgIC8vc2xvcGUgb2YgbGluZSBiZXR3ZWVuIGNlbnRlciBvZiByZWN0QSBhbmQgY2VudGVyIG9mIHJlY3RCXG4gICAgICB2YXIgc2xvcGVQcmltZSA9IChwMnkgLSBwMXkpIC8gKHAyeCAtIHAxeCk7XG4gICAgICB2YXIgY2FyZGluYWxEaXJlY3Rpb25BID0gdm9pZCAwO1xuICAgICAgdmFyIGNhcmRpbmFsRGlyZWN0aW9uQiA9IHZvaWQgMDtcbiAgICAgIHZhciB0ZW1wUG9pbnRBeCA9IHZvaWQgMDtcbiAgICAgIHZhciB0ZW1wUG9pbnRBeSA9IHZvaWQgMDtcbiAgICAgIHZhciB0ZW1wUG9pbnRCeCA9IHZvaWQgMDtcbiAgICAgIHZhciB0ZW1wUG9pbnRCeSA9IHZvaWQgMDtcblxuICAgICAgLy9kZXRlcm1pbmUgd2hldGhlciBjbGlwcGluZyBwb2ludCBpcyB0aGUgY29ybmVyIG9mIG5vZGVBXG4gICAgICBpZiAoLXNsb3BlQSA9PT0gc2xvcGVQcmltZSkge1xuICAgICAgICBpZiAocDF4ID4gcDJ4KSB7XG4gICAgICAgICAgcmVzdWx0WzBdID0gYm90dG9tTGVmdEF4O1xuICAgICAgICAgIHJlc3VsdFsxXSA9IGJvdHRvbUxlZnRBeTtcbiAgICAgICAgICBjbGlwUG9pbnRBRm91bmQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdFswXSA9IHRvcFJpZ2h0QXg7XG4gICAgICAgICAgcmVzdWx0WzFdID0gdG9wTGVmdEF5O1xuICAgICAgICAgIGNsaXBQb2ludEFGb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2xvcGVBID09PSBzbG9wZVByaW1lKSB7XG4gICAgICAgIGlmIChwMXggPiBwMngpIHtcbiAgICAgICAgICByZXN1bHRbMF0gPSB0b3BMZWZ0QXg7XG4gICAgICAgICAgcmVzdWx0WzFdID0gdG9wTGVmdEF5O1xuICAgICAgICAgIGNsaXBQb2ludEFGb3VuZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0WzBdID0gYm90dG9tUmlnaHRBeDtcbiAgICAgICAgICByZXN1bHRbMV0gPSBib3R0b21MZWZ0QXk7XG4gICAgICAgICAgY2xpcFBvaW50QUZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvL2RldGVybWluZSB3aGV0aGVyIGNsaXBwaW5nIHBvaW50IGlzIHRoZSBjb3JuZXIgb2Ygbm9kZUJcbiAgICAgIGlmICgtc2xvcGVCID09PSBzbG9wZVByaW1lKSB7XG4gICAgICAgIGlmIChwMnggPiBwMXgpIHtcbiAgICAgICAgICByZXN1bHRbMl0gPSBib3R0b21MZWZ0Qng7XG4gICAgICAgICAgcmVzdWx0WzNdID0gYm90dG9tTGVmdEJ5O1xuICAgICAgICAgIGNsaXBQb2ludEJGb3VuZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0WzJdID0gdG9wUmlnaHRCeDtcbiAgICAgICAgICByZXN1bHRbM10gPSB0b3BMZWZ0Qnk7XG4gICAgICAgICAgY2xpcFBvaW50QkZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzbG9wZUIgPT09IHNsb3BlUHJpbWUpIHtcbiAgICAgICAgaWYgKHAyeCA+IHAxeCkge1xuICAgICAgICAgIHJlc3VsdFsyXSA9IHRvcExlZnRCeDtcbiAgICAgICAgICByZXN1bHRbM10gPSB0b3BMZWZ0Qnk7XG4gICAgICAgICAgY2xpcFBvaW50QkZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbMl0gPSBib3R0b21SaWdodEJ4O1xuICAgICAgICAgIHJlc3VsdFszXSA9IGJvdHRvbUxlZnRCeTtcbiAgICAgICAgICBjbGlwUG9pbnRCRm91bmQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vaWYgYm90aCBjbGlwcGluZyBwb2ludHMgYXJlIGNvcm5lcnNcbiAgICAgIGlmIChjbGlwUG9pbnRBRm91bmQgJiYgY2xpcFBvaW50QkZvdW5kKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy9kZXRlcm1pbmUgQ2FyZGluYWwgRGlyZWN0aW9uIG9mIHJlY3RhbmdsZXNcbiAgICAgIGlmIChwMXggPiBwMngpIHtcbiAgICAgICAgaWYgKHAxeSA+IHAyeSkge1xuICAgICAgICAgIGNhcmRpbmFsRGlyZWN0aW9uQSA9IHRoaXMuZ2V0Q2FyZGluYWxEaXJlY3Rpb24oc2xvcGVBLCBzbG9wZVByaW1lLCA0KTtcbiAgICAgICAgICBjYXJkaW5hbERpcmVjdGlvbkIgPSB0aGlzLmdldENhcmRpbmFsRGlyZWN0aW9uKHNsb3BlQiwgc2xvcGVQcmltZSwgMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FyZGluYWxEaXJlY3Rpb25BID0gdGhpcy5nZXRDYXJkaW5hbERpcmVjdGlvbigtc2xvcGVBLCBzbG9wZVByaW1lLCAzKTtcbiAgICAgICAgICBjYXJkaW5hbERpcmVjdGlvbkIgPSB0aGlzLmdldENhcmRpbmFsRGlyZWN0aW9uKC1zbG9wZUIsIHNsb3BlUHJpbWUsIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocDF5ID4gcDJ5KSB7XG4gICAgICAgICAgY2FyZGluYWxEaXJlY3Rpb25BID0gdGhpcy5nZXRDYXJkaW5hbERpcmVjdGlvbigtc2xvcGVBLCBzbG9wZVByaW1lLCAxKTtcbiAgICAgICAgICBjYXJkaW5hbERpcmVjdGlvbkIgPSB0aGlzLmdldENhcmRpbmFsRGlyZWN0aW9uKC1zbG9wZUIsIHNsb3BlUHJpbWUsIDMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhcmRpbmFsRGlyZWN0aW9uQSA9IHRoaXMuZ2V0Q2FyZGluYWxEaXJlY3Rpb24oc2xvcGVBLCBzbG9wZVByaW1lLCAyKTtcbiAgICAgICAgICBjYXJkaW5hbERpcmVjdGlvbkIgPSB0aGlzLmdldENhcmRpbmFsRGlyZWN0aW9uKHNsb3BlQiwgc2xvcGVQcmltZSwgNCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vY2FsY3VsYXRlIGNsaXBwaW5nIFBvaW50IGlmIGl0IGlzIG5vdCBmb3VuZCBiZWZvcmVcbiAgICAgIGlmICghY2xpcFBvaW50QUZvdW5kKSB7XG4gICAgICAgIHN3aXRjaCAoY2FyZGluYWxEaXJlY3Rpb25BKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdGVtcFBvaW50QXkgPSB0b3BMZWZ0QXk7XG4gICAgICAgICAgICB0ZW1wUG9pbnRBeCA9IHAxeCArIC1oYWxmSGVpZ2h0QSAvIHNsb3BlUHJpbWU7XG4gICAgICAgICAgICByZXN1bHRbMF0gPSB0ZW1wUG9pbnRBeDtcbiAgICAgICAgICAgIHJlc3VsdFsxXSA9IHRlbXBQb2ludEF5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGVtcFBvaW50QXggPSBib3R0b21SaWdodEF4O1xuICAgICAgICAgICAgdGVtcFBvaW50QXkgPSBwMXkgKyBoYWxmV2lkdGhBICogc2xvcGVQcmltZTtcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IHRlbXBQb2ludEF4O1xuICAgICAgICAgICAgcmVzdWx0WzFdID0gdGVtcFBvaW50QXk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB0ZW1wUG9pbnRBeSA9IGJvdHRvbUxlZnRBeTtcbiAgICAgICAgICAgIHRlbXBQb2ludEF4ID0gcDF4ICsgaGFsZkhlaWdodEEgLyBzbG9wZVByaW1lO1xuICAgICAgICAgICAgcmVzdWx0WzBdID0gdGVtcFBvaW50QXg7XG4gICAgICAgICAgICByZXN1bHRbMV0gPSB0ZW1wUG9pbnRBeTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHRlbXBQb2ludEF4ID0gYm90dG9tTGVmdEF4O1xuICAgICAgICAgICAgdGVtcFBvaW50QXkgPSBwMXkgKyAtaGFsZldpZHRoQSAqIHNsb3BlUHJpbWU7XG4gICAgICAgICAgICByZXN1bHRbMF0gPSB0ZW1wUG9pbnRBeDtcbiAgICAgICAgICAgIHJlc3VsdFsxXSA9IHRlbXBQb2ludEF5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghY2xpcFBvaW50QkZvdW5kKSB7XG4gICAgICAgIHN3aXRjaCAoY2FyZGluYWxEaXJlY3Rpb25CKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdGVtcFBvaW50QnkgPSB0b3BMZWZ0Qnk7XG4gICAgICAgICAgICB0ZW1wUG9pbnRCeCA9IHAyeCArIC1oYWxmSGVpZ2h0QiAvIHNsb3BlUHJpbWU7XG4gICAgICAgICAgICByZXN1bHRbMl0gPSB0ZW1wUG9pbnRCeDtcbiAgICAgICAgICAgIHJlc3VsdFszXSA9IHRlbXBQb2ludEJ5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGVtcFBvaW50QnggPSBib3R0b21SaWdodEJ4O1xuICAgICAgICAgICAgdGVtcFBvaW50QnkgPSBwMnkgKyBoYWxmV2lkdGhCICogc2xvcGVQcmltZTtcbiAgICAgICAgICAgIHJlc3VsdFsyXSA9IHRlbXBQb2ludEJ4O1xuICAgICAgICAgICAgcmVzdWx0WzNdID0gdGVtcFBvaW50Qnk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB0ZW1wUG9pbnRCeSA9IGJvdHRvbUxlZnRCeTtcbiAgICAgICAgICAgIHRlbXBQb2ludEJ4ID0gcDJ4ICsgaGFsZkhlaWdodEIgLyBzbG9wZVByaW1lO1xuICAgICAgICAgICAgcmVzdWx0WzJdID0gdGVtcFBvaW50Qng7XG4gICAgICAgICAgICByZXN1bHRbM10gPSB0ZW1wUG9pbnRCeTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHRlbXBQb2ludEJ4ID0gYm90dG9tTGVmdEJ4O1xuICAgICAgICAgICAgdGVtcFBvaW50QnkgPSBwMnkgKyAtaGFsZldpZHRoQiAqIHNsb3BlUHJpbWU7XG4gICAgICAgICAgICByZXN1bHRbMl0gPSB0ZW1wUG9pbnRCeDtcbiAgICAgICAgICAgIHJlc3VsdFszXSA9IHRlbXBQb2ludEJ5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBpbiB3aGljaCBjYXJkaW5hbCBkaXJlY3Rpb24gZG9lcyBpbnB1dCBwb2ludCBzdGF5c1xuICogMTogTm9ydGhcbiAqIDI6IEVhc3RcbiAqIDM6IFNvdXRoXG4gKiA0OiBXZXN0XG4gKi9cbklHZW9tZXRyeS5nZXRDYXJkaW5hbERpcmVjdGlvbiA9IGZ1bmN0aW9uIChzbG9wZSwgc2xvcGVQcmltZSwgbGluZSkge1xuICBpZiAoc2xvcGUgPiBzbG9wZVByaW1lKSB7XG4gICAgcmV0dXJuIGxpbmU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDEgKyBsaW5lICUgNDtcbiAgfVxufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBjYWxjdWxhdGVzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byBsaW5lcyBkZWZpbmVkIGJ5XG4gKiBwb2ludCBwYWlycyAoczEsczIpIGFuZCAoZjEsZjIpLlxuICovXG5JR2VvbWV0cnkuZ2V0SW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gKHMxLCBzMiwgZjEsIGYyKSB7XG4gIGlmIChmMiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW50ZXJzZWN0aW9uMihzMSwgczIsIGYxKTtcbiAgfVxuXG4gIHZhciB4MSA9IHMxLng7XG4gIHZhciB5MSA9IHMxLnk7XG4gIHZhciB4MiA9IHMyLng7XG4gIHZhciB5MiA9IHMyLnk7XG4gIHZhciB4MyA9IGYxLng7XG4gIHZhciB5MyA9IGYxLnk7XG4gIHZhciB4NCA9IGYyLng7XG4gIHZhciB5NCA9IGYyLnk7XG4gIHZhciB4ID0gdm9pZCAwLFxuICAgICAgeSA9IHZvaWQgMDsgLy8gaW50ZXJzZWN0aW9uIHBvaW50XG4gIHZhciBhMSA9IHZvaWQgMCxcbiAgICAgIGEyID0gdm9pZCAwLFxuICAgICAgYjEgPSB2b2lkIDAsXG4gICAgICBiMiA9IHZvaWQgMCxcbiAgICAgIGMxID0gdm9pZCAwLFxuICAgICAgYzIgPSB2b2lkIDA7IC8vIGNvZWZmaWNpZW50cyBvZiBsaW5lIGVxbnMuXG4gIHZhciBkZW5vbSA9IHZvaWQgMDtcblxuICBhMSA9IHkyIC0geTE7XG4gIGIxID0geDEgLSB4MjtcbiAgYzEgPSB4MiAqIHkxIC0geDEgKiB5MjsgLy8geyBhMSp4ICsgYjEqeSArIGMxID0gMCBpcyBsaW5lIDEgfVxuXG4gIGEyID0geTQgLSB5MztcbiAgYjIgPSB4MyAtIHg0O1xuICBjMiA9IHg0ICogeTMgLSB4MyAqIHk0OyAvLyB7IGEyKnggKyBiMip5ICsgYzIgPSAwIGlzIGxpbmUgMiB9XG5cbiAgZGVub20gPSBhMSAqIGIyIC0gYTIgKiBiMTtcblxuICBpZiAoZGVub20gPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHggPSAoYjEgKiBjMiAtIGIyICogYzEpIC8gZGVub207XG4gIHkgPSAoYTIgKiBjMSAtIGExICogYzIpIC8gZGVub207XG5cbiAgcmV0dXJuIG5ldyBQb2ludCh4LCB5KTtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgZmluZHMgYW5kIHJldHVybnMgdGhlIGFuZ2xlIG9mIHRoZSB2ZWN0b3IgZnJvbSB0aGUgKyB4LWF4aXNcbiAqIGluIGNsb2Nrd2lzZSBkaXJlY3Rpb24gKGNvbXBhdGlibGUgdy8gSmF2YSBjb29yZGluYXRlIHN5c3RlbSEpLlxuICovXG5JR2VvbWV0cnkuYW5nbGVPZlZlY3RvciA9IGZ1bmN0aW9uIChDeCwgQ3ksIE54LCBOeSkge1xuICB2YXIgQ19hbmdsZSA9IHZvaWQgMDtcblxuICBpZiAoQ3ggIT09IE54KSB7XG4gICAgQ19hbmdsZSA9IE1hdGguYXRhbigoTnkgLSBDeSkgLyAoTnggLSBDeCkpO1xuXG4gICAgaWYgKE54IDwgQ3gpIHtcbiAgICAgIENfYW5nbGUgKz0gTWF0aC5QSTtcbiAgICB9IGVsc2UgaWYgKE55IDwgQ3kpIHtcbiAgICAgIENfYW5nbGUgKz0gdGhpcy5UV09fUEk7XG4gICAgfVxuICB9IGVsc2UgaWYgKE55IDwgQ3kpIHtcbiAgICBDX2FuZ2xlID0gdGhpcy5PTkVfQU5EX0hBTEZfUEk7IC8vIDI3MCBkZWdyZWVzXG4gIH0gZWxzZSB7XG4gICAgQ19hbmdsZSA9IHRoaXMuSEFMRl9QSTsgLy8gOTAgZGVncmVlc1xuICB9XG5cbiAgcmV0dXJuIENfYW5nbGU7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGNoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB0d28gbGluZSBzZWdtZW50cyAob25lIHdpdGggcG9pbnRcbiAqIHAxIGFuZCBwMiwgdGhlIG90aGVyIHdpdGggcG9pbnQgcDMgYW5kIHA0KSBpbnRlcnNlY3QgYXQgYSBwb2ludCBvdGhlclxuICogdGhhbiB0aGVzZSBwb2ludHMuXG4gKi9cbklHZW9tZXRyeS5kb0ludGVyc2VjdCA9IGZ1bmN0aW9uIChwMSwgcDIsIHAzLCBwNCkge1xuICB2YXIgYSA9IHAxLng7XG4gIHZhciBiID0gcDEueTtcbiAgdmFyIGMgPSBwMi54O1xuICB2YXIgZCA9IHAyLnk7XG4gIHZhciBwID0gcDMueDtcbiAgdmFyIHEgPSBwMy55O1xuICB2YXIgciA9IHA0Lng7XG4gIHZhciBzID0gcDQueTtcbiAgdmFyIGRldCA9IChjIC0gYSkgKiAocyAtIHEpIC0gKHIgLSBwKSAqIChkIC0gYik7XG5cbiAgaWYgKGRldCA9PT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGFtYmRhID0gKChzIC0gcSkgKiAociAtIGEpICsgKHAgLSByKSAqIChzIC0gYikpIC8gZGV0O1xuICAgIHZhciBnYW1tYSA9ICgoYiAtIGQpICogKHIgLSBhKSArIChjIC0gYSkgKiAocyAtIGIpKSAvIGRldDtcbiAgICByZXR1cm4gMCA8IGxhbWJkYSAmJiBsYW1iZGEgPCAxICYmIDAgPCBnYW1tYSAmJiBnYW1tYSA8IDE7XG4gIH1cbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2QgY2hlY2tzIGFuZCBjYWxjdWxhdGVzIHRoZSBpbnRlcnNlY3Rpb24gb2YgXG4gKiBhIGxpbmUgc2VnbWVudCBhbmQgYSBjaXJjbGUuXG4gKi9cbklHZW9tZXRyeS5maW5kQ2lyY2xlTGluZUludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiAoRXgsIEV5LCBMeCwgTHksIEN4LCBDeSwgcikge1xuXG4gIC8vIEUgaXMgdGhlIHN0YXJ0aW5nIHBvaW50IG9mIHRoZSByYXksXG4gIC8vIEwgaXMgdGhlIGVuZCBwb2ludCBvZiB0aGUgcmF5LFxuICAvLyBDIGlzIHRoZSBjZW50ZXIgb2Ygc3BoZXJlIHlvdSdyZSB0ZXN0aW5nIGFnYWluc3RcbiAgLy8gciBpcyB0aGUgcmFkaXVzIG9mIHRoYXQgc3BoZXJlXG5cbiAgLy8gQ29tcHV0ZTpcbiAgLy8gZCA9IEwgLSBFICggRGlyZWN0aW9uIHZlY3RvciBvZiByYXksIGZyb20gc3RhcnQgdG8gZW5kIClcbiAgLy8gZiA9IEUgLSBDICggVmVjdG9yIGZyb20gY2VudGVyIHNwaGVyZSB0byByYXkgc3RhcnQgKVxuXG4gIC8vIFRoZW4gdGhlIGludGVyc2VjdGlvbiBpcyBmb3VuZCBieS4uXG4gIC8vIFAgPSBFICsgdCAqIGRcbiAgLy8gVGhpcyBpcyBhIHBhcmFtZXRyaWMgZXF1YXRpb246XG4gIC8vIFB4ID0gRXggKyB0ZHhcbiAgLy8gUHkgPSBFeSArIHRkeVxuXG4gIC8vIGdldCBhLCBiLCBjIHZhbHVlc1xuICB2YXIgYSA9IChMeCAtIEV4KSAqIChMeCAtIEV4KSArIChMeSAtIEV5KSAqIChMeSAtIEV5KTtcbiAgdmFyIGIgPSAyICogKChFeCAtIEN4KSAqIChMeCAtIEV4KSArIChFeSAtIEN5KSAqIChMeSAtIEV5KSk7XG4gIHZhciBjID0gKEV4IC0gQ3gpICogKEV4IC0gQ3gpICsgKEV5IC0gQ3kpICogKEV5IC0gQ3kpIC0gciAqIHI7XG5cbiAgLy8gZ2V0IGRpc2NyaW1pbmFudFxuICB2YXIgZGlzYyA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuICBpZiAoZGlzYyA+PSAwKSB7XG4gICAgLy8gaW5zZXJ0IGludG8gcXVhZHJhdGljIGZvcm11bGFcbiAgICB2YXIgdDEgPSAoLWIgKyBNYXRoLnNxcnQoYiAqIGIgLSA0ICogYSAqIGMpKSAvICgyICogYSk7XG4gICAgdmFyIHQyID0gKC1iIC0gTWF0aC5zcXJ0KGIgKiBiIC0gNCAqIGEgKiBjKSkgLyAoMiAqIGEpO1xuICAgIHZhciBpbnRlcnNlY3Rpb25zID0gbnVsbDtcbiAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICAvLyB0MSBpcyB0aGUgaW50ZXJzZWN0aW9uLCBhbmQgaXQncyBjbG9zZXIgdGhhbiB0MlxuICAgICAgLy8gKHNpbmNlIHQxIHVzZXMgLWIgLSBkaXNjcmltaW5hbnQpXG4gICAgICAvLyBJbXBhbGUsIFBva2VcbiAgICAgIHJldHVybiBbdDFdO1xuICAgIH1cblxuICAgIC8vIGhlcmUgdDEgZGlkbid0IGludGVyc2VjdCBzbyB3ZSBhcmUgZWl0aGVyIHN0YXJ0ZWRcbiAgICAvLyBpbnNpZGUgdGhlIHNwaGVyZSBvciBjb21wbGV0ZWx5IHBhc3QgaXRcbiAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAvLyBFeGl0V291bmRcbiAgICAgIHJldHVybiBbdDJdO1xuICAgIH1cblxuICAgIHJldHVybiBpbnRlcnNlY3Rpb25zO1xuICB9IGVsc2UgcmV0dXJuIG51bGw7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU2VjdGlvbjogQ2xhc3MgQ29uc3RhbnRzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBTb21lIHVzZWZ1bCBwcmUtY2FsY3VsYXRlZCBjb25zdGFudHNcbiAqL1xuSUdlb21ldHJ5LkhBTEZfUEkgPSAwLjUgKiBNYXRoLlBJO1xuSUdlb21ldHJ5Lk9ORV9BTkRfSEFMRl9QSSA9IDEuNSAqIE1hdGguUEk7XG5JR2VvbWV0cnkuVFdPX1BJID0gMi4wICogTWF0aC5QSTtcbklHZW9tZXRyeS5USFJFRV9QSSA9IDMuMCAqIE1hdGguUEk7XG5cbm1vZHVsZS5leHBvcnRzID0gSUdlb21ldHJ5O1xuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gSU1hdGgoKSB7fVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIHNpZ24gb2YgdGhlIGlucHV0IHZhbHVlLlxuICovXG5JTWF0aC5zaWduID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA+IDApIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmICh2YWx1ZSA8IDApIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5cbklNYXRoLmZsb29yID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA8IDAgPyBNYXRoLmNlaWwodmFsdWUpIDogTWF0aC5mbG9vcih2YWx1ZSk7XG59O1xuXG5JTWF0aC5jZWlsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA8IDAgPyBNYXRoLmZsb29yKHZhbHVlKSA6IE1hdGguY2VpbCh2YWx1ZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IElNYXRoO1xuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIEludGVnZXIoKSB7fVxuXG5JbnRlZ2VyLk1BWF9WQUxVRSA9IDIxNDc0ODM2NDc7XG5JbnRlZ2VyLk1JTl9WQUxVRSA9IC0yMTQ3NDgzNjQ4O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVnZXI7XG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIG5vZGVGcm9tID0gZnVuY3Rpb24gbm9kZUZyb20odmFsdWUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBuZXh0OiBudWxsLCBwcmV2OiBudWxsIH07XG59O1xuXG52YXIgYWRkID0gZnVuY3Rpb24gYWRkKHByZXYsIG5vZGUsIG5leHQsIGxpc3QpIHtcbiAgaWYgKHByZXYgIT09IG51bGwpIHtcbiAgICBwcmV2Lm5leHQgPSBub2RlO1xuICB9IGVsc2Uge1xuICAgIGxpc3QuaGVhZCA9IG5vZGU7XG4gIH1cblxuICBpZiAobmV4dCAhPT0gbnVsbCkge1xuICAgIG5leHQucHJldiA9IG5vZGU7XG4gIH0gZWxzZSB7XG4gICAgbGlzdC50YWlsID0gbm9kZTtcbiAgfVxuXG4gIG5vZGUucHJldiA9IHByZXY7XG4gIG5vZGUubmV4dCA9IG5leHQ7XG5cbiAgbGlzdC5sZW5ndGgrKztcblxuICByZXR1cm4gbm9kZTtcbn07XG5cbnZhciBfcmVtb3ZlID0gZnVuY3Rpb24gX3JlbW92ZShub2RlLCBsaXN0KSB7XG4gIHZhciBwcmV2ID0gbm9kZS5wcmV2LFxuICAgICAgbmV4dCA9IG5vZGUubmV4dDtcblxuXG4gIGlmIChwcmV2ICE9PSBudWxsKSB7XG4gICAgcHJldi5uZXh0ID0gbmV4dDtcbiAgfSBlbHNlIHtcbiAgICBsaXN0LmhlYWQgPSBuZXh0O1xuICB9XG5cbiAgaWYgKG5leHQgIT09IG51bGwpIHtcbiAgICBuZXh0LnByZXYgPSBwcmV2O1xuICB9IGVsc2Uge1xuICAgIGxpc3QudGFpbCA9IHByZXY7XG4gIH1cblxuICBub2RlLnByZXYgPSBub2RlLm5leHQgPSBudWxsO1xuXG4gIGxpc3QubGVuZ3RoLS07XG5cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG52YXIgTGlua2VkTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTGlua2VkTGlzdCh2YWxzKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMaW5rZWRMaXN0KTtcblxuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IG51bGw7XG5cbiAgICBpZiAodmFscyAhPSBudWxsKSB7XG4gICAgICB2YWxzLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnB1c2godik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTGlua2VkTGlzdCwgW3tcbiAgICBrZXk6IFwic2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaXplKCkge1xuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnNlcnRCZWZvcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKHZhbCwgb3RoZXJOb2RlKSB7XG4gICAgICByZXR1cm4gYWRkKG90aGVyTm9kZS5wcmV2LCBub2RlRnJvbSh2YWwpLCBvdGhlck5vZGUsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnNlcnRBZnRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRBZnRlcih2YWwsIG90aGVyTm9kZSkge1xuICAgICAgcmV0dXJuIGFkZChvdGhlck5vZGUsIG5vZGVGcm9tKHZhbCksIG90aGVyTm9kZS5uZXh0LCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0Tm9kZUJlZm9yZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnROb2RlQmVmb3JlKG5ld05vZGUsIG90aGVyTm9kZSkge1xuICAgICAgcmV0dXJuIGFkZChvdGhlck5vZGUucHJldiwgbmV3Tm9kZSwgb3RoZXJOb2RlLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5zZXJ0Tm9kZUFmdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydE5vZGVBZnRlcihuZXdOb2RlLCBvdGhlck5vZGUpIHtcbiAgICAgIHJldHVybiBhZGQob3RoZXJOb2RlLCBuZXdOb2RlLCBvdGhlck5vZGUubmV4dCwgdGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInB1c2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHVzaCh2YWwpIHtcbiAgICAgIHJldHVybiBhZGQodGhpcy50YWlsLCBub2RlRnJvbSh2YWwpLCBudWxsLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5zaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNoaWZ0KHZhbCkge1xuICAgICAgcmV0dXJuIGFkZChudWxsLCBub2RlRnJvbSh2YWwpLCB0aGlzLmhlYWQsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKG5vZGUpIHtcbiAgICAgIHJldHVybiBfcmVtb3ZlKG5vZGUsIHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwb3BcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9wKCkge1xuICAgICAgcmV0dXJuIF9yZW1vdmUodGhpcy50YWlsLCB0aGlzKS52YWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9wTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3BOb2RlKCkge1xuICAgICAgcmV0dXJuIF9yZW1vdmUodGhpcy50YWlsLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2hpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgICByZXR1cm4gX3JlbW92ZSh0aGlzLmhlYWQsIHRoaXMpLnZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaGlmdE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnROb2RlKCkge1xuICAgICAgcmV0dXJuIF9yZW1vdmUodGhpcy5oZWFkLCB0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0X29iamVjdF9hdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRfb2JqZWN0X2F0KGluZGV4KSB7XG4gICAgICBpZiAoaW5kZXggPD0gdGhpcy5sZW5ndGgoKSkge1xuICAgICAgICB2YXIgaSA9IDE7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5oZWFkO1xuICAgICAgICB3aGlsZSAoaSA8IGluZGV4KSB7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnQudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldF9vYmplY3RfYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0X29iamVjdF9hdChpbmRleCwgdmFsdWUpIHtcbiAgICAgIGlmIChpbmRleCA8PSB0aGlzLmxlbmd0aCgpKSB7XG4gICAgICAgIHZhciBpID0gMTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIHdoaWxlIChpIDwgaW5kZXgpIHtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50LnZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExpbmtlZExpc3Q7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGlua2VkTGlzdDtcblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKlxyXG4gKlRoaXMgY2xhc3MgaXMgdGhlIGphdmFzY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFBvaW50LmphdmEgY2xhc3MgaW4gamRrXHJcbiAqL1xuZnVuY3Rpb24gUG9pbnQoeCwgeSwgcCkge1xuICB0aGlzLnggPSBudWxsO1xuICB0aGlzLnkgPSBudWxsO1xuICBpZiAoeCA9PSBudWxsICYmIHkgPT0gbnVsbCAmJiBwID09IG51bGwpIHtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHggPT0gJ251bWJlcicgJiYgdHlwZW9mIHkgPT0gJ251bWJlcicgJiYgcCA9PSBudWxsKSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9IGVsc2UgaWYgKHguY29uc3RydWN0b3IubmFtZSA9PSAnUG9pbnQnICYmIHkgPT0gbnVsbCAmJiBwID09IG51bGwpIHtcbiAgICBwID0geDtcbiAgICB0aGlzLnggPSBwLng7XG4gICAgdGhpcy55ID0gcC55O1xuICB9XG59XG5cblBvaW50LnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy54O1xufTtcblxuUG9pbnQucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZ2V0TG9jYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLnNldExvY2F0aW9uID0gZnVuY3Rpb24gKHgsIHksIHApIHtcbiAgaWYgKHguY29uc3RydWN0b3IubmFtZSA9PSAnUG9pbnQnICYmIHkgPT0gbnVsbCAmJiBwID09IG51bGwpIHtcbiAgICBwID0geDtcbiAgICB0aGlzLnNldExvY2F0aW9uKHAueCwgcC55KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgeCA9PSAnbnVtYmVyJyAmJiB0eXBlb2YgeSA9PSAnbnVtYmVyJyAmJiBwID09IG51bGwpIHtcbiAgICAvL2lmIGJvdGggcGFyYW1ldGVycyBhcmUgaW50ZWdlciBqdXN0IG1vdmUgKHgseSkgbG9jYXRpb25cbiAgICBpZiAocGFyc2VJbnQoeCkgPT0geCAmJiBwYXJzZUludCh5KSA9PSB5KSB7XG4gICAgICB0aGlzLm1vdmUoeCwgeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMueCA9IE1hdGguZmxvb3IoeCArIDAuNSk7XG4gICAgICB0aGlzLnkgPSBNYXRoLmZsb29yKHkgKyAwLjUpO1xuICAgIH1cbiAgfVxufTtcblxuUG9pbnQucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiAoeCwgeSkge1xuICB0aGlzLnggPSB4O1xuICB0aGlzLnkgPSB5O1xufTtcblxuUG9pbnQucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChkeCwgZHkpIHtcbiAgdGhpcy54ICs9IGR4O1xuICB0aGlzLnkgKz0gZHk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG9iaikge1xuICBpZiAob2JqLmNvbnN0cnVjdG9yLm5hbWUgPT0gXCJQb2ludFwiKSB7XG4gICAgdmFyIHB0ID0gb2JqO1xuICAgIHJldHVybiB0aGlzLnggPT0gcHQueCAmJiB0aGlzLnkgPT0gcHQueTtcbiAgfVxuICByZXR1cm4gdGhpcyA9PSBvYmo7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgUG9pbnQoKS5jb25zdHJ1Y3Rvci5uYW1lICsgXCJbeD1cIiArIHRoaXMueCArIFwiLHk9XCIgKyB0aGlzLnkgKyBcIl1cIjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9pbnQ7XG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gUmVjdGFuZ2xlRCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHRoaXMueCA9IDA7XG4gIHRoaXMueSA9IDA7XG4gIHRoaXMud2lkdGggPSAwO1xuICB0aGlzLmhlaWdodCA9IDA7XG5cbiAgaWYgKHggIT0gbnVsbCAmJiB5ICE9IG51bGwgJiYgd2lkdGggIT0gbnVsbCAmJiBoZWlnaHQgIT0gbnVsbCkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbn1cblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueDtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLnNldFggPSBmdW5jdGlvbiAoeCkge1xuICB0aGlzLnggPSB4O1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueTtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLnNldFkgPSBmdW5jdGlvbiAoeSkge1xuICB0aGlzLnkgPSB5O1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLndpZHRoO1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuc2V0V2lkdGggPSBmdW5jdGlvbiAod2lkdGgpIHtcbiAgdGhpcy53aWR0aCA9IHdpZHRoO1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5oZWlnaHQ7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5zZXRIZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0KSB7XG4gIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0UmlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoO1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0Qm90dG9tID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5pbnRlcnNlY3RzID0gZnVuY3Rpb24gKGEpIHtcbiAgaWYgKHRoaXMuZ2V0UmlnaHQoKSA8IGEueCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLmdldEJvdHRvbSgpIDwgYS55KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGEuZ2V0UmlnaHQoKSA8IHRoaXMueCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChhLmdldEJvdHRvbSgpIDwgdGhpcy55KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRDZW50ZXJYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy54ICsgdGhpcy53aWR0aCAvIDI7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRNaW5YID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5nZXRYKCk7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRNYXhYID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5nZXRYKCkgKyB0aGlzLndpZHRoO1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0Q2VudGVyWSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMueSArIHRoaXMuaGVpZ2h0IC8gMjtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldE1pblkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdldFkoKTtcbn07XG5cblJlY3RhbmdsZUQucHJvdG90eXBlLmdldE1heFkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdldFkoKSArIHRoaXMuaGVpZ2h0O1xufTtcblxuUmVjdGFuZ2xlRC5wcm90b3R5cGUuZ2V0V2lkdGhIYWxmID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy53aWR0aCAvIDI7XG59O1xuXG5SZWN0YW5nbGVELnByb3RvdHlwZS5nZXRIZWlnaHRIYWxmID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5oZWlnaHQgLyAyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWN0YW5nbGVEO1xuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gVW5pcXVlSURHZW5lcmV0b3IoKSB7fVxuXG5VbmlxdWVJREdlbmVyZXRvci5sYXN0SUQgPSAwO1xuXG5VbmlxdWVJREdlbmVyZXRvci5jcmVhdGVJRCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgaWYgKFVuaXF1ZUlER2VuZXJldG9yLmlzUHJpbWl0aXZlKG9iaikpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIGlmIChvYmoudW5pcXVlSUQgIT0gbnVsbCkge1xuICAgIHJldHVybiBvYmoudW5pcXVlSUQ7XG4gIH1cbiAgb2JqLnVuaXF1ZUlEID0gVW5pcXVlSURHZW5lcmV0b3IuZ2V0U3RyaW5nKCk7XG4gIFVuaXF1ZUlER2VuZXJldG9yLmxhc3RJRCsrO1xuICByZXR1cm4gb2JqLnVuaXF1ZUlEO1xufTtcblxuVW5pcXVlSURHZW5lcmV0b3IuZ2V0U3RyaW5nID0gZnVuY3Rpb24gKGlkKSB7XG4gIGlmIChpZCA9PSBudWxsKSBpZCA9IFVuaXF1ZUlER2VuZXJldG9yLmxhc3RJRDtcbiAgcmV0dXJuIFwiT2JqZWN0I1wiICsgaWQgKyBcIlwiO1xufTtcblxuVW5pcXVlSURHZW5lcmV0b3IuaXNQcmltaXRpdmUgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGFyZyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGFyZyk7XG4gIHJldHVybiBhcmcgPT0gbnVsbCB8fCB0eXBlICE9IFwib2JqZWN0XCIgJiYgdHlwZSAhPSBcImZ1bmN0aW9uXCI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVuaXF1ZUlER2VuZXJldG9yO1xuXG4vKioqLyB9KSxcbi8qIDE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxuXG52YXIgTGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBMR3JhcGhNYW5hZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbnZhciBMTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG52YXIgTEVkZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xudmFyIExHcmFwaCA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG52YXIgUG9pbnREID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbnZhciBUcmFuc2Zvcm0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcbnZhciBFbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG5cbmZ1bmN0aW9uIExheW91dChpc1JlbW90ZVVzZSkge1xuICBFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgLy9MYXlvdXQgUXVhbGl0eTogMDpkcmFmdCwgMTpkZWZhdWx0LCAyOnByb29mXG4gIHRoaXMubGF5b3V0UXVhbGl0eSA9IExheW91dENvbnN0YW50cy5RVUFMSVRZO1xuICAvL1doZXRoZXIgbGF5b3V0IHNob3VsZCBjcmVhdGUgYmVuZHBvaW50cyBhcyBuZWVkZWQgb3Igbm90XG4gIHRoaXMuY3JlYXRlQmVuZHNBc05lZWRlZCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0NSRUFURV9CRU5EU19BU19ORUVERUQ7XG4gIC8vV2hldGhlciBsYXlvdXQgc2hvdWxkIGJlIGluY3JlbWVudGFsIG9yIG5vdFxuICB0aGlzLmluY3JlbWVudGFsID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfSU5DUkVNRU5UQUw7XG4gIC8vV2hldGhlciB3ZSBhbmltYXRlIGZyb20gYmVmb3JlIHRvIGFmdGVyIGxheW91dCBub2RlIHBvc2l0aW9uc1xuICB0aGlzLmFuaW1hdGlvbk9uTGF5b3V0ID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQU5JTUFUSU9OX09OX0xBWU9VVDtcbiAgLy9XaGV0aGVyIHdlIGFuaW1hdGUgdGhlIGxheW91dCBwcm9jZXNzIG9yIG5vdFxuICB0aGlzLmFuaW1hdGlvbkR1cmluZ0xheW91dCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0FOSU1BVElPTl9EVVJJTkdfTEFZT1VUO1xuICAvL051bWJlciBpdGVyYXRpb25zIHRoYXQgc2hvdWxkIGJlIGRvbmUgYmV0d2VlbiB0d28gc3VjY2Vzc2l2ZSBhbmltYXRpb25zXG4gIHRoaXMuYW5pbWF0aW9uUGVyaW9kID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQU5JTUFUSU9OX1BFUklPRDtcbiAgLyoqXHJcbiAgICogV2hldGhlciBvciBub3QgbGVhZiBub2RlcyAobm9uLWNvbXBvdW5kIG5vZGVzKSBhcmUgb2YgdW5pZm9ybSBzaXplcy4gV2hlblxyXG4gICAqIHRoZXkgYXJlLCBib3RoIHNwcmluZyBhbmQgcmVwdWxzaW9uIGZvcmNlcyBiZXR3ZWVuIHR3byBsZWFmIG5vZGVzIGNhbiBiZVxyXG4gICAqIGNhbGN1bGF0ZWQgd2l0aG91dCB0aGUgZXhwZW5zaXZlIGNsaXBwaW5nIHBvaW50IGNhbGN1bGF0aW9ucywgcmVzdWx0aW5nXHJcbiAgICogaW4gbWFqb3Igc3BlZWQtdXAuXHJcbiAgICovXG4gIHRoaXMudW5pZm9ybUxlYWZOb2RlU2l6ZXMgPSBMYXlvdXRDb25zdGFudHMuREVGQVVMVF9VTklGT1JNX0xFQUZfTk9ERV9TSVpFUztcbiAgLyoqXHJcbiAgICogVGhpcyBpcyB1c2VkIGZvciBjcmVhdGlvbiBvZiBiZW5kcG9pbnRzIGJ5IHVzaW5nIGR1bW15IG5vZGVzIGFuZCBlZGdlcy5cclxuICAgKiBNYXBzIGFuIExFZGdlIHRvIGl0cyBkdW1teSBiZW5kcG9pbnQgcGF0aC5cclxuICAgKi9cbiAgdGhpcy5lZGdlVG9EdW1teU5vZGVzID0gbmV3IE1hcCgpO1xuICB0aGlzLmdyYXBoTWFuYWdlciA9IG5ldyBMR3JhcGhNYW5hZ2VyKHRoaXMpO1xuICB0aGlzLmlzTGF5b3V0RmluaXNoZWQgPSBmYWxzZTtcbiAgdGhpcy5pc1N1YkxheW91dCA9IGZhbHNlO1xuICB0aGlzLmlzUmVtb3RlVXNlID0gZmFsc2U7XG5cbiAgaWYgKGlzUmVtb3RlVXNlICE9IG51bGwpIHtcbiAgICB0aGlzLmlzUmVtb3RlVXNlID0gaXNSZW1vdGVVc2U7XG4gIH1cbn1cblxuTGF5b3V0LlJBTkRPTV9TRUVEID0gMTtcblxuTGF5b3V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRW1pdHRlci5wcm90b3R5cGUpO1xuXG5MYXlvdXQucHJvdG90eXBlLmdldEdyYXBoTWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ3JhcGhNYW5hZ2VyO1xufTtcblxuTGF5b3V0LnByb3RvdHlwZS5nZXRBbGxOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ3JhcGhNYW5hZ2VyLmdldEFsbE5vZGVzKCk7XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLmdldEFsbEVkZ2VzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsRWRnZXMoKTtcbn07XG5cbkxheW91dC5wcm90b3R5cGUuZ2V0QWxsTm9kZXNUb0FwcGx5R3Jhdml0YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxOb2Rlc1RvQXBwbHlHcmF2aXRhdGlvbigpO1xufTtcblxuTGF5b3V0LnByb3RvdHlwZS5uZXdHcmFwaE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBnbSA9IG5ldyBMR3JhcGhNYW5hZ2VyKHRoaXMpO1xuICB0aGlzLmdyYXBoTWFuYWdlciA9IGdtO1xuICByZXR1cm4gZ207XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLm5ld0dyYXBoID0gZnVuY3Rpb24gKHZHcmFwaCkge1xuICByZXR1cm4gbmV3IExHcmFwaChudWxsLCB0aGlzLmdyYXBoTWFuYWdlciwgdkdyYXBoKTtcbn07XG5cbkxheW91dC5wcm90b3R5cGUubmV3Tm9kZSA9IGZ1bmN0aW9uICh2Tm9kZSkge1xuICByZXR1cm4gbmV3IExOb2RlKHRoaXMuZ3JhcGhNYW5hZ2VyLCB2Tm9kZSk7XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLm5ld0VkZ2UgPSBmdW5jdGlvbiAodkVkZ2UpIHtcbiAgcmV0dXJuIG5ldyBMRWRnZShudWxsLCBudWxsLCB2RWRnZSk7XG59O1xuXG5MYXlvdXQucHJvdG90eXBlLmNoZWNrTGF5b3V0U3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKSA9PSBudWxsIHx8IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKS5nZXROb2RlcygpLmxlbmd0aCA9PSAwIHx8IHRoaXMuZ3JhcGhNYW5hZ2VyLmluY2x1ZGVzSW52YWxpZEVkZ2UoKTtcbn07XG5cbkxheW91dC5wcm90b3R5cGUucnVuTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmlzTGF5b3V0RmluaXNoZWQgPSBmYWxzZTtcblxuICBpZiAodGhpcy50aWxpbmdQcmVMYXlvdXQpIHtcbiAgICB0aGlzLnRpbGluZ1ByZUxheW91dCgpO1xuICB9XG5cbiAgdGhpcy5pbml0UGFyYW1ldGVycygpO1xuICB2YXIgaXNMYXlvdXRTdWNjZXNzZnVsbDtcblxuICBpZiAodGhpcy5jaGVja0xheW91dFN1Y2Nlc3MoKSkge1xuICAgIGlzTGF5b3V0U3VjY2Vzc2Z1bGwgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBpc0xheW91dFN1Y2Nlc3NmdWxsID0gdGhpcy5sYXlvdXQoKTtcbiAgfVxuXG4gIGlmIChMYXlvdXRDb25zdGFudHMuQU5JTUFURSA9PT0gJ2R1cmluZycpIHtcbiAgICAvLyBJZiB0aGlzIGlzIGEgJ2R1cmluZycgbGF5b3V0IGFuaW1hdGlvbi4gTGF5b3V0IGlzIG5vdCBmaW5pc2hlZCB5ZXQuIFxuICAgIC8vIFdlIG5lZWQgdG8gcGVyZm9ybSB0aGVzZSBpbiBpbmRleC5qcyB3aGVuIGxheW91dCBpcyByZWFsbHkgZmluaXNoZWQuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGlzTGF5b3V0U3VjY2Vzc2Z1bGwpIHtcbiAgICBpZiAoIXRoaXMuaXNTdWJMYXlvdXQpIHtcbiAgICAgIHRoaXMuZG9Qb3N0TGF5b3V0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMudGlsaW5nUG9zdExheW91dCkge1xuICAgIHRoaXMudGlsaW5nUG9zdExheW91dCgpO1xuICB9XG5cbiAgdGhpcy5pc0xheW91dEZpbmlzaGVkID0gdHJ1ZTtcblxuICByZXR1cm4gaXNMYXlvdXRTdWNjZXNzZnVsbDtcbn07XG5cbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCBwZXJmb3JtcyB0aGUgb3BlcmF0aW9ucyByZXF1aXJlZCBhZnRlciBsYXlvdXQuXHJcbiAqL1xuTGF5b3V0LnByb3RvdHlwZS5kb1Bvc3RMYXlvdXQgPSBmdW5jdGlvbiAoKSB7XG4gIC8vYXNzZXJ0ICFpc1N1YkxheW91dCA6IFwiU2hvdWxkIG5vdCBiZSBjYWxsZWQgb24gc3ViLWxheW91dCFcIjtcbiAgLy8gUHJvcGFnYXRlIGdlb21ldHJpYyBjaGFuZ2VzIHRvIHYtbGV2ZWwgb2JqZWN0c1xuICBpZiAoIXRoaXMuaW5jcmVtZW50YWwpIHtcbiAgICB0aGlzLnRyYW5zZm9ybSgpO1xuICB9XG4gIHRoaXMudXBkYXRlKCk7XG59O1xuXG4vKipcclxuICogVGhpcyBtZXRob2QgdXBkYXRlcyB0aGUgZ2VvbWV0cnkgb2YgdGhlIHRhcmdldCBncmFwaCBhY2NvcmRpbmcgdG9cclxuICogY2FsY3VsYXRlZCBsYXlvdXQuXHJcbiAqL1xuTGF5b3V0LnByb3RvdHlwZS51cGRhdGUyID0gZnVuY3Rpb24gKCkge1xuICAvLyB1cGRhdGUgYmVuZCBwb2ludHNcbiAgaWYgKHRoaXMuY3JlYXRlQmVuZHNBc05lZWRlZCkge1xuICAgIHRoaXMuY3JlYXRlQmVuZHBvaW50c0Zyb21EdW1teU5vZGVzKCk7XG5cbiAgICAvLyByZXNldCBhbGwgZWRnZXMsIHNpbmNlIHRoZSB0b3BvbG9neSBoYXMgY2hhbmdlZFxuICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLnJlc2V0QWxsRWRnZXMoKTtcbiAgfVxuXG4gIC8vIHBlcmZvcm0gZWRnZSwgbm9kZSBhbmQgcm9vdCB1cGRhdGVzIGlmIGxheW91dCBpcyBub3QgY2FsbGVkXG4gIC8vIHJlbW90ZWx5XG4gIGlmICghdGhpcy5pc1JlbW90ZVVzZSkge1xuICAgIC8vIHVwZGF0ZSBhbGwgZWRnZXNcbiAgICB2YXIgZWRnZTtcbiAgICB2YXIgYWxsRWRnZXMgPSB0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxFZGdlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGVkZ2UgPSBhbGxFZGdlc1tpXTtcbiAgICAgIC8vICAgICAgdGhpcy51cGRhdGUoZWRnZSk7XG4gICAgfVxuXG4gICAgLy8gcmVjdXJzaXZlbHkgdXBkYXRlIG5vZGVzXG4gICAgdmFyIG5vZGU7XG4gICAgdmFyIG5vZGVzID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpLmdldE5vZGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgLy8gICAgICB0aGlzLnVwZGF0ZShub2RlKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgcm9vdCBncmFwaFxuICAgIHRoaXMudXBkYXRlKHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKSk7XG4gIH1cbn07XG5cbkxheW91dC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG9iaikge1xuICBpZiAob2JqID09IG51bGwpIHtcbiAgICB0aGlzLnVwZGF0ZTIoKTtcbiAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBMTm9kZSkge1xuICAgIHZhciBub2RlID0gb2JqO1xuICAgIGlmIChub2RlLmdldENoaWxkKCkgIT0gbnVsbCkge1xuICAgICAgLy8gc2luY2Ugbm9kZSBpcyBjb21wb3VuZCwgcmVjdXJzaXZlbHkgdXBkYXRlIGNoaWxkIG5vZGVzXG4gICAgICB2YXIgbm9kZXMgPSBub2RlLmdldENoaWxkKCkuZ2V0Tm9kZXMoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdXBkYXRlKG5vZGVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB0aGUgbC1sZXZlbCBub2RlIGlzIGFzc29jaWF0ZWQgd2l0aCBhIHYtbGV2ZWwgZ3JhcGggb2JqZWN0LFxuICAgIC8vIHRoZW4gaXQgaXMgYXNzdW1lZCB0aGF0IHRoZSB2LWxldmVsIG5vZGUgaW1wbGVtZW50cyB0aGVcbiAgICAvLyBpbnRlcmZhY2UgVXBkYXRhYmxlLlxuICAgIGlmIChub2RlLnZHcmFwaE9iamVjdCAhPSBudWxsKSB7XG4gICAgICAvLyBjYXN0IHRvIFVwZGF0YWJsZSB3aXRob3V0IGFueSB0eXBlIGNoZWNrXG4gICAgICB2YXIgdk5vZGUgPSBub2RlLnZHcmFwaE9iamVjdDtcblxuICAgICAgLy8gY2FsbCB0aGUgdXBkYXRlIG1ldGhvZCBvZiB0aGUgaW50ZXJmYWNlXG4gICAgICB2Tm9kZS51cGRhdGUobm9kZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIExFZGdlKSB7XG4gICAgdmFyIGVkZ2UgPSBvYmo7XG4gICAgLy8gaWYgdGhlIGwtbGV2ZWwgZWRnZSBpcyBhc3NvY2lhdGVkIHdpdGggYSB2LWxldmVsIGdyYXBoIG9iamVjdCxcbiAgICAvLyB0aGVuIGl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgdi1sZXZlbCBlZGdlIGltcGxlbWVudHMgdGhlXG4gICAgLy8gaW50ZXJmYWNlIFVwZGF0YWJsZS5cblxuICAgIGlmIChlZGdlLnZHcmFwaE9iamVjdCAhPSBudWxsKSB7XG4gICAgICAvLyBjYXN0IHRvIFVwZGF0YWJsZSB3aXRob3V0IGFueSB0eXBlIGNoZWNrXG4gICAgICB2YXIgdkVkZ2UgPSBlZGdlLnZHcmFwaE9iamVjdDtcblxuICAgICAgLy8gY2FsbCB0aGUgdXBkYXRlIG1ldGhvZCBvZiB0aGUgaW50ZXJmYWNlXG4gICAgICB2RWRnZS51cGRhdGUoZWRnZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIExHcmFwaCkge1xuICAgIHZhciBncmFwaCA9IG9iajtcbiAgICAvLyBpZiB0aGUgbC1sZXZlbCBncmFwaCBpcyBhc3NvY2lhdGVkIHdpdGggYSB2LWxldmVsIGdyYXBoIG9iamVjdCxcbiAgICAvLyB0aGVuIGl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgdi1sZXZlbCBvYmplY3QgaW1wbGVtZW50cyB0aGVcbiAgICAvLyBpbnRlcmZhY2UgVXBkYXRhYmxlLlxuXG4gICAgaWYgKGdyYXBoLnZHcmFwaE9iamVjdCAhPSBudWxsKSB7XG4gICAgICAvLyBjYXN0IHRvIFVwZGF0YWJsZSB3aXRob3V0IGFueSB0eXBlIGNoZWNrXG4gICAgICB2YXIgdkdyYXBoID0gZ3JhcGgudkdyYXBoT2JqZWN0O1xuXG4gICAgICAvLyBjYWxsIHRoZSB1cGRhdGUgbWV0aG9kIG9mIHRoZSBpbnRlcmZhY2VcbiAgICAgIHZHcmFwaC51cGRhdGUoZ3JhcGgpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gc2V0IGFsbCBsYXlvdXQgcGFyYW1ldGVycyB0byBkZWZhdWx0IHZhbHVlc1xyXG4gKiBkZXRlcm1pbmVkIGF0IGNvbXBpbGUgdGltZS5cclxuICovXG5MYXlvdXQucHJvdG90eXBlLmluaXRQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuaXNTdWJMYXlvdXQpIHtcbiAgICB0aGlzLmxheW91dFF1YWxpdHkgPSBMYXlvdXRDb25zdGFudHMuUVVBTElUWTtcbiAgICB0aGlzLmFuaW1hdGlvbkR1cmluZ0xheW91dCA9IExheW91dENvbnN0YW50cy5ERUZBVUxUX0FOSU1BVElPTl9EVVJJTkdfTEFZT1VUO1xuICAgIHRoaXMuYW5pbWF0aW9uUGVyaW9kID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQU5JTUFUSU9OX1BFUklPRDtcbiAgICB0aGlzLmFuaW1hdGlvbk9uTGF5b3V0ID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQU5JTUFUSU9OX09OX0xBWU9VVDtcbiAgICB0aGlzLmluY3JlbWVudGFsID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfSU5DUkVNRU5UQUw7XG4gICAgdGhpcy5jcmVhdGVCZW5kc0FzTmVlZGVkID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfQ1JFQVRFX0JFTkRTX0FTX05FRURFRDtcbiAgICB0aGlzLnVuaWZvcm1MZWFmTm9kZVNpemVzID0gTGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfVU5JRk9STV9MRUFGX05PREVfU0laRVM7XG4gIH1cblxuICBpZiAodGhpcy5hbmltYXRpb25EdXJpbmdMYXlvdXQpIHtcbiAgICB0aGlzLmFuaW1hdGlvbk9uTGF5b3V0ID0gZmFsc2U7XG4gIH1cbn07XG5cbkxheW91dC5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gKG5ld0xlZnRUb3ApIHtcbiAgaWYgKG5ld0xlZnRUb3AgPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy50cmFuc2Zvcm0obmV3IFBvaW50RCgwLCAwKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gY3JlYXRlIGEgdHJhbnNmb3JtYXRpb24gb2JqZWN0IChmcm9tIEVjbGlwc2UgdG8gbGF5b3V0KS4gV2hlbiBhblxuICAgIC8vIGludmVyc2UgdHJhbnNmb3JtIGlzIGFwcGxpZWQsIHdlIGdldCB1cHBlci1sZWZ0IGNvb3JkaW5hdGUgb2YgdGhlXG4gICAgLy8gZHJhd2luZyBvciB0aGUgcm9vdCBncmFwaCBhdCBnaXZlbiBpbnB1dCBjb29yZGluYXRlIChzb21lIG1hcmdpbnNcbiAgICAvLyBhbHJlYWR5IGluY2x1ZGVkIGluIGNhbGN1bGF0aW9uIG9mIGxlZnQtdG9wKS5cblxuICAgIHZhciB0cmFucyA9IG5ldyBUcmFuc2Zvcm0oKTtcbiAgICB2YXIgbGVmdFRvcCA9IHRoaXMuZ3JhcGhNYW5hZ2VyLmdldFJvb3QoKS51cGRhdGVMZWZ0VG9wKCk7XG5cbiAgICBpZiAobGVmdFRvcCAhPSBudWxsKSB7XG4gICAgICB0cmFucy5zZXRXb3JsZE9yZ1gobmV3TGVmdFRvcC54KTtcbiAgICAgIHRyYW5zLnNldFdvcmxkT3JnWShuZXdMZWZ0VG9wLnkpO1xuXG4gICAgICB0cmFucy5zZXREZXZpY2VPcmdYKGxlZnRUb3AueCk7XG4gICAgICB0cmFucy5zZXREZXZpY2VPcmdZKGxlZnRUb3AueSk7XG5cbiAgICAgIHZhciBub2RlcyA9IHRoaXMuZ2V0QWxsTm9kZXMoKTtcbiAgICAgIHZhciBub2RlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgbm9kZS50cmFuc2Zvcm0odHJhbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuTGF5b3V0LnByb3RvdHlwZS5wb3NpdGlvbk5vZGVzUmFuZG9tbHkgPSBmdW5jdGlvbiAoZ3JhcGgpIHtcblxuICBpZiAoZ3JhcGggPT0gdW5kZWZpbmVkKSB7XG4gICAgLy9hc3NlcnQgIXRoaXMuaW5jcmVtZW50YWw7XG4gICAgdGhpcy5wb3NpdGlvbk5vZGVzUmFuZG9tbHkodGhpcy5nZXRHcmFwaE1hbmFnZXIoKS5nZXRSb290KCkpO1xuICAgIHRoaXMuZ2V0R3JhcGhNYW5hZ2VyKCkuZ2V0Um9vdCgpLnVwZGF0ZUJvdW5kcyh0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbE5vZGU7XG4gICAgdmFyIGNoaWxkR3JhcGg7XG5cbiAgICB2YXIgbm9kZXMgPSBncmFwaC5nZXROb2RlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxOb2RlID0gbm9kZXNbaV07XG4gICAgICBjaGlsZEdyYXBoID0gbE5vZGUuZ2V0Q2hpbGQoKTtcblxuICAgICAgaWYgKGNoaWxkR3JhcGggPT0gbnVsbCkge1xuICAgICAgICBsTm9kZS5zY2F0dGVyKCk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkR3JhcGguZ2V0Tm9kZXMoKS5sZW5ndGggPT0gMCkge1xuICAgICAgICBsTm9kZS5zY2F0dGVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBvc2l0aW9uTm9kZXNSYW5kb21seShjaGlsZEdyYXBoKTtcbiAgICAgICAgbE5vZGUudXBkYXRlQm91bmRzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcclxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIGxpc3Qgb2YgdHJlZXMgd2hlcmUgZWFjaCB0cmVlIGlzIHJlcHJlc2VudGVkIGFzIGFcclxuICogbGlzdCBvZiBsLW5vZGVzLiBUaGUgbWV0aG9kIHJldHVybnMgYSBsaXN0IG9mIHNpemUgMCB3aGVuOlxyXG4gKiAtIFRoZSBncmFwaCBpcyBub3QgZmxhdCBvclxyXG4gKiAtIE9uZSBvZiB0aGUgY29tcG9uZW50KHMpIG9mIHRoZSBncmFwaCBpcyBub3QgYSB0cmVlLlxyXG4gKi9cbkxheW91dC5wcm90b3R5cGUuZ2V0RmxhdEZvcmVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGZsYXRGb3Jlc3QgPSBbXTtcbiAgdmFyIGlzRm9yZXN0ID0gdHJ1ZTtcblxuICAvLyBRdWljayByZWZlcmVuY2UgZm9yIGFsbCBub2RlcyBpbiB0aGUgZ3JhcGggbWFuYWdlciBhc3NvY2lhdGVkIHdpdGhcbiAgLy8gdGhpcyBsYXlvdXQuIFRoZSBsaXN0IHNob3VsZCBub3QgYmUgY2hhbmdlZC5cbiAgdmFyIGFsbE5vZGVzID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpLmdldE5vZGVzKCk7XG5cbiAgLy8gRmlyc3QgYmUgc3VyZSB0aGF0IHRoZSBncmFwaCBpcyBmbGF0XG4gIHZhciBpc0ZsYXQgPSB0cnVlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYWxsTm9kZXNbaV0uZ2V0Q2hpbGQoKSAhPSBudWxsKSB7XG4gICAgICBpc0ZsYXQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm4gZW1wdHkgZm9yZXN0IGlmIHRoZSBncmFwaCBpcyBub3QgZmxhdC5cbiAgaWYgKCFpc0ZsYXQpIHtcbiAgICByZXR1cm4gZmxhdEZvcmVzdDtcbiAgfVxuXG4gIC8vIFJ1biBCRlMgZm9yIGVhY2ggY29tcG9uZW50IG9mIHRoZSBncmFwaC5cblxuICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgdmFyIHRvQmVWaXNpdGVkID0gW107XG4gIHZhciBwYXJlbnRzID0gbmV3IE1hcCgpO1xuICB2YXIgdW5Qcm9jZXNzZWROb2RlcyA9IFtdO1xuXG4gIHVuUHJvY2Vzc2VkTm9kZXMgPSB1blByb2Nlc3NlZE5vZGVzLmNvbmNhdChhbGxOb2Rlcyk7XG5cbiAgLy8gRWFjaCBpdGVyYXRpb24gb2YgdGhpcyBsb29wIGZpbmRzIGEgY29tcG9uZW50IG9mIHRoZSBncmFwaCBhbmRcbiAgLy8gZGVjaWRlcyB3aGV0aGVyIGl0IGlzIGEgdHJlZSBvciBub3QuIElmIGl0IGlzIGEgdHJlZSwgYWRkcyBpdCB0byB0aGVcbiAgLy8gZm9yZXN0IGFuZCBjb250aW51ZWQgd2l0aCB0aGUgbmV4dCBjb21wb25lbnQuXG5cbiAgd2hpbGUgKHVuUHJvY2Vzc2VkTm9kZXMubGVuZ3RoID4gMCAmJiBpc0ZvcmVzdCkge1xuICAgIHRvQmVWaXNpdGVkLnB1c2godW5Qcm9jZXNzZWROb2Rlc1swXSk7XG5cbiAgICAvLyBTdGFydCB0aGUgQkZTLiBFYWNoIGl0ZXJhdGlvbiBvZiB0aGlzIGxvb3AgdmlzaXRzIGEgbm9kZSBpbiBhXG4gICAgLy8gQkZTIG1hbm5lci5cbiAgICB3aGlsZSAodG9CZVZpc2l0ZWQubGVuZ3RoID4gMCAmJiBpc0ZvcmVzdCkge1xuICAgICAgLy9wb29sIG9wZXJhdGlvblxuICAgICAgdmFyIGN1cnJlbnROb2RlID0gdG9CZVZpc2l0ZWRbMF07XG4gICAgICB0b0JlVmlzaXRlZC5zcGxpY2UoMCwgMSk7XG4gICAgICB2aXNpdGVkLmFkZChjdXJyZW50Tm9kZSk7XG5cbiAgICAgIC8vIFRyYXZlcnNlIGFsbCBuZWlnaGJvcnMgb2YgdGhpcyBub2RlXG4gICAgICB2YXIgbmVpZ2hib3JFZGdlcyA9IGN1cnJlbnROb2RlLmdldEVkZ2VzKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmVpZ2hib3JFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY3VycmVudE5laWdoYm9yID0gbmVpZ2hib3JFZGdlc1tpXS5nZXRPdGhlckVuZChjdXJyZW50Tm9kZSk7XG5cbiAgICAgICAgLy8gSWYgQkZTIGlzIG5vdCBncm93aW5nIGZyb20gdGhpcyBuZWlnaGJvci5cbiAgICAgICAgaWYgKHBhcmVudHMuZ2V0KGN1cnJlbnROb2RlKSAhPSBjdXJyZW50TmVpZ2hib3IpIHtcbiAgICAgICAgICAvLyBXZSBoYXZlbid0IHByZXZpb3VzbHkgdmlzaXRlZCB0aGlzIG5laWdoYm9yLlxuICAgICAgICAgIGlmICghdmlzaXRlZC5oYXMoY3VycmVudE5laWdoYm9yKSkge1xuICAgICAgICAgICAgdG9CZVZpc2l0ZWQucHVzaChjdXJyZW50TmVpZ2hib3IpO1xuICAgICAgICAgICAgcGFyZW50cy5zZXQoY3VycmVudE5laWdoYm9yLCBjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFNpbmNlIHdlIGhhdmUgcHJldmlvdXNseSB2aXNpdGVkIHRoaXMgbmVpZ2hib3IgYW5kXG4gICAgICAgICAgLy8gdGhpcyBuZWlnaGJvciBpcyBub3QgcGFyZW50IG9mIGN1cnJlbnROb2RlLCBnaXZlblxuICAgICAgICAgIC8vIGdyYXBoIGNvbnRhaW5zIGEgY29tcG9uZW50IHRoYXQgaXMgbm90IHRyZWUsIGhlbmNlXG4gICAgICAgICAgLy8gaXQgaXMgbm90IGEgZm9yZXN0LlxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBpc0ZvcmVzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZSBncmFwaCBjb250YWlucyBhIGNvbXBvbmVudCB0aGF0IGlzIG5vdCBhIHRyZWUuIEVtcHR5XG4gICAgLy8gcHJldmlvdXNseSBmb3VuZCB0cmVlcy4gVGhlIG1ldGhvZCB3aWxsIGVuZC5cbiAgICBpZiAoIWlzRm9yZXN0KSB7XG4gICAgICBmbGF0Rm9yZXN0ID0gW107XG4gICAgfVxuICAgIC8vIFNhdmUgY3VycmVudGx5IHZpc2l0ZWQgbm9kZXMgYXMgYSB0cmVlIGluIG91ciBmb3Jlc3QuIFJlc2V0XG4gICAgLy8gdmlzaXRlZCBhbmQgcGFyZW50cyBsaXN0cy4gQ29udGludWUgd2l0aCB0aGUgbmV4dCBjb21wb25lbnQgb2ZcbiAgICAvLyB0aGUgZ3JhcGgsIGlmIGFueS5cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHRlbXAgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHZpc2l0ZWQpKTtcbiAgICAgICAgZmxhdEZvcmVzdC5wdXNoKHRlbXApO1xuICAgICAgICAvL2ZsYXRGb3Jlc3QgPSBmbGF0Rm9yZXN0LmNvbmNhdCh0ZW1wKTtcbiAgICAgICAgLy91blByb2Nlc3NlZE5vZGVzLnJlbW92ZUFsbCh2aXNpdGVkKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZW1wLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdGVtcFtpXTtcbiAgICAgICAgICB2YXIgaW5kZXggPSB1blByb2Nlc3NlZE5vZGVzLmluZGV4T2YodmFsdWUpO1xuICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB1blByb2Nlc3NlZE5vZGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gICAgICAgIHBhcmVudHMgPSBuZXcgTWFwKCk7XG4gICAgICB9XG4gIH1cblxuICByZXR1cm4gZmxhdEZvcmVzdDtcbn07XG5cbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGR1bW15IG5vZGVzIChhbiBsLWxldmVsIG5vZGUgd2l0aCBtaW5pbWFsIGRpbWVuc2lvbnMpXHJcbiAqIGZvciB0aGUgZ2l2ZW4gZWRnZSAob25lIHBlciBiZW5kcG9pbnQpLiBUaGUgZXhpc3RpbmcgbC1sZXZlbCBzdHJ1Y3R1cmVcclxuICogaXMgdXBkYXRlZCBhY2NvcmRpbmdseS5cclxuICovXG5MYXlvdXQucHJvdG90eXBlLmNyZWF0ZUR1bW15Tm9kZXNGb3JCZW5kcG9pbnRzID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgdmFyIGR1bW15Tm9kZXMgPSBbXTtcbiAgdmFyIHByZXYgPSBlZGdlLnNvdXJjZTtcblxuICB2YXIgZ3JhcGggPSB0aGlzLmdyYXBoTWFuYWdlci5jYWxjTG93ZXN0Q29tbW9uQW5jZXN0b3IoZWRnZS5zb3VyY2UsIGVkZ2UudGFyZ2V0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2UuYmVuZHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIC8vIGNyZWF0ZSBuZXcgZHVtbXkgbm9kZVxuICAgIHZhciBkdW1teU5vZGUgPSB0aGlzLm5ld05vZGUobnVsbCk7XG4gICAgZHVtbXlOb2RlLnNldFJlY3QobmV3IFBvaW50KDAsIDApLCBuZXcgRGltZW5zaW9uKDEsIDEpKTtcblxuICAgIGdyYXBoLmFkZChkdW1teU5vZGUpO1xuXG4gICAgLy8gY3JlYXRlIG5ldyBkdW1teSBlZGdlIGJldHdlZW4gcHJldiBhbmQgZHVtbXkgbm9kZVxuICAgIHZhciBkdW1teUVkZ2UgPSB0aGlzLm5ld0VkZ2UobnVsbCk7XG4gICAgdGhpcy5ncmFwaE1hbmFnZXIuYWRkKGR1bW15RWRnZSwgcHJldiwgZHVtbXlOb2RlKTtcblxuICAgIGR1bW15Tm9kZXMuYWRkKGR1bW15Tm9kZSk7XG4gICAgcHJldiA9IGR1bW15Tm9kZTtcbiAgfVxuXG4gIHZhciBkdW1teUVkZ2UgPSB0aGlzLm5ld0VkZ2UobnVsbCk7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyLmFkZChkdW1teUVkZ2UsIHByZXYsIGVkZ2UudGFyZ2V0KTtcblxuICB0aGlzLmVkZ2VUb0R1bW15Tm9kZXMuc2V0KGVkZ2UsIGR1bW15Tm9kZXMpO1xuXG4gIC8vIHJlbW92ZSByZWFsIGVkZ2UgZnJvbSBncmFwaCBtYW5hZ2VyIGlmIGl0IGlzIGludGVyLWdyYXBoXG4gIGlmIChlZGdlLmlzSW50ZXJHcmFwaCgpKSB7XG4gICAgdGhpcy5ncmFwaE1hbmFnZXIucmVtb3ZlKGVkZ2UpO1xuICB9XG4gIC8vIGVsc2UsIHJlbW92ZSB0aGUgZWRnZSBmcm9tIHRoZSBjdXJyZW50IGdyYXBoXG4gIGVsc2Uge1xuICAgICAgZ3JhcGgucmVtb3ZlKGVkZ2UpO1xuICAgIH1cblxuICByZXR1cm4gZHVtbXlOb2Rlcztcbn07XG5cbi8qKlxyXG4gKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGJlbmRwb2ludHMgZm9yIGVkZ2VzIGZyb20gdGhlIGR1bW15IG5vZGVzXHJcbiAqIGF0IGwtbGV2ZWwuXHJcbiAqL1xuTGF5b3V0LnByb3RvdHlwZS5jcmVhdGVCZW5kcG9pbnRzRnJvbUR1bW15Tm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlZGdlcyA9IFtdO1xuICBlZGdlcyA9IGVkZ2VzLmNvbmNhdCh0aGlzLmdyYXBoTWFuYWdlci5nZXRBbGxFZGdlcygpKTtcbiAgZWRnZXMgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuZWRnZVRvRHVtbXlOb2Rlcy5rZXlzKCkpKS5jb25jYXQoZWRnZXMpO1xuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgZWRnZXMubGVuZ3RoOyBrKyspIHtcbiAgICB2YXIgbEVkZ2UgPSBlZGdlc1trXTtcblxuICAgIGlmIChsRWRnZS5iZW5kcG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBwYXRoID0gdGhpcy5lZGdlVG9EdW1teU5vZGVzLmdldChsRWRnZSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZHVtbXlOb2RlID0gcGF0aFtpXTtcbiAgICAgICAgdmFyIHAgPSBuZXcgUG9pbnREKGR1bW15Tm9kZS5nZXRDZW50ZXJYKCksIGR1bW15Tm9kZS5nZXRDZW50ZXJZKCkpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBiZW5kcG9pbnQncyBsb2NhdGlvbiBhY2NvcmRpbmcgdG8gZHVtbXkgbm9kZVxuICAgICAgICB2YXIgZWJwID0gbEVkZ2UuYmVuZHBvaW50cy5nZXQoaSk7XG4gICAgICAgIGVicC54ID0gcC54O1xuICAgICAgICBlYnAueSA9IHAueTtcblxuICAgICAgICAvLyByZW1vdmUgdGhlIGR1bW15IG5vZGUsIGR1bW15IGVkZ2VzIGluY2lkZW50IHdpdGggdGhpc1xuICAgICAgICAvLyBkdW1teSBub2RlIGlzIGFsc28gcmVtb3ZlZCAod2l0aGluIHRoZSByZW1vdmUgbWV0aG9kKVxuICAgICAgICBkdW1teU5vZGUuZ2V0T3duZXIoKS5yZW1vdmUoZHVtbXlOb2RlKTtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIHRoZSByZWFsIGVkZ2UgdG8gZ3JhcGhcbiAgICAgIHRoaXMuZ3JhcGhNYW5hZ2VyLmFkZChsRWRnZSwgbEVkZ2Uuc291cmNlLCBsRWRnZS50YXJnZXQpO1xuICAgIH1cbiAgfVxufTtcblxuTGF5b3V0LnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChzbGlkZXJWYWx1ZSwgZGVmYXVsdFZhbHVlLCBtaW5EaXYsIG1heE11bCkge1xuICBpZiAobWluRGl2ICE9IHVuZGVmaW5lZCAmJiBtYXhNdWwgIT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuXG4gICAgaWYgKHNsaWRlclZhbHVlIDw9IDUwKSB7XG4gICAgICB2YXIgbWluVmFsdWUgPSBkZWZhdWx0VmFsdWUgLyBtaW5EaXY7XG4gICAgICB2YWx1ZSAtPSAoZGVmYXVsdFZhbHVlIC0gbWluVmFsdWUpIC8gNTAgKiAoNTAgLSBzbGlkZXJWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtYXhWYWx1ZSA9IGRlZmF1bHRWYWx1ZSAqIG1heE11bDtcbiAgICAgIHZhbHVlICs9IChtYXhWYWx1ZSAtIGRlZmF1bHRWYWx1ZSkgLyA1MCAqIChzbGlkZXJWYWx1ZSAtIDUwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGEsIGI7XG5cbiAgICBpZiAoc2xpZGVyVmFsdWUgPD0gNTApIHtcbiAgICAgIGEgPSA5LjAgKiBkZWZhdWx0VmFsdWUgLyA1MDAuMDtcbiAgICAgIGIgPSBkZWZhdWx0VmFsdWUgLyAxMC4wO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gOS4wICogZGVmYXVsdFZhbHVlIC8gNTAuMDtcbiAgICAgIGIgPSAtOCAqIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYSAqIHNsaWRlclZhbHVlICsgYjtcbiAgfVxufTtcblxuLyoqXHJcbiAqIFRoaXMgbWV0aG9kIGZpbmRzIGFuZCByZXR1cm5zIHRoZSBjZW50ZXIgb2YgdGhlIGdpdmVuIG5vZGVzLCBhc3N1bWluZ1xyXG4gKiB0aGF0IHRoZSBnaXZlbiBub2RlcyBmb3JtIGEgdHJlZSBpbiB0aGVtc2VsdmVzLlxyXG4gKi9cbkxheW91dC5maW5kQ2VudGVyT2ZUcmVlID0gZnVuY3Rpb24gKG5vZGVzKSB7XG4gIHZhciBsaXN0ID0gW107XG4gIGxpc3QgPSBsaXN0LmNvbmNhdChub2Rlcyk7XG5cbiAgdmFyIHJlbW92ZWROb2RlcyA9IFtdO1xuICB2YXIgcmVtYWluaW5nRGVncmVlcyA9IG5ldyBNYXAoKTtcbiAgdmFyIGZvdW5kQ2VudGVyID0gZmFsc2U7XG4gIHZhciBjZW50ZXJOb2RlID0gbnVsbDtcblxuICBpZiAobGlzdC5sZW5ndGggPT0gMSB8fCBsaXN0Lmxlbmd0aCA9PSAyKSB7XG4gICAgZm91bmRDZW50ZXIgPSB0cnVlO1xuICAgIGNlbnRlck5vZGUgPSBsaXN0WzBdO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5vZGUgPSBsaXN0W2ldO1xuICAgIHZhciBkZWdyZWUgPSBub2RlLmdldE5laWdoYm9yc0xpc3QoKS5zaXplO1xuICAgIHJlbWFpbmluZ0RlZ3JlZXMuc2V0KG5vZGUsIG5vZGUuZ2V0TmVpZ2hib3JzTGlzdCgpLnNpemUpO1xuXG4gICAgaWYgKGRlZ3JlZSA9PSAxKSB7XG4gICAgICByZW1vdmVkTm9kZXMucHVzaChub2RlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgdGVtcExpc3QgPSBbXTtcbiAgdGVtcExpc3QgPSB0ZW1wTGlzdC5jb25jYXQocmVtb3ZlZE5vZGVzKTtcblxuICB3aGlsZSAoIWZvdW5kQ2VudGVyKSB7XG4gICAgdmFyIHRlbXBMaXN0MiA9IFtdO1xuICAgIHRlbXBMaXN0MiA9IHRlbXBMaXN0Mi5jb25jYXQodGVtcExpc3QpO1xuICAgIHRlbXBMaXN0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBub2RlID0gbGlzdFtpXTtcblxuICAgICAgdmFyIGluZGV4ID0gbGlzdC5pbmRleE9mKG5vZGUpO1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmVpZ2hib3VycyA9IG5vZGUuZ2V0TmVpZ2hib3JzTGlzdCgpO1xuXG4gICAgICBuZWlnaGJvdXJzLmZvckVhY2goZnVuY3Rpb24gKG5laWdoYm91cikge1xuICAgICAgICBpZiAocmVtb3ZlZE5vZGVzLmluZGV4T2YobmVpZ2hib3VyKSA8IDApIHtcbiAgICAgICAgICB2YXIgb3RoZXJEZWdyZWUgPSByZW1haW5pbmdEZWdyZWVzLmdldChuZWlnaGJvdXIpO1xuICAgICAgICAgIHZhciBuZXdEZWdyZWUgPSBvdGhlckRlZ3JlZSAtIDE7XG5cbiAgICAgICAgICBpZiAobmV3RGVncmVlID09IDEpIHtcbiAgICAgICAgICAgIHRlbXBMaXN0LnB1c2gobmVpZ2hib3VyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZW1haW5pbmdEZWdyZWVzLnNldChuZWlnaGJvdXIsIG5ld0RlZ3JlZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJlbW92ZWROb2RlcyA9IHJlbW92ZWROb2Rlcy5jb25jYXQodGVtcExpc3QpO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09IDEgfHwgbGlzdC5sZW5ndGggPT0gMikge1xuICAgICAgZm91bmRDZW50ZXIgPSB0cnVlO1xuICAgICAgY2VudGVyTm9kZSA9IGxpc3RbMF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNlbnRlck5vZGU7XG59O1xuXG4vKipcclxuICogRHVyaW5nIHRoZSBjb2Fyc2VuaW5nIHByb2Nlc3MsIHRoaXMgbGF5b3V0IG1heSBiZSByZWZlcmVuY2VkIGJ5IHR3byBncmFwaCBtYW5hZ2Vyc1xyXG4gKiB0aGlzIHNldHRlciBmdW5jdGlvbiBncmFudHMgYWNjZXNzIHRvIGNoYW5nZSB0aGUgY3VycmVudGx5IGJlaW5nIHVzZWQgZ3JhcGggbWFuYWdlclxyXG4gKi9cbkxheW91dC5wcm90b3R5cGUuc2V0R3JhcGhNYW5hZ2VyID0gZnVuY3Rpb24gKGdtKSB7XG4gIHRoaXMuZ3JhcGhNYW5hZ2VyID0gZ207XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExheW91dDtcblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBSYW5kb21TZWVkKCkge31cbi8vIGFkYXB0ZWQgZnJvbTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE5MzAzNzI1XG5SYW5kb21TZWVkLnNlZWQgPSAxO1xuUmFuZG9tU2VlZC54ID0gMDtcblxuUmFuZG9tU2VlZC5uZXh0RG91YmxlID0gZnVuY3Rpb24gKCkge1xuICBSYW5kb21TZWVkLnggPSBNYXRoLnNpbihSYW5kb21TZWVkLnNlZWQrKykgKiAxMDAwMDtcbiAgcmV0dXJuIFJhbmRvbVNlZWQueCAtIE1hdGguZmxvb3IoUmFuZG9tU2VlZC54KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tU2VlZDtcblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgUG9pbnREID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxuZnVuY3Rpb24gVHJhbnNmb3JtKHgsIHkpIHtcbiAgdGhpcy5sd29ybGRPcmdYID0gMC4wO1xuICB0aGlzLmx3b3JsZE9yZ1kgPSAwLjA7XG4gIHRoaXMubGRldmljZU9yZ1ggPSAwLjA7XG4gIHRoaXMubGRldmljZU9yZ1kgPSAwLjA7XG4gIHRoaXMubHdvcmxkRXh0WCA9IDEuMDtcbiAgdGhpcy5sd29ybGRFeHRZID0gMS4wO1xuICB0aGlzLmxkZXZpY2VFeHRYID0gMS4wO1xuICB0aGlzLmxkZXZpY2VFeHRZID0gMS4wO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldFdvcmxkT3JnWCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubHdvcmxkT3JnWDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0V29ybGRPcmdYID0gZnVuY3Rpb24gKHdveCkge1xuICB0aGlzLmx3b3JsZE9yZ1ggPSB3b3g7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldFdvcmxkT3JnWSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubHdvcmxkT3JnWTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0V29ybGRPcmdZID0gZnVuY3Rpb24gKHdveSkge1xuICB0aGlzLmx3b3JsZE9yZ1kgPSB3b3k7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldFdvcmxkRXh0WCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubHdvcmxkRXh0WDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0V29ybGRFeHRYID0gZnVuY3Rpb24gKHdleCkge1xuICB0aGlzLmx3b3JsZEV4dFggPSB3ZXg7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldFdvcmxkRXh0WSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubHdvcmxkRXh0WTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0V29ybGRFeHRZID0gZnVuY3Rpb24gKHdleSkge1xuICB0aGlzLmx3b3JsZEV4dFkgPSB3ZXk7XG59O1xuXG4vKiBEZXZpY2UgcmVsYXRlZCAqL1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldERldmljZU9yZ1ggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxkZXZpY2VPcmdYO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXREZXZpY2VPcmdYID0gZnVuY3Rpb24gKGRveCkge1xuICB0aGlzLmxkZXZpY2VPcmdYID0gZG94O1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5nZXREZXZpY2VPcmdZID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sZGV2aWNlT3JnWTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0RGV2aWNlT3JnWSA9IGZ1bmN0aW9uIChkb3kpIHtcbiAgdGhpcy5sZGV2aWNlT3JnWSA9IGRveTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0RGV2aWNlRXh0WCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubGRldmljZUV4dFg7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldERldmljZUV4dFggPSBmdW5jdGlvbiAoZGV4KSB7XG4gIHRoaXMubGRldmljZUV4dFggPSBkZXg7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldERldmljZUV4dFkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxkZXZpY2VFeHRZO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXREZXZpY2VFeHRZID0gZnVuY3Rpb24gKGRleSkge1xuICB0aGlzLmxkZXZpY2VFeHRZID0gZGV5O1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS50cmFuc2Zvcm1YID0gZnVuY3Rpb24gKHgpIHtcbiAgdmFyIHhEZXZpY2UgPSAwLjA7XG4gIHZhciB3b3JsZEV4dFggPSB0aGlzLmx3b3JsZEV4dFg7XG4gIGlmICh3b3JsZEV4dFggIT0gMC4wKSB7XG4gICAgeERldmljZSA9IHRoaXMubGRldmljZU9yZ1ggKyAoeCAtIHRoaXMubHdvcmxkT3JnWCkgKiB0aGlzLmxkZXZpY2VFeHRYIC8gd29ybGRFeHRYO1xuICB9XG5cbiAgcmV0dXJuIHhEZXZpY2U7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnRyYW5zZm9ybVkgPSBmdW5jdGlvbiAoeSkge1xuICB2YXIgeURldmljZSA9IDAuMDtcbiAgdmFyIHdvcmxkRXh0WSA9IHRoaXMubHdvcmxkRXh0WTtcbiAgaWYgKHdvcmxkRXh0WSAhPSAwLjApIHtcbiAgICB5RGV2aWNlID0gdGhpcy5sZGV2aWNlT3JnWSArICh5IC0gdGhpcy5sd29ybGRPcmdZKSAqIHRoaXMubGRldmljZUV4dFkgLyB3b3JsZEV4dFk7XG4gIH1cblxuICByZXR1cm4geURldmljZTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuaW52ZXJzZVRyYW5zZm9ybVggPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgeFdvcmxkID0gMC4wO1xuICB2YXIgZGV2aWNlRXh0WCA9IHRoaXMubGRldmljZUV4dFg7XG4gIGlmIChkZXZpY2VFeHRYICE9IDAuMCkge1xuICAgIHhXb3JsZCA9IHRoaXMubHdvcmxkT3JnWCArICh4IC0gdGhpcy5sZGV2aWNlT3JnWCkgKiB0aGlzLmx3b3JsZEV4dFggLyBkZXZpY2VFeHRYO1xuICB9XG5cbiAgcmV0dXJuIHhXb3JsZDtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuaW52ZXJzZVRyYW5zZm9ybVkgPSBmdW5jdGlvbiAoeSkge1xuICB2YXIgeVdvcmxkID0gMC4wO1xuICB2YXIgZGV2aWNlRXh0WSA9IHRoaXMubGRldmljZUV4dFk7XG4gIGlmIChkZXZpY2VFeHRZICE9IDAuMCkge1xuICAgIHlXb3JsZCA9IHRoaXMubHdvcmxkT3JnWSArICh5IC0gdGhpcy5sZGV2aWNlT3JnWSkgKiB0aGlzLmx3b3JsZEV4dFkgLyBkZXZpY2VFeHRZO1xuICB9XG4gIHJldHVybiB5V29ybGQ7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmludmVyc2VUcmFuc2Zvcm1Qb2ludCA9IGZ1bmN0aW9uIChpblBvaW50KSB7XG4gIHZhciBvdXRQb2ludCA9IG5ldyBQb2ludEQodGhpcy5pbnZlcnNlVHJhbnNmb3JtWChpblBvaW50LngpLCB0aGlzLmludmVyc2VUcmFuc2Zvcm1ZKGluUG9pbnQueSkpO1xuICByZXR1cm4gb3V0UG9pbnQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxuLyoqKi8gfSksXG4vKiAxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IGVsc2UgeyByZXR1cm4gQXJyYXkuZnJvbShhcnIpOyB9IH1cblxudmFyIExheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xudmFyIEZETGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbnZhciBMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIElHZW9tZXRyeSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG52YXIgSU1hdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG5mdW5jdGlvbiBGRExheW91dCgpIHtcbiAgTGF5b3V0LmNhbGwodGhpcyk7XG5cbiAgdGhpcy51c2VTbWFydElkZWFsRWRnZUxlbmd0aENhbGN1bGF0aW9uID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9VU0VfU01BUlRfSURFQUxfRURHRV9MRU5HVEhfQ0FMQ1VMQVRJT047XG4gIHRoaXMuZ3Jhdml0eUNvbnN0YW50ID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9HUkFWSVRZX1NUUkVOR1RIO1xuICB0aGlzLmNvbXBvdW5kR3Jhdml0eUNvbnN0YW50ID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT01QT1VORF9HUkFWSVRZX1NUUkVOR1RIO1xuICB0aGlzLmdyYXZpdHlSYW5nZUZhY3RvciA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfR1JBVklUWV9SQU5HRV9GQUNUT1I7XG4gIHRoaXMuY29tcG91bmRHcmF2aXR5UmFuZ2VGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPTVBPVU5EX0dSQVZJVFlfUkFOR0VfRkFDVE9SO1xuICB0aGlzLmRpc3BsYWNlbWVudFRocmVzaG9sZFBlck5vZGUgPSAzLjAgKiBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIIC8gMTAwO1xuICB0aGlzLmNvb2xpbmdGYWN0b3IgPSBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0NPT0xJTkdfRkFDVE9SX0lOQ1JFTUVOVEFMO1xuICB0aGlzLmluaXRpYWxDb29saW5nRmFjdG9yID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9DT09MSU5HX0ZBQ1RPUl9JTkNSRU1FTlRBTDtcbiAgdGhpcy50b3RhbERpc3BsYWNlbWVudCA9IDAuMDtcbiAgdGhpcy5vbGRUb3RhbERpc3BsYWNlbWVudCA9IDAuMDtcbiAgdGhpcy5tYXhJdGVyYXRpb25zID0gRkRMYXlvdXRDb25zdGFudHMuTUFYX0lURVJBVElPTlM7XG59XG5cbkZETGF5b3V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTGF5b3V0LnByb3RvdHlwZSk7XG5cbmZvciAodmFyIHByb3AgaW4gTGF5b3V0KSB7XG4gIEZETGF5b3V0W3Byb3BdID0gTGF5b3V0W3Byb3BdO1xufVxuXG5GRExheW91dC5wcm90b3R5cGUuaW5pdFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gIExheW91dC5wcm90b3R5cGUuaW5pdFBhcmFtZXRlcnMuY2FsbCh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIHRoaXMudG90YWxJdGVyYXRpb25zID0gMDtcbiAgdGhpcy5ub3RBbmltYXRlZEl0ZXJhdGlvbnMgPSAwO1xuXG4gIHRoaXMudXNlRlJHcmlkVmFyaWFudCA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfVVNFX1NNQVJUX1JFUFVMU0lPTl9SQU5HRV9DQUxDVUxBVElPTjtcblxuICB0aGlzLmdyaWQgPSBbXTtcbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjSWRlYWxFZGdlTGVuZ3RocyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGVkZ2U7XG4gIHZhciBvcmlnaW5hbElkZWFsTGVuZ3RoO1xuICB2YXIgbGNhRGVwdGg7XG4gIHZhciBzb3VyY2U7XG4gIHZhciB0YXJnZXQ7XG4gIHZhciBzaXplT2ZTb3VyY2VJbkxjYTtcbiAgdmFyIHNpemVPZlRhcmdldEluTGNhO1xuXG4gIHZhciBhbGxFZGdlcyA9IHRoaXMuZ2V0R3JhcGhNYW5hZ2VyKCkuZ2V0QWxsRWRnZXMoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxFZGdlcy5sZW5ndGg7IGkrKykge1xuICAgIGVkZ2UgPSBhbGxFZGdlc1tpXTtcblxuICAgIG9yaWdpbmFsSWRlYWxMZW5ndGggPSBlZGdlLmlkZWFsTGVuZ3RoO1xuXG4gICAgaWYgKGVkZ2UuaXNJbnRlckdyYXBoKSB7XG4gICAgICBzb3VyY2UgPSBlZGdlLmdldFNvdXJjZSgpO1xuICAgICAgdGFyZ2V0ID0gZWRnZS5nZXRUYXJnZXQoKTtcblxuICAgICAgc2l6ZU9mU291cmNlSW5MY2EgPSBlZGdlLmdldFNvdXJjZUluTGNhKCkuZ2V0RXN0aW1hdGVkU2l6ZSgpO1xuICAgICAgc2l6ZU9mVGFyZ2V0SW5MY2EgPSBlZGdlLmdldFRhcmdldEluTGNhKCkuZ2V0RXN0aW1hdGVkU2l6ZSgpO1xuXG4gICAgICBpZiAodGhpcy51c2VTbWFydElkZWFsRWRnZUxlbmd0aENhbGN1bGF0aW9uKSB7XG4gICAgICAgIGVkZ2UuaWRlYWxMZW5ndGggKz0gc2l6ZU9mU291cmNlSW5MY2EgKyBzaXplT2ZUYXJnZXRJbkxjYSAtIDIgKiBMYXlvdXRDb25zdGFudHMuU0lNUExFX05PREVfU0laRTtcbiAgICAgIH1cblxuICAgICAgbGNhRGVwdGggPSBlZGdlLmdldExjYSgpLmdldEluY2x1c2lvblRyZWVEZXB0aCgpO1xuXG4gICAgICBlZGdlLmlkZWFsTGVuZ3RoICs9IG9yaWdpbmFsSWRlYWxMZW5ndGggKiBGRExheW91dENvbnN0YW50cy5QRVJfTEVWRUxfSURFQUxfRURHRV9MRU5HVEhfRkFDVE9SICogKHNvdXJjZS5nZXRJbmNsdXNpb25UcmVlRGVwdGgoKSArIHRhcmdldC5nZXRJbmNsdXNpb25UcmVlRGVwdGgoKSAtIDIgKiBsY2FEZXB0aCk7XG4gICAgfVxuICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuaW5pdFNwcmluZ0VtYmVkZGVyID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBzID0gdGhpcy5nZXRBbGxOb2RlcygpLmxlbmd0aDtcbiAgaWYgKHRoaXMuaW5jcmVtZW50YWwpIHtcbiAgICBpZiAocyA+IEZETGF5b3V0Q29uc3RhbnRzLkFEQVBUQVRJT05fTE9XRVJfTk9ERV9MSU1JVCkge1xuICAgICAgdGhpcy5jb29saW5nRmFjdG9yID0gTWF0aC5tYXgodGhpcy5jb29saW5nRmFjdG9yICogRkRMYXlvdXRDb25zdGFudHMuQ09PTElOR19BREFQVEFUSU9OX0ZBQ1RPUiwgdGhpcy5jb29saW5nRmFjdG9yIC0gKHMgLSBGRExheW91dENvbnN0YW50cy5BREFQVEFUSU9OX0xPV0VSX05PREVfTElNSVQpIC8gKEZETGF5b3V0Q29uc3RhbnRzLkFEQVBUQVRJT05fVVBQRVJfTk9ERV9MSU1JVCAtIEZETGF5b3V0Q29uc3RhbnRzLkFEQVBUQVRJT05fTE9XRVJfTk9ERV9MSU1JVCkgKiB0aGlzLmNvb2xpbmdGYWN0b3IgKiAoMSAtIEZETGF5b3V0Q29uc3RhbnRzLkNPT0xJTkdfQURBUFRBVElPTl9GQUNUT1IpKTtcbiAgICB9XG4gICAgdGhpcy5tYXhOb2RlRGlzcGxhY2VtZW50ID0gRkRMYXlvdXRDb25zdGFudHMuTUFYX05PREVfRElTUExBQ0VNRU5UX0lOQ1JFTUVOVEFMO1xuICB9IGVsc2Uge1xuICAgIGlmIChzID4gRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9MT1dFUl9OT0RFX0xJTUlUKSB7XG4gICAgICB0aGlzLmNvb2xpbmdGYWN0b3IgPSBNYXRoLm1heChGRExheW91dENvbnN0YW50cy5DT09MSU5HX0FEQVBUQVRJT05fRkFDVE9SLCAxLjAgLSAocyAtIEZETGF5b3V0Q29uc3RhbnRzLkFEQVBUQVRJT05fTE9XRVJfTk9ERV9MSU1JVCkgLyAoRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9VUFBFUl9OT0RFX0xJTUlUIC0gRkRMYXlvdXRDb25zdGFudHMuQURBUFRBVElPTl9MT1dFUl9OT0RFX0xJTUlUKSAqICgxIC0gRkRMYXlvdXRDb25zdGFudHMuQ09PTElOR19BREFQVEFUSU9OX0ZBQ1RPUikpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvb2xpbmdGYWN0b3IgPSAxLjA7XG4gICAgfVxuICAgIHRoaXMuaW5pdGlhbENvb2xpbmdGYWN0b3IgPSB0aGlzLmNvb2xpbmdGYWN0b3I7XG4gICAgdGhpcy5tYXhOb2RlRGlzcGxhY2VtZW50ID0gRkRMYXlvdXRDb25zdGFudHMuTUFYX05PREVfRElTUExBQ0VNRU5UO1xuICB9XG5cbiAgdGhpcy5tYXhJdGVyYXRpb25zID0gTWF0aC5tYXgodGhpcy5nZXRBbGxOb2RlcygpLmxlbmd0aCAqIDUsIHRoaXMubWF4SXRlcmF0aW9ucyk7XG5cbiAgLy8gUmVhc3NpZ24gdGhpcyBhdHRyaWJ1dGUgYnkgdXNpbmcgbmV3IGNvbnN0YW50IHZhbHVlXG4gIHRoaXMuZGlzcGxhY2VtZW50VGhyZXNob2xkUGVyTm9kZSA9IDMuMCAqIEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfRURHRV9MRU5HVEggLyAxMDA7XG4gIHRoaXMudG90YWxEaXNwbGFjZW1lbnRUaHJlc2hvbGQgPSB0aGlzLmRpc3BsYWNlbWVudFRocmVzaG9sZFBlck5vZGUgKiB0aGlzLmdldEFsbE5vZGVzKCkubGVuZ3RoO1xuXG4gIHRoaXMucmVwdWxzaW9uUmFuZ2UgPSB0aGlzLmNhbGNSZXB1bHNpb25SYW5nZSgpO1xufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGNTcHJpbmdGb3JjZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsRWRnZXMgPSB0aGlzLmdldEFsbEVkZ2VzKCk7XG4gIHZhciBlZGdlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbEVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgZWRnZSA9IGxFZGdlc1tpXTtcblxuICAgIHRoaXMuY2FsY1NwcmluZ0ZvcmNlKGVkZ2UsIGVkZ2UuaWRlYWxMZW5ndGgpO1xuICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuY2FsY1JlcHVsc2lvbkZvcmNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGdyaWRVcGRhdGVBbGxvd2VkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICB2YXIgZm9yY2VUb05vZGVTdXJyb3VuZGluZ1VwZGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgdmFyIGksIGo7XG4gIHZhciBub2RlQSwgbm9kZUI7XG4gIHZhciBsTm9kZXMgPSB0aGlzLmdldEFsbE5vZGVzKCk7XG4gIHZhciBwcm9jZXNzZWROb2RlU2V0O1xuXG4gIGlmICh0aGlzLnVzZUZSR3JpZFZhcmlhbnQpIHtcbiAgICBpZiAodGhpcy50b3RhbEl0ZXJhdGlvbnMgJSBGRExheW91dENvbnN0YW50cy5HUklEX0NBTENVTEFUSU9OX0NIRUNLX1BFUklPRCA9PSAxICYmIGdyaWRVcGRhdGVBbGxvd2VkKSB7XG4gICAgICB0aGlzLnVwZGF0ZUdyaWQoKTtcbiAgICB9XG5cbiAgICBwcm9jZXNzZWROb2RlU2V0ID0gbmV3IFNldCgpO1xuXG4gICAgLy8gY2FsY3VsYXRlIHJlcHVsc2lvbiBmb3JjZXMgYmV0d2VlbiBlYWNoIG5vZGVzIGFuZCBpdHMgc3Vycm91bmRpbmdcbiAgICBmb3IgKGkgPSAwOyBpIDwgbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBub2RlQSA9IGxOb2Rlc1tpXTtcbiAgICAgIHRoaXMuY2FsY3VsYXRlUmVwdWxzaW9uRm9yY2VPZkFOb2RlKG5vZGVBLCBwcm9jZXNzZWROb2RlU2V0LCBncmlkVXBkYXRlQWxsb3dlZCwgZm9yY2VUb05vZGVTdXJyb3VuZGluZ1VwZGF0ZSk7XG4gICAgICBwcm9jZXNzZWROb2RlU2V0LmFkZChub2RlQSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoaSA9IDA7IGkgPCBsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG5vZGVBID0gbE5vZGVzW2ldO1xuXG4gICAgICBmb3IgKGogPSBpICsgMTsgaiA8IGxOb2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBub2RlQiA9IGxOb2Rlc1tqXTtcblxuICAgICAgICAvLyBJZiBib3RoIG5vZGVzIGFyZSBub3QgbWVtYmVycyBvZiB0aGUgc2FtZSBncmFwaCwgc2tpcC5cbiAgICAgICAgaWYgKG5vZGVBLmdldE93bmVyKCkgIT0gbm9kZUIuZ2V0T3duZXIoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxjUmVwdWxzaW9uRm9yY2Uobm9kZUEsIG5vZGVCKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjR3Jhdml0YXRpb25hbEZvcmNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGU7XG4gIHZhciBsTm9kZXMgPSB0aGlzLmdldEFsbE5vZGVzVG9BcHBseUdyYXZpdGF0aW9uKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlID0gbE5vZGVzW2ldO1xuICAgIHRoaXMuY2FsY0dyYXZpdGF0aW9uYWxGb3JjZShub2RlKTtcbiAgfVxufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLm1vdmVOb2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxOb2RlcyA9IHRoaXMuZ2V0QWxsTm9kZXMoKTtcbiAgdmFyIG5vZGU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBub2RlID0gbE5vZGVzW2ldO1xuICAgIG5vZGUubW92ZSgpO1xuICB9XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuY2FsY1NwcmluZ0ZvcmNlID0gZnVuY3Rpb24gKGVkZ2UsIGlkZWFsTGVuZ3RoKSB7XG4gIHZhciBzb3VyY2VOb2RlID0gZWRnZS5nZXRTb3VyY2UoKTtcbiAgdmFyIHRhcmdldE5vZGUgPSBlZGdlLmdldFRhcmdldCgpO1xuXG4gIHZhciBsZW5ndGg7XG4gIHZhciBzcHJpbmdGb3JjZTtcbiAgdmFyIHNwcmluZ0ZvcmNlWDtcbiAgdmFyIHNwcmluZ0ZvcmNlWTtcblxuICAvLyBVcGRhdGUgZWRnZSBsZW5ndGhcbiAgaWYgKHRoaXMudW5pZm9ybUxlYWZOb2RlU2l6ZXMgJiYgc291cmNlTm9kZS5nZXRDaGlsZCgpID09IG51bGwgJiYgdGFyZ2V0Tm9kZS5nZXRDaGlsZCgpID09IG51bGwpIHtcbiAgICBlZGdlLnVwZGF0ZUxlbmd0aFNpbXBsZSgpO1xuICB9IGVsc2Uge1xuICAgIGVkZ2UudXBkYXRlTGVuZ3RoKCk7XG5cbiAgICBpZiAoZWRnZS5pc092ZXJsYXBpbmdTb3VyY2VBbmRUYXJnZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBsZW5ndGggPSBlZGdlLmdldExlbmd0aCgpO1xuXG4gIGlmIChsZW5ndGggPT0gMCkgcmV0dXJuO1xuXG4gIC8vIENhbGN1bGF0ZSBzcHJpbmcgZm9yY2VzXG4gIHNwcmluZ0ZvcmNlID0gZWRnZS5lZGdlRWxhc3RpY2l0eSAqIChsZW5ndGggLSBpZGVhbExlbmd0aCk7XG5cbiAgLy8gUHJvamVjdCBmb3JjZSBvbnRvIHggYW5kIHkgYXhlc1xuICBzcHJpbmdGb3JjZVggPSBzcHJpbmdGb3JjZSAqIChlZGdlLmxlbmd0aFggLyBsZW5ndGgpO1xuICBzcHJpbmdGb3JjZVkgPSBzcHJpbmdGb3JjZSAqIChlZGdlLmxlbmd0aFkgLyBsZW5ndGgpO1xuXG4gIC8vIEFwcGx5IGZvcmNlcyBvbiB0aGUgZW5kIG5vZGVzXG4gIHNvdXJjZU5vZGUuc3ByaW5nRm9yY2VYICs9IHNwcmluZ0ZvcmNlWDtcbiAgc291cmNlTm9kZS5zcHJpbmdGb3JjZVkgKz0gc3ByaW5nRm9yY2VZO1xuICB0YXJnZXROb2RlLnNwcmluZ0ZvcmNlWCAtPSBzcHJpbmdGb3JjZVg7XG4gIHRhcmdldE5vZGUuc3ByaW5nRm9yY2VZIC09IHNwcmluZ0ZvcmNlWTtcbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjUmVwdWxzaW9uRm9yY2UgPSBmdW5jdGlvbiAobm9kZUEsIG5vZGVCKSB7XG4gIHZhciByZWN0QSA9IG5vZGVBLmdldFJlY3QoKTtcbiAgdmFyIHJlY3RCID0gbm9kZUIuZ2V0UmVjdCgpO1xuICB2YXIgb3ZlcmxhcEFtb3VudCA9IG5ldyBBcnJheSgyKTtcbiAgdmFyIGNsaXBQb2ludHMgPSBuZXcgQXJyYXkoNCk7XG4gIHZhciBkaXN0YW5jZVg7XG4gIHZhciBkaXN0YW5jZVk7XG4gIHZhciBkaXN0YW5jZVNxdWFyZWQ7XG4gIHZhciBkaXN0YW5jZTtcbiAgdmFyIHJlcHVsc2lvbkZvcmNlO1xuICB2YXIgcmVwdWxzaW9uRm9yY2VYO1xuICB2YXIgcmVwdWxzaW9uRm9yY2VZO1xuXG4gIGlmIChyZWN0QS5pbnRlcnNlY3RzKHJlY3RCKSkgLy8gdHdvIG5vZGVzIG92ZXJsYXBcbiAgICB7XG4gICAgICAvLyBjYWxjdWxhdGUgc2VwYXJhdGlvbiBhbW91bnQgaW4geCBhbmQgeSBkaXJlY3Rpb25zXG4gICAgICBJR2VvbWV0cnkuY2FsY1NlcGFyYXRpb25BbW91bnQocmVjdEEsIHJlY3RCLCBvdmVybGFwQW1vdW50LCBGRExheW91dENvbnN0YW50cy5ERUZBVUxUX0VER0VfTEVOR1RIIC8gMi4wKTtcblxuICAgICAgcmVwdWxzaW9uRm9yY2VYID0gMiAqIG92ZXJsYXBBbW91bnRbMF07XG4gICAgICByZXB1bHNpb25Gb3JjZVkgPSAyICogb3ZlcmxhcEFtb3VudFsxXTtcblxuICAgICAgdmFyIGNoaWxkcmVuQ29uc3RhbnQgPSBub2RlQS5ub09mQ2hpbGRyZW4gKiBub2RlQi5ub09mQ2hpbGRyZW4gLyAobm9kZUEubm9PZkNoaWxkcmVuICsgbm9kZUIubm9PZkNoaWxkcmVuKTtcblxuICAgICAgLy8gQXBwbHkgZm9yY2VzIG9uIHRoZSB0d28gbm9kZXNcbiAgICAgIG5vZGVBLnJlcHVsc2lvbkZvcmNlWCAtPSBjaGlsZHJlbkNvbnN0YW50ICogcmVwdWxzaW9uRm9yY2VYO1xuICAgICAgbm9kZUEucmVwdWxzaW9uRm9yY2VZIC09IGNoaWxkcmVuQ29uc3RhbnQgKiByZXB1bHNpb25Gb3JjZVk7XG4gICAgICBub2RlQi5yZXB1bHNpb25Gb3JjZVggKz0gY2hpbGRyZW5Db25zdGFudCAqIHJlcHVsc2lvbkZvcmNlWDtcbiAgICAgIG5vZGVCLnJlcHVsc2lvbkZvcmNlWSArPSBjaGlsZHJlbkNvbnN0YW50ICogcmVwdWxzaW9uRm9yY2VZO1xuICAgIH0gZWxzZSAvLyBubyBvdmVybGFwXG4gICAge1xuICAgICAgLy8gY2FsY3VsYXRlIGRpc3RhbmNlXG5cbiAgICAgIGlmICh0aGlzLnVuaWZvcm1MZWFmTm9kZVNpemVzICYmIG5vZGVBLmdldENoaWxkKCkgPT0gbnVsbCAmJiBub2RlQi5nZXRDaGlsZCgpID09IG51bGwpIC8vIHNpbXBseSBiYXNlIHJlcHVsc2lvbiBvbiBkaXN0YW5jZSBvZiBub2RlIGNlbnRlcnNcbiAgICAgICAge1xuICAgICAgICAgIGRpc3RhbmNlWCA9IHJlY3RCLmdldENlbnRlclgoKSAtIHJlY3RBLmdldENlbnRlclgoKTtcbiAgICAgICAgICBkaXN0YW5jZVkgPSByZWN0Qi5nZXRDZW50ZXJZKCkgLSByZWN0QS5nZXRDZW50ZXJZKCk7XG4gICAgICAgIH0gZWxzZSAvLyB1c2UgY2xpcHBpbmcgcG9pbnRzXG4gICAgICAgIHtcbiAgICAgICAgICBJR2VvbWV0cnkuZ2V0SW50ZXJzZWN0aW9uKHJlY3RBLCByZWN0QiwgY2xpcFBvaW50cyk7XG5cbiAgICAgICAgICBkaXN0YW5jZVggPSBjbGlwUG9pbnRzWzJdIC0gY2xpcFBvaW50c1swXTtcbiAgICAgICAgICBkaXN0YW5jZVkgPSBjbGlwUG9pbnRzWzNdIC0gY2xpcFBvaW50c1sxXTtcbiAgICAgICAgfVxuXG4gICAgICAvLyBObyByZXB1bHNpb24gcmFuZ2UuIEZSIGdyaWQgdmFyaWFudCBzaG91bGQgdGFrZSBjYXJlIG9mIHRoaXMuXG4gICAgICBpZiAoTWF0aC5hYnMoZGlzdGFuY2VYKSA8IEZETGF5b3V0Q29uc3RhbnRzLk1JTl9SRVBVTFNJT05fRElTVCkge1xuICAgICAgICBkaXN0YW5jZVggPSBJTWF0aC5zaWduKGRpc3RhbmNlWCkgKiBGRExheW91dENvbnN0YW50cy5NSU5fUkVQVUxTSU9OX0RJU1Q7XG4gICAgICB9XG5cbiAgICAgIGlmIChNYXRoLmFicyhkaXN0YW5jZVkpIDwgRkRMYXlvdXRDb25zdGFudHMuTUlOX1JFUFVMU0lPTl9ESVNUKSB7XG4gICAgICAgIGRpc3RhbmNlWSA9IElNYXRoLnNpZ24oZGlzdGFuY2VZKSAqIEZETGF5b3V0Q29uc3RhbnRzLk1JTl9SRVBVTFNJT05fRElTVDtcbiAgICAgIH1cblxuICAgICAgZGlzdGFuY2VTcXVhcmVkID0gZGlzdGFuY2VYICogZGlzdGFuY2VYICsgZGlzdGFuY2VZICogZGlzdGFuY2VZO1xuICAgICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZGlzdGFuY2VTcXVhcmVkKTtcblxuICAgICAgLy8gSGVyZSB3ZSB1c2UgaGFsZiBvZiB0aGUgbm9kZXMnIHJlcHVsc2lvbiB2YWx1ZXMgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICAgIHJlcHVsc2lvbkZvcmNlID0gKG5vZGVBLm5vZGVSZXB1bHNpb24gLyAyICsgbm9kZUIubm9kZVJlcHVsc2lvbiAvIDIpICogbm9kZUEubm9PZkNoaWxkcmVuICogbm9kZUIubm9PZkNoaWxkcmVuIC8gZGlzdGFuY2VTcXVhcmVkO1xuXG4gICAgICAvLyBQcm9qZWN0IGZvcmNlIG9udG8geCBhbmQgeSBheGVzXG4gICAgICByZXB1bHNpb25Gb3JjZVggPSByZXB1bHNpb25Gb3JjZSAqIGRpc3RhbmNlWCAvIGRpc3RhbmNlO1xuICAgICAgcmVwdWxzaW9uRm9yY2VZID0gcmVwdWxzaW9uRm9yY2UgKiBkaXN0YW5jZVkgLyBkaXN0YW5jZTtcblxuICAgICAgLy8gQXBwbHkgZm9yY2VzIG9uIHRoZSB0d28gbm9kZXMgICAgXG4gICAgICBub2RlQS5yZXB1bHNpb25Gb3JjZVggLT0gcmVwdWxzaW9uRm9yY2VYO1xuICAgICAgbm9kZUEucmVwdWxzaW9uRm9yY2VZIC09IHJlcHVsc2lvbkZvcmNlWTtcbiAgICAgIG5vZGVCLnJlcHVsc2lvbkZvcmNlWCArPSByZXB1bHNpb25Gb3JjZVg7XG4gICAgICBub2RlQi5yZXB1bHNpb25Gb3JjZVkgKz0gcmVwdWxzaW9uRm9yY2VZO1xuICAgIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjR3Jhdml0YXRpb25hbEZvcmNlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdmFyIG93bmVyR3JhcGg7XG4gIHZhciBvd25lckNlbnRlclg7XG4gIHZhciBvd25lckNlbnRlclk7XG4gIHZhciBkaXN0YW5jZVg7XG4gIHZhciBkaXN0YW5jZVk7XG4gIHZhciBhYnNEaXN0YW5jZVg7XG4gIHZhciBhYnNEaXN0YW5jZVk7XG4gIHZhciBlc3RpbWF0ZWRTaXplO1xuICBvd25lckdyYXBoID0gbm9kZS5nZXRPd25lcigpO1xuXG4gIG93bmVyQ2VudGVyWCA9IChvd25lckdyYXBoLmdldFJpZ2h0KCkgKyBvd25lckdyYXBoLmdldExlZnQoKSkgLyAyO1xuICBvd25lckNlbnRlclkgPSAob3duZXJHcmFwaC5nZXRUb3AoKSArIG93bmVyR3JhcGguZ2V0Qm90dG9tKCkpIC8gMjtcbiAgZGlzdGFuY2VYID0gbm9kZS5nZXRDZW50ZXJYKCkgLSBvd25lckNlbnRlclg7XG4gIGRpc3RhbmNlWSA9IG5vZGUuZ2V0Q2VudGVyWSgpIC0gb3duZXJDZW50ZXJZO1xuICBhYnNEaXN0YW5jZVggPSBNYXRoLmFicyhkaXN0YW5jZVgpICsgbm9kZS5nZXRXaWR0aCgpIC8gMjtcbiAgYWJzRGlzdGFuY2VZID0gTWF0aC5hYnMoZGlzdGFuY2VZKSArIG5vZGUuZ2V0SGVpZ2h0KCkgLyAyO1xuXG4gIGlmIChub2RlLmdldE93bmVyKCkgPT0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpKSAvLyBpbiB0aGUgcm9vdCBncmFwaFxuICAgIHtcbiAgICAgIGVzdGltYXRlZFNpemUgPSBvd25lckdyYXBoLmdldEVzdGltYXRlZFNpemUoKSAqIHRoaXMuZ3Jhdml0eVJhbmdlRmFjdG9yO1xuXG4gICAgICBpZiAoYWJzRGlzdGFuY2VYID4gZXN0aW1hdGVkU2l6ZSB8fCBhYnNEaXN0YW5jZVkgPiBlc3RpbWF0ZWRTaXplKSB7XG4gICAgICAgIG5vZGUuZ3Jhdml0YXRpb25Gb3JjZVggPSAtdGhpcy5ncmF2aXR5Q29uc3RhbnQgKiBkaXN0YW5jZVg7XG4gICAgICAgIG5vZGUuZ3Jhdml0YXRpb25Gb3JjZVkgPSAtdGhpcy5ncmF2aXR5Q29uc3RhbnQgKiBkaXN0YW5jZVk7XG4gICAgICB9XG4gICAgfSBlbHNlIC8vIGluc2lkZSBhIGNvbXBvdW5kXG4gICAge1xuICAgICAgZXN0aW1hdGVkU2l6ZSA9IG93bmVyR3JhcGguZ2V0RXN0aW1hdGVkU2l6ZSgpICogdGhpcy5jb21wb3VuZEdyYXZpdHlSYW5nZUZhY3RvcjtcblxuICAgICAgaWYgKGFic0Rpc3RhbmNlWCA+IGVzdGltYXRlZFNpemUgfHwgYWJzRGlzdGFuY2VZID4gZXN0aW1hdGVkU2l6ZSkge1xuICAgICAgICBub2RlLmdyYXZpdGF0aW9uRm9yY2VYID0gLXRoaXMuZ3Jhdml0eUNvbnN0YW50ICogZGlzdGFuY2VYICogdGhpcy5jb21wb3VuZEdyYXZpdHlDb25zdGFudDtcbiAgICAgICAgbm9kZS5ncmF2aXRhdGlvbkZvcmNlWSA9IC10aGlzLmdyYXZpdHlDb25zdGFudCAqIGRpc3RhbmNlWSAqIHRoaXMuY29tcG91bmRHcmF2aXR5Q29uc3RhbnQ7XG4gICAgICB9XG4gICAgfVxufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmlzQ29udmVyZ2VkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY29udmVyZ2VkO1xuICB2YXIgb3NjaWxhdGluZyA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLnRvdGFsSXRlcmF0aW9ucyA+IHRoaXMubWF4SXRlcmF0aW9ucyAvIDMpIHtcbiAgICBvc2NpbGF0aW5nID0gTWF0aC5hYnModGhpcy50b3RhbERpc3BsYWNlbWVudCAtIHRoaXMub2xkVG90YWxEaXNwbGFjZW1lbnQpIDwgMjtcbiAgfVxuXG4gIGNvbnZlcmdlZCA9IHRoaXMudG90YWxEaXNwbGFjZW1lbnQgPCB0aGlzLnRvdGFsRGlzcGxhY2VtZW50VGhyZXNob2xkO1xuXG4gIHRoaXMub2xkVG90YWxEaXNwbGFjZW1lbnQgPSB0aGlzLnRvdGFsRGlzcGxhY2VtZW50O1xuXG4gIHJldHVybiBjb252ZXJnZWQgfHwgb3NjaWxhdGluZztcbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5hbmltYXRlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5hbmltYXRpb25EdXJpbmdMYXlvdXQgJiYgIXRoaXMuaXNTdWJMYXlvdXQpIHtcbiAgICBpZiAodGhpcy5ub3RBbmltYXRlZEl0ZXJhdGlvbnMgPT0gdGhpcy5hbmltYXRpb25QZXJpb2QpIHtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICB0aGlzLm5vdEFuaW1hdGVkSXRlcmF0aW9ucyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubm90QW5pbWF0ZWRJdGVyYXRpb25zKys7XG4gICAgfVxuICB9XG59O1xuXG4vL1RoaXMgbWV0aG9kIGNhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBjaGlsZHJlbiAod2VpZ2h0KSBmb3IgYWxsIG5vZGVzXG5GRExheW91dC5wcm90b3R5cGUuY2FsY05vT2ZDaGlsZHJlbkZvckFsbE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZTtcbiAgdmFyIGFsbE5vZGVzID0gdGhpcy5ncmFwaE1hbmFnZXIuZ2V0QWxsTm9kZXMoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbm9kZSA9IGFsbE5vZGVzW2ldO1xuICAgIG5vZGUubm9PZkNoaWxkcmVuID0gbm9kZS5nZXROb09mQ2hpbGRyZW4oKTtcbiAgfVxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFNlY3Rpb246IEZSLUdyaWQgVmFyaWFudCBSZXB1bHNpb24gRm9yY2UgQ2FsY3VsYXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjR3JpZCA9IGZ1bmN0aW9uIChncmFwaCkge1xuXG4gIHZhciBzaXplWCA9IDA7XG4gIHZhciBzaXplWSA9IDA7XG5cbiAgc2l6ZVggPSBwYXJzZUludChNYXRoLmNlaWwoKGdyYXBoLmdldFJpZ2h0KCkgLSBncmFwaC5nZXRMZWZ0KCkpIC8gdGhpcy5yZXB1bHNpb25SYW5nZSkpO1xuICBzaXplWSA9IHBhcnNlSW50KE1hdGguY2VpbCgoZ3JhcGguZ2V0Qm90dG9tKCkgLSBncmFwaC5nZXRUb3AoKSkgLyB0aGlzLnJlcHVsc2lvblJhbmdlKSk7XG5cbiAgdmFyIGdyaWQgPSBuZXcgQXJyYXkoc2l6ZVgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZVg7IGkrKykge1xuICAgIGdyaWRbaV0gPSBuZXcgQXJyYXkoc2l6ZVkpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplWDsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzaXplWTsgaisrKSB7XG4gICAgICBncmlkW2ldW2pdID0gbmV3IEFycmF5KCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdyaWQ7XG59O1xuXG5GRExheW91dC5wcm90b3R5cGUuYWRkTm9kZVRvR3JpZCA9IGZ1bmN0aW9uICh2LCBsZWZ0LCB0b3ApIHtcblxuICB2YXIgc3RhcnRYID0gMDtcbiAgdmFyIGZpbmlzaFggPSAwO1xuICB2YXIgc3RhcnRZID0gMDtcbiAgdmFyIGZpbmlzaFkgPSAwO1xuXG4gIHN0YXJ0WCA9IHBhcnNlSW50KE1hdGguZmxvb3IoKHYuZ2V0UmVjdCgpLnggLSBsZWZ0KSAvIHRoaXMucmVwdWxzaW9uUmFuZ2UpKTtcbiAgZmluaXNoWCA9IHBhcnNlSW50KE1hdGguZmxvb3IoKHYuZ2V0UmVjdCgpLndpZHRoICsgdi5nZXRSZWN0KCkueCAtIGxlZnQpIC8gdGhpcy5yZXB1bHNpb25SYW5nZSkpO1xuICBzdGFydFkgPSBwYXJzZUludChNYXRoLmZsb29yKCh2LmdldFJlY3QoKS55IC0gdG9wKSAvIHRoaXMucmVwdWxzaW9uUmFuZ2UpKTtcbiAgZmluaXNoWSA9IHBhcnNlSW50KE1hdGguZmxvb3IoKHYuZ2V0UmVjdCgpLmhlaWdodCArIHYuZ2V0UmVjdCgpLnkgLSB0b3ApIC8gdGhpcy5yZXB1bHNpb25SYW5nZSkpO1xuXG4gIGZvciAodmFyIGkgPSBzdGFydFg7IGkgPD0gZmluaXNoWDsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IHN0YXJ0WTsgaiA8PSBmaW5pc2hZOyBqKyspIHtcbiAgICAgIHRoaXMuZ3JpZFtpXVtqXS5wdXNoKHYpO1xuICAgICAgdi5zZXRHcmlkQ29vcmRpbmF0ZXMoc3RhcnRYLCBmaW5pc2hYLCBzdGFydFksIGZpbmlzaFkpO1xuICAgIH1cbiAgfVxufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLnVwZGF0ZUdyaWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpO1xuICB2YXIgbm9kZUE7XG4gIHZhciBsTm9kZXMgPSB0aGlzLmdldEFsbE5vZGVzKCk7XG5cbiAgdGhpcy5ncmlkID0gdGhpcy5jYWxjR3JpZCh0aGlzLmdyYXBoTWFuYWdlci5nZXRSb290KCkpO1xuXG4gIC8vIHB1dCBhbGwgbm9kZXMgdG8gcHJvcGVyIGdyaWQgY2VsbHNcbiAgZm9yIChpID0gMDsgaSA8IGxOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIG5vZGVBID0gbE5vZGVzW2ldO1xuICAgIHRoaXMuYWRkTm9kZVRvR3JpZChub2RlQSwgdGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpLmdldExlZnQoKSwgdGhpcy5ncmFwaE1hbmFnZXIuZ2V0Um9vdCgpLmdldFRvcCgpKTtcbiAgfVxufTtcblxuRkRMYXlvdXQucHJvdG90eXBlLmNhbGN1bGF0ZVJlcHVsc2lvbkZvcmNlT2ZBTm9kZSA9IGZ1bmN0aW9uIChub2RlQSwgcHJvY2Vzc2VkTm9kZVNldCwgZ3JpZFVwZGF0ZUFsbG93ZWQsIGZvcmNlVG9Ob2RlU3Vycm91bmRpbmdVcGRhdGUpIHtcblxuICBpZiAodGhpcy50b3RhbEl0ZXJhdGlvbnMgJSBGRExheW91dENvbnN0YW50cy5HUklEX0NBTENVTEFUSU9OX0NIRUNLX1BFUklPRCA9PSAxICYmIGdyaWRVcGRhdGVBbGxvd2VkIHx8IGZvcmNlVG9Ob2RlU3Vycm91bmRpbmdVcGRhdGUpIHtcbiAgICB2YXIgc3Vycm91bmRpbmcgPSBuZXcgU2V0KCk7XG4gICAgbm9kZUEuc3Vycm91bmRpbmcgPSBuZXcgQXJyYXkoKTtcbiAgICB2YXIgbm9kZUI7XG4gICAgdmFyIGdyaWQgPSB0aGlzLmdyaWQ7XG5cbiAgICBmb3IgKHZhciBpID0gbm9kZUEuc3RhcnRYIC0gMTsgaSA8IG5vZGVBLmZpbmlzaFggKyAyOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSBub2RlQS5zdGFydFkgLSAxOyBqIDwgbm9kZUEuZmluaXNoWSArIDI7IGorKykge1xuICAgICAgICBpZiAoIShpIDwgMCB8fCBqIDwgMCB8fCBpID49IGdyaWQubGVuZ3RoIHx8IGogPj0gZ3JpZFswXS5sZW5ndGgpKSB7XG4gICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBncmlkW2ldW2pdLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBub2RlQiA9IGdyaWRbaV1bal1ba107XG5cbiAgICAgICAgICAgIC8vIElmIGJvdGggbm9kZXMgYXJlIG5vdCBtZW1iZXJzIG9mIHRoZSBzYW1lIGdyYXBoLCBcbiAgICAgICAgICAgIC8vIG9yIGJvdGggbm9kZXMgYXJlIHRoZSBzYW1lLCBza2lwLlxuICAgICAgICAgICAgaWYgKG5vZGVBLmdldE93bmVyKCkgIT0gbm9kZUIuZ2V0T3duZXIoKSB8fCBub2RlQSA9PSBub2RlQikge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHJlcHVsc2lvbiBmb3JjZSBiZXR3ZWVuXG4gICAgICAgICAgICAvLyBub2RlQSBhbmQgbm9kZUIgaGFzIGFscmVhZHkgYmVlbiBjYWxjdWxhdGVkXG4gICAgICAgICAgICBpZiAoIXByb2Nlc3NlZE5vZGVTZXQuaGFzKG5vZGVCKSAmJiAhc3Vycm91bmRpbmcuaGFzKG5vZGVCKSkge1xuICAgICAgICAgICAgICB2YXIgZGlzdGFuY2VYID0gTWF0aC5hYnMobm9kZUEuZ2V0Q2VudGVyWCgpIC0gbm9kZUIuZ2V0Q2VudGVyWCgpKSAtIChub2RlQS5nZXRXaWR0aCgpIC8gMiArIG5vZGVCLmdldFdpZHRoKCkgLyAyKTtcbiAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlWSA9IE1hdGguYWJzKG5vZGVBLmdldENlbnRlclkoKSAtIG5vZGVCLmdldENlbnRlclkoKSkgLSAobm9kZUEuZ2V0SGVpZ2h0KCkgLyAyICsgbm9kZUIuZ2V0SGVpZ2h0KCkgLyAyKTtcblxuICAgICAgICAgICAgICAvLyBpZiB0aGUgZGlzdGFuY2UgYmV0d2VlbiBub2RlQSBhbmQgbm9kZUIgXG4gICAgICAgICAgICAgIC8vIGlzIGxlc3MgdGhlbiBjYWxjdWxhdGlvbiByYW5nZVxuICAgICAgICAgICAgICBpZiAoZGlzdGFuY2VYIDw9IHRoaXMucmVwdWxzaW9uUmFuZ2UgJiYgZGlzdGFuY2VZIDw9IHRoaXMucmVwdWxzaW9uUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAvL3RoZW4gYWRkIG5vZGVCIHRvIHN1cnJvdW5kaW5nIG9mIG5vZGVBXG4gICAgICAgICAgICAgICAgc3Vycm91bmRpbmcuYWRkKG5vZGVCKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIG5vZGVBLnN1cnJvdW5kaW5nID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShzdXJyb3VuZGluZykpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBub2RlQS5zdXJyb3VuZGluZy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuY2FsY1JlcHVsc2lvbkZvcmNlKG5vZGVBLCBub2RlQS5zdXJyb3VuZGluZ1tpXSk7XG4gIH1cbn07XG5cbkZETGF5b3V0LnByb3RvdHlwZS5jYWxjUmVwdWxzaW9uUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAwLjA7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZETGF5b3V0O1xuXG4vKioqLyB9KSxcbi8qIDE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBMRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgRkRMYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG5mdW5jdGlvbiBGRExheW91dEVkZ2Uoc291cmNlLCB0YXJnZXQsIHZFZGdlKSB7XG4gIExFZGdlLmNhbGwodGhpcywgc291cmNlLCB0YXJnZXQsIHZFZGdlKTtcblxuICAvLyBJZGVhbCBsZW5ndGggYW5kIGVsYXN0aWNpdHkgdmFsdWUgZm9yIHRoaXMgZWRnZVxuICB0aGlzLmlkZWFsTGVuZ3RoID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9FREdFX0xFTkdUSDtcbiAgdGhpcy5lZGdlRWxhc3RpY2l0eSA9IEZETGF5b3V0Q29uc3RhbnRzLkRFRkFVTFRfU1BSSU5HX1NUUkVOR1RIO1xufVxuXG5GRExheW91dEVkZ2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShMRWRnZS5wcm90b3R5cGUpO1xuXG5mb3IgKHZhciBwcm9wIGluIExFZGdlKSB7XG4gIEZETGF5b3V0RWRnZVtwcm9wXSA9IExFZGdlW3Byb3BdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZETGF5b3V0RWRnZTtcblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgTE5vZGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIEZETGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuZnVuY3Rpb24gRkRMYXlvdXROb2RlKGdtLCBsb2MsIHNpemUsIHZOb2RlKSB7XG4gIC8vIGFsdGVybmF0aXZlIGNvbnN0cnVjdG9yIGlzIGhhbmRsZWQgaW5zaWRlIExOb2RlXG4gIExOb2RlLmNhbGwodGhpcywgZ20sIGxvYywgc2l6ZSwgdk5vZGUpO1xuXG4gIC8vIFJlcHVsc2lvbiB2YWx1ZSBvZiB0aGlzIG5vZGVcbiAgdGhpcy5ub2RlUmVwdWxzaW9uID0gRkRMYXlvdXRDb25zdGFudHMuREVGQVVMVF9SRVBVTFNJT05fU1RSRU5HVEg7XG5cbiAgLy9TcHJpbmcsIHJlcHVsc2lvbiBhbmQgZ3Jhdml0YXRpb25hbCBmb3JjZXMgYWN0aW5nIG9uIHRoaXMgbm9kZVxuICB0aGlzLnNwcmluZ0ZvcmNlWCA9IDA7XG4gIHRoaXMuc3ByaW5nRm9yY2VZID0gMDtcbiAgdGhpcy5yZXB1bHNpb25Gb3JjZVggPSAwO1xuICB0aGlzLnJlcHVsc2lvbkZvcmNlWSA9IDA7XG4gIHRoaXMuZ3Jhdml0YXRpb25Gb3JjZVggPSAwO1xuICB0aGlzLmdyYXZpdGF0aW9uRm9yY2VZID0gMDtcbiAgLy9BbW91bnQgYnkgd2hpY2ggdGhpcyBub2RlIGlzIHRvIGJlIG1vdmVkIGluIHRoaXMgaXRlcmF0aW9uXG4gIHRoaXMuZGlzcGxhY2VtZW50WCA9IDA7XG4gIHRoaXMuZGlzcGxhY2VtZW50WSA9IDA7XG5cbiAgLy9TdGFydCBhbmQgZmluaXNoIGdyaWQgY29vcmRpbmF0ZXMgdGhhdCB0aGlzIG5vZGUgaXMgZmFsbGVuIGludG9cbiAgdGhpcy5zdGFydFggPSAwO1xuICB0aGlzLmZpbmlzaFggPSAwO1xuICB0aGlzLnN0YXJ0WSA9IDA7XG4gIHRoaXMuZmluaXNoWSA9IDA7XG5cbiAgLy9HZW9tZXRyaWMgbmVpZ2hib3JzIG9mIHRoaXMgbm9kZVxuICB0aGlzLnN1cnJvdW5kaW5nID0gW107XG59XG5cbkZETGF5b3V0Tm9kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKExOb2RlLnByb3RvdHlwZSk7XG5cbmZvciAodmFyIHByb3AgaW4gTE5vZGUpIHtcbiAgRkRMYXlvdXROb2RlW3Byb3BdID0gTE5vZGVbcHJvcF07XG59XG5cbkZETGF5b3V0Tm9kZS5wcm90b3R5cGUuc2V0R3JpZENvb3JkaW5hdGVzID0gZnVuY3Rpb24gKF9zdGFydFgsIF9maW5pc2hYLCBfc3RhcnRZLCBfZmluaXNoWSkge1xuICB0aGlzLnN0YXJ0WCA9IF9zdGFydFg7XG4gIHRoaXMuZmluaXNoWCA9IF9maW5pc2hYO1xuICB0aGlzLnN0YXJ0WSA9IF9zdGFydFk7XG4gIHRoaXMuZmluaXNoWSA9IF9maW5pc2hZO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGRExheW91dE5vZGU7XG5cbi8qKiovIH0pLFxuLyogMjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gRGltZW5zaW9uRCh3aWR0aCwgaGVpZ2h0KSB7XG4gIHRoaXMud2lkdGggPSAwO1xuICB0aGlzLmhlaWdodCA9IDA7XG4gIGlmICh3aWR0aCAhPT0gbnVsbCAmJiBoZWlnaHQgIT09IG51bGwpIHtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gIH1cbn1cblxuRGltZW5zaW9uRC5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLndpZHRoO1xufTtcblxuRGltZW5zaW9uRC5wcm90b3R5cGUuc2V0V2lkdGggPSBmdW5jdGlvbiAod2lkdGgpIHtcbiAgdGhpcy53aWR0aCA9IHdpZHRoO1xufTtcblxuRGltZW5zaW9uRC5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5oZWlnaHQ7XG59O1xuXG5EaW1lbnNpb25ELnByb3RvdHlwZS5zZXRIZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0KSB7XG4gIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEaW1lbnNpb25EO1xuXG4vKioqLyB9KSxcbi8qIDIyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBVbmlxdWVJREdlbmVyZXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG5mdW5jdGlvbiBIYXNoTWFwKCkge1xuICB0aGlzLm1hcCA9IHt9O1xuICB0aGlzLmtleXMgPSBbXTtcbn1cblxuSGFzaE1hcC5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdmFyIHRoZUlkID0gVW5pcXVlSURHZW5lcmV0b3IuY3JlYXRlSUQoa2V5KTtcbiAgaWYgKCF0aGlzLmNvbnRhaW5zKHRoZUlkKSkge1xuICAgIHRoaXMubWFwW3RoZUlkXSA9IHZhbHVlO1xuICAgIHRoaXMua2V5cy5wdXNoKGtleSk7XG4gIH1cbn07XG5cbkhhc2hNYXAucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKGtleSkge1xuICB2YXIgdGhlSWQgPSBVbmlxdWVJREdlbmVyZXRvci5jcmVhdGVJRChrZXkpO1xuICByZXR1cm4gdGhpcy5tYXBba2V5XSAhPSBudWxsO1xufTtcblxuSGFzaE1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICB2YXIgdGhlSWQgPSBVbmlxdWVJREdlbmVyZXRvci5jcmVhdGVJRChrZXkpO1xuICByZXR1cm4gdGhpcy5tYXBbdGhlSWRdO1xufTtcblxuSGFzaE1hcC5wcm90b3R5cGUua2V5U2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5rZXlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIYXNoTWFwO1xuXG4vKioqLyB9KSxcbi8qIDIzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBVbmlxdWVJREdlbmVyZXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuXG5mdW5jdGlvbiBIYXNoU2V0KCkge1xuICB0aGlzLnNldCA9IHt9O1xufVxuO1xuXG5IYXNoU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciB0aGVJZCA9IFVuaXF1ZUlER2VuZXJldG9yLmNyZWF0ZUlEKG9iaik7XG4gIGlmICghdGhpcy5jb250YWlucyh0aGVJZCkpIHRoaXMuc2V0W3RoZUlkXSA9IG9iajtcbn07XG5cbkhhc2hTZXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgZGVsZXRlIHRoaXMuc2V0W1VuaXF1ZUlER2VuZXJldG9yLmNyZWF0ZUlEKG9iaildO1xufTtcblxuSGFzaFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2V0ID0ge307XG59O1xuXG5IYXNoU2V0LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHRoaXMuc2V0W1VuaXF1ZUlER2VuZXJldG9yLmNyZWF0ZUlEKG9iaildID09IG9iajtcbn07XG5cbkhhc2hTZXQucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnNpemUoKSA9PT0gMDtcbn07XG5cbkhhc2hTZXQucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnNldCkubGVuZ3RoO1xufTtcblxuLy9jb25jYXRzIHRoaXMuc2V0IHRvIHRoZSBnaXZlbiBsaXN0XG5IYXNoU2V0LnByb3RvdHlwZS5hZGRBbGxUbyA9IGZ1bmN0aW9uIChsaXN0KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcy5zZXQpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBsaXN0LnB1c2godGhpcy5zZXRba2V5c1tpXV0pO1xuICB9XG59O1xuXG5IYXNoU2V0LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zZXQpLmxlbmd0aDtcbn07XG5cbkhhc2hTZXQucHJvdG90eXBlLmFkZEFsbCA9IGZ1bmN0aW9uIChsaXN0KSB7XG4gIHZhciBzID0gbGlzdC5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgdmFyIHYgPSBsaXN0W2ldO1xuICAgIHRoaXMuYWRkKHYpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2hTZXQ7XG5cbi8qKiovIH0pLFxuLyogMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLy8gU29tZSBtYXRyaXggKDFkIGFuZCAyZCBhcnJheSkgb3BlcmF0aW9uc1xuZnVuY3Rpb24gTWF0cml4KCkge31cblxuLyoqXG4gKiBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAqIGFycmF5MSwgYXJyYXkyIGFuZCByZXN1bHQgYXJlIDJkIGFycmF5c1xuICovXG5NYXRyaXgubXVsdE1hdCA9IGZ1bmN0aW9uIChhcnJheTEsIGFycmF5Mikge1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheTEubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRbaV0gPSBbXTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGFycmF5MlswXS5sZW5ndGg7IGorKykge1xuICAgICAgcmVzdWx0W2ldW2pdID0gMDtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgYXJyYXkxWzBdLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHJlc3VsdFtpXVtqXSArPSBhcnJheTFbaV1ba10gKiBhcnJheTJba11bal07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIG1hdHJpeCB0cmFuc3Bvc2VcbiAqIGFycmF5IGFuZCByZXN1bHQgYXJlIDJkIGFycmF5c1xuICovXG5NYXRyaXgudHJhbnNwb3NlID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5WzBdLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0W2ldID0gW107XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBhcnJheS5sZW5ndGg7IGorKykge1xuICAgICAgcmVzdWx0W2ldW2pdID0gYXJyYXlbal1baV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogbXVsdGlwbHkgYXJyYXkgd2l0aCBjb25zdGFudFxuICogYXJyYXkgYW5kIHJlc3VsdCBhcmUgMWQgYXJyYXlzXG4gKi9cbk1hdHJpeC5tdWx0Q29ucyA9IGZ1bmN0aW9uIChhcnJheSwgY29uc3RhbnQpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRbaV0gPSBhcnJheVtpXSAqIGNvbnN0YW50O1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogc3Vic3RyYWN0IHR3byBhcnJheXNcbiAqIGFycmF5MSwgYXJyYXkyIGFuZCByZXN1bHQgYXJlIDFkIGFycmF5c1xuICovXG5NYXRyaXgubWludXNPcCA9IGZ1bmN0aW9uIChhcnJheTEsIGFycmF5Mikge1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheTEubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRbaV0gPSBhcnJheTFbaV0gLSBhcnJheTJbaV07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBkb3QgcHJvZHVjdCBvZiB0d28gYXJyYXlzIHdpdGggc2FtZSBzaXplXG4gKiBhcnJheTEgYW5kIGFycmF5MiBhcmUgMWQgYXJyYXlzXG4gKi9cbk1hdHJpeC5kb3RQcm9kdWN0ID0gZnVuY3Rpb24gKGFycmF5MSwgYXJyYXkyKSB7XG4gIHZhciBwcm9kdWN0ID0gMDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5MS5sZW5ndGg7IGkrKykge1xuICAgIHByb2R1Y3QgKz0gYXJyYXkxW2ldICogYXJyYXkyW2ldO1xuICB9XG5cbiAgcmV0dXJuIHByb2R1Y3Q7XG59O1xuXG4vKipcbiAqIG1hZ25pdHVkZSBvZiBhbiBhcnJheVxuICogYXJyYXkgaXMgMWQgYXJyYXlcbiAqL1xuTWF0cml4Lm1hZyA9IGZ1bmN0aW9uIChhcnJheSkge1xuICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMuZG90UHJvZHVjdChhcnJheSwgYXJyYXkpKTtcbn07XG5cbi8qKlxuICogbm9ybWFsaXphdGlvbiBvZiBhbiBhcnJheVxuICogYXJyYXkgYW5kIHJlc3VsdCBhcmUgMWQgYXJyYXlcbiAqL1xuTWF0cml4Lm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChhcnJheSkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBtYWduaXR1ZGUgPSB0aGlzLm1hZyhhcnJheSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdFtpXSA9IGFycmF5W2ldIC8gbWFnbml0dWRlO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogbXVsdGlwbHkgYW4gYXJyYXkgd2l0aCBjZW50ZXJpbmcgbWF0cml4XG4gKiBhcnJheSBhbmQgcmVzdWx0IGFyZSAxZCBhcnJheVxuICovXG5NYXRyaXgubXVsdEdhbW1hID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIHN1bSA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHN1bSArPSBhcnJheVtpXTtcbiAgfVxuXG4gIHN1bSAqPSAtMSAvIGFycmF5Lmxlbmd0aDtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJyYXkubGVuZ3RoOyBfaSsrKSB7XG4gICAgcmVzdWx0W19pXSA9IHN1bSArIGFycmF5W19pXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBhIHNwZWNpYWwgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gKiByZXN1bHQgPSAwLjUgKiBDICogSU5WICogQ15UICogYXJyYXlcbiAqIGFycmF5IGFuZCByZXN1bHQgYXJlIDFkLCBDIGFuZCBJTlYgYXJlIDJkIGFycmF5c1xuICovXG5NYXRyaXgubXVsdEwgPSBmdW5jdGlvbiAoYXJyYXksIEMsIElOVikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciB0ZW1wMSA9IFtdO1xuICB2YXIgdGVtcDIgPSBbXTtcblxuICAvLyBtdWx0aXBseSBieSBDXlRcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBDWzBdLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBDLmxlbmd0aDsgaisrKSB7XG4gICAgICBzdW0gKz0gLTAuNSAqIENbal1baV0gKiBhcnJheVtqXTtcbiAgICB9XG4gICAgdGVtcDFbaV0gPSBzdW07XG4gIH1cbiAgLy8gbXVsdGlwbHkgdGhlIHJlc3VsdCBieSBJTlZcbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgSU5WLmxlbmd0aDsgX2kyKyspIHtcbiAgICB2YXIgX3N1bSA9IDA7XG4gICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IElOVi5sZW5ndGg7IF9qKyspIHtcbiAgICAgIF9zdW0gKz0gSU5WW19pMl1bX2pdICogdGVtcDFbX2pdO1xuICAgIH1cbiAgICB0ZW1wMltfaTJdID0gX3N1bTtcbiAgfVxuICAvLyBtdWx0aXBseSB0aGUgcmVzdWx0IGJ5IENcbiAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgQy5sZW5ndGg7IF9pMysrKSB7XG4gICAgdmFyIF9zdW0yID0gMDtcbiAgICBmb3IgKHZhciBfajIgPSAwOyBfajIgPCBDWzBdLmxlbmd0aDsgX2oyKyspIHtcbiAgICAgIF9zdW0yICs9IENbX2kzXVtfajJdICogdGVtcDJbX2oyXTtcbiAgICB9XG4gICAgcmVzdWx0W19pM10gPSBfc3VtMjtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hdHJpeDtcblxuLyoqKi8gfSksXG4vKiAyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIEEgY2xhc3NpYyBRdWlja3NvcnQgYWxnb3JpdGhtIHdpdGggSG9hcmUncyBwYXJ0aXRpb25cbiAqIC0gV29ya3MgYWxzbyBvbiBMaW5rZWRMaXN0IG9iamVjdHNcbiAqXG4gKiBDb3B5cmlnaHQ6IGktVmlzIFJlc2VhcmNoIEdyb3VwLCBCaWxrZW50IFVuaXZlcnNpdHksIDIwMDcgLSBwcmVzZW50XG4gKi9cblxudmFyIExpbmtlZExpc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxudmFyIFF1aWNrc29ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBRdWlja3NvcnQoQSwgY29tcGFyZUZ1bmN0aW9uKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBRdWlja3NvcnQpO1xuXG4gICAgICAgIGlmIChjb21wYXJlRnVuY3Rpb24gIT09IG51bGwgfHwgY29tcGFyZUZ1bmN0aW9uICE9PSB1bmRlZmluZWQpIHRoaXMuY29tcGFyZUZ1bmN0aW9uID0gdGhpcy5fZGVmYXVsdENvbXBhcmVGdW5jdGlvbjtcblxuICAgICAgICB2YXIgbGVuZ3RoID0gdm9pZCAwO1xuICAgICAgICBpZiAoQSBpbnN0YW5jZW9mIExpbmtlZExpc3QpIGxlbmd0aCA9IEEuc2l6ZSgpO2Vsc2UgbGVuZ3RoID0gQS5sZW5ndGg7XG5cbiAgICAgICAgdGhpcy5fcXVpY2tzb3J0KEEsIDAsIGxlbmd0aCAtIDEpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhRdWlja3NvcnQsIFt7XG4gICAgICAgIGtleTogJ19xdWlja3NvcnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3F1aWNrc29ydChBLCBwLCByKSB7XG4gICAgICAgICAgICBpZiAocCA8IHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcSA9IHRoaXMuX3BhcnRpdGlvbihBLCBwLCByKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWlja3NvcnQoQSwgcCwgcSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVpY2tzb3J0KEEsIHEgKyAxLCByKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3BhcnRpdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcGFydGl0aW9uKEEsIHAsIHIpIHtcbiAgICAgICAgICAgIHZhciB4ID0gdGhpcy5fZ2V0KEEsIHApO1xuICAgICAgICAgICAgdmFyIGkgPSBwO1xuICAgICAgICAgICAgdmFyIGogPSByO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5jb21wYXJlRnVuY3Rpb24oeCwgdGhpcy5fZ2V0KEEsIGopKSkge1xuICAgICAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICAgICAgfXdoaWxlICh0aGlzLmNvbXBhcmVGdW5jdGlvbih0aGlzLl9nZXQoQSwgaSksIHgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9aWYgKGkgPCBqKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N3YXAoQSwgaSwgaik7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSByZXR1cm4gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2dldCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0KG9iamVjdCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBMaW5rZWRMaXN0KSByZXR1cm4gb2JqZWN0LmdldF9vYmplY3RfYXQoaW5kZXgpO2Vsc2UgcmV0dXJuIG9iamVjdFtpbmRleF07XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19zZXQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldChvYmplY3QsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIExpbmtlZExpc3QpIG9iamVjdC5zZXRfb2JqZWN0X2F0KGluZGV4LCB2YWx1ZSk7ZWxzZSBvYmplY3RbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19zd2FwJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zd2FwKEEsIGksIGopIHtcbiAgICAgICAgICAgIHZhciB0ZW1wID0gdGhpcy5fZ2V0KEEsIGkpO1xuICAgICAgICAgICAgdGhpcy5fc2V0KEEsIGksIHRoaXMuX2dldChBLCBqKSk7XG4gICAgICAgICAgICB0aGlzLl9zZXQoQSwgaiwgdGVtcCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19kZWZhdWx0Q29tcGFyZUZ1bmN0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWZhdWx0Q29tcGFyZUZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiID4gYTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBRdWlja3NvcnQ7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gUXVpY2tzb3J0O1xuXG4vKioqLyB9KSxcbi8qIDI2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8vIFNpbmd1bGFyIFZhbHVlIERlY29tcG9zaXRpb24gaW1wbGVtZW50YXRpb25cbmZ1bmN0aW9uIFNWRCgpIHt9O1xuXG4vKiBCZWxvdyBzaW5ndWxhciB2YWx1ZSBkZWNvbXBvc2l0aW9uIChzdmQpIGNvZGUgaW5jbHVkaW5nIGh5cG90IGZ1bmN0aW9uIGlzIGFkb3B0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZHJhZ29uZmx5LWFpL0phbWFKU1xuICAgU29tZSBjaGFuZ2VzIGFyZSBhcHBsaWVkIHRvIG1ha2UgdGhlIGNvZGUgY29tcGF0aWJsZSB3aXRoIHRoZSBmY29zZSBjb2RlIGFuZCB0byBtYWtlIGl0IGluZGVwZW5kZW50IGZyb20gSmFtYS5cbiAgIElucHV0IG1hdHJpeCBpcyBjaGFuZ2VkIHRvIGEgMkQgYXJyYXkgaW5zdGVhZCBvZiBKYW1hIG1hdHJpeC4gTWF0cml4IGRpbWVuc2lvbnMgYXJlIHRha2VuIGFjY29yZGluZyB0byAyRCBhcnJheSBpbnN0ZWFkIG9mIHVzaW5nIEphbWEgZnVuY3Rpb25zLlxuICAgQW4gb2JqZWN0IHRoYXQgaW5jbHVkZXMgc2luZ3VsYXIgdmFsdWUgY29tcG9uZW50cyBpcyBjcmVhdGVkIGZvciByZXR1cm4uIFxuICAgVGhlIHR5cGVzIG9mIGlucHV0IHBhcmFtZXRlcnMgb2YgdGhlIGh5cG90IGZ1bmN0aW9uIGFyZSByZW1vdmVkLiBcbiAgIGxldCBpcyB1c2VkIGluc3RlYWQgb2YgdmFyIGZvciB0aGUgdmFyaWFibGUgaW5pdGlhbGl6YXRpb24uXG4qL1xuLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcGFjaGUgTGljZW5zZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgVmVyc2lvbiAyLjAsIEphbnVhcnkgMjAwNFxuICAgICAgICAgICAgICAgICAgICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL1xuXG4gICBURVJNUyBBTkQgQ09ORElUSU9OUyBGT1IgVVNFLCBSRVBST0RVQ1RJT04sIEFORCBESVNUUklCVVRJT05cblxuICAgMS4gRGVmaW5pdGlvbnMuXG5cbiAgICAgIFwiTGljZW5zZVwiIHNoYWxsIG1lYW4gdGhlIHRlcm1zIGFuZCBjb25kaXRpb25zIGZvciB1c2UsIHJlcHJvZHVjdGlvbixcbiAgICAgIGFuZCBkaXN0cmlidXRpb24gYXMgZGVmaW5lZCBieSBTZWN0aW9ucyAxIHRocm91Z2ggOSBvZiB0aGlzIGRvY3VtZW50LlxuXG4gICAgICBcIkxpY2Vuc29yXCIgc2hhbGwgbWVhbiB0aGUgY29weXJpZ2h0IG93bmVyIG9yIGVudGl0eSBhdXRob3JpemVkIGJ5XG4gICAgICB0aGUgY29weXJpZ2h0IG93bmVyIHRoYXQgaXMgZ3JhbnRpbmcgdGhlIExpY2Vuc2UuXG5cbiAgICAgIFwiTGVnYWwgRW50aXR5XCIgc2hhbGwgbWVhbiB0aGUgdW5pb24gb2YgdGhlIGFjdGluZyBlbnRpdHkgYW5kIGFsbFxuICAgICAgb3RoZXIgZW50aXRpZXMgdGhhdCBjb250cm9sLCBhcmUgY29udHJvbGxlZCBieSwgb3IgYXJlIHVuZGVyIGNvbW1vblxuICAgICAgY29udHJvbCB3aXRoIHRoYXQgZW50aXR5LiBGb3IgdGhlIHB1cnBvc2VzIG9mIHRoaXMgZGVmaW5pdGlvbixcbiAgICAgIFwiY29udHJvbFwiIG1lYW5zIChpKSB0aGUgcG93ZXIsIGRpcmVjdCBvciBpbmRpcmVjdCwgdG8gY2F1c2UgdGhlXG4gICAgICBkaXJlY3Rpb24gb3IgbWFuYWdlbWVudCBvZiBzdWNoIGVudGl0eSwgd2hldGhlciBieSBjb250cmFjdCBvclxuICAgICAgb3RoZXJ3aXNlLCBvciAoaWkpIG93bmVyc2hpcCBvZiBmaWZ0eSBwZXJjZW50ICg1MCUpIG9yIG1vcmUgb2YgdGhlXG4gICAgICBvdXRzdGFuZGluZyBzaGFyZXMsIG9yIChpaWkpIGJlbmVmaWNpYWwgb3duZXJzaGlwIG9mIHN1Y2ggZW50aXR5LlxuXG4gICAgICBcIllvdVwiIChvciBcIllvdXJcIikgc2hhbGwgbWVhbiBhbiBpbmRpdmlkdWFsIG9yIExlZ2FsIEVudGl0eVxuICAgICAgZXhlcmNpc2luZyBwZXJtaXNzaW9ucyBncmFudGVkIGJ5IHRoaXMgTGljZW5zZS5cblxuICAgICAgXCJTb3VyY2VcIiBmb3JtIHNoYWxsIG1lYW4gdGhlIHByZWZlcnJlZCBmb3JtIGZvciBtYWtpbmcgbW9kaWZpY2F0aW9ucyxcbiAgICAgIGluY2x1ZGluZyBidXQgbm90IGxpbWl0ZWQgdG8gc29mdHdhcmUgc291cmNlIGNvZGUsIGRvY3VtZW50YXRpb25cbiAgICAgIHNvdXJjZSwgYW5kIGNvbmZpZ3VyYXRpb24gZmlsZXMuXG5cbiAgICAgIFwiT2JqZWN0XCIgZm9ybSBzaGFsbCBtZWFuIGFueSBmb3JtIHJlc3VsdGluZyBmcm9tIG1lY2hhbmljYWxcbiAgICAgIHRyYW5zZm9ybWF0aW9uIG9yIHRyYW5zbGF0aW9uIG9mIGEgU291cmNlIGZvcm0sIGluY2x1ZGluZyBidXRcbiAgICAgIG5vdCBsaW1pdGVkIHRvIGNvbXBpbGVkIG9iamVjdCBjb2RlLCBnZW5lcmF0ZWQgZG9jdW1lbnRhdGlvbixcbiAgICAgIGFuZCBjb252ZXJzaW9ucyB0byBvdGhlciBtZWRpYSB0eXBlcy5cblxuICAgICAgXCJXb3JrXCIgc2hhbGwgbWVhbiB0aGUgd29yayBvZiBhdXRob3JzaGlwLCB3aGV0aGVyIGluIFNvdXJjZSBvclxuICAgICAgT2JqZWN0IGZvcm0sIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZSBMaWNlbnNlLCBhcyBpbmRpY2F0ZWQgYnkgYVxuICAgICAgY29weXJpZ2h0IG5vdGljZSB0aGF0IGlzIGluY2x1ZGVkIGluIG9yIGF0dGFjaGVkIHRvIHRoZSB3b3JrXG4gICAgICAoYW4gZXhhbXBsZSBpcyBwcm92aWRlZCBpbiB0aGUgQXBwZW5kaXggYmVsb3cpLlxuXG4gICAgICBcIkRlcml2YXRpdmUgV29ya3NcIiBzaGFsbCBtZWFuIGFueSB3b3JrLCB3aGV0aGVyIGluIFNvdXJjZSBvciBPYmplY3RcbiAgICAgIGZvcm0sIHRoYXQgaXMgYmFzZWQgb24gKG9yIGRlcml2ZWQgZnJvbSkgdGhlIFdvcmsgYW5kIGZvciB3aGljaCB0aGVcbiAgICAgIGVkaXRvcmlhbCByZXZpc2lvbnMsIGFubm90YXRpb25zLCBlbGFib3JhdGlvbnMsIG9yIG90aGVyIG1vZGlmaWNhdGlvbnNcbiAgICAgIHJlcHJlc2VudCwgYXMgYSB3aG9sZSwgYW4gb3JpZ2luYWwgd29yayBvZiBhdXRob3JzaGlwLiBGb3IgdGhlIHB1cnBvc2VzXG4gICAgICBvZiB0aGlzIExpY2Vuc2UsIERlcml2YXRpdmUgV29ya3Mgc2hhbGwgbm90IGluY2x1ZGUgd29ya3MgdGhhdCByZW1haW5cbiAgICAgIHNlcGFyYWJsZSBmcm9tLCBvciBtZXJlbHkgbGluayAob3IgYmluZCBieSBuYW1lKSB0byB0aGUgaW50ZXJmYWNlcyBvZixcbiAgICAgIHRoZSBXb3JrIGFuZCBEZXJpdmF0aXZlIFdvcmtzIHRoZXJlb2YuXG5cbiAgICAgIFwiQ29udHJpYnV0aW9uXCIgc2hhbGwgbWVhbiBhbnkgd29yayBvZiBhdXRob3JzaGlwLCBpbmNsdWRpbmdcbiAgICAgIHRoZSBvcmlnaW5hbCB2ZXJzaW9uIG9mIHRoZSBXb3JrIGFuZCBhbnkgbW9kaWZpY2F0aW9ucyBvciBhZGRpdGlvbnNcbiAgICAgIHRvIHRoYXQgV29yayBvciBEZXJpdmF0aXZlIFdvcmtzIHRoZXJlb2YsIHRoYXQgaXMgaW50ZW50aW9uYWxseVxuICAgICAgc3VibWl0dGVkIHRvIExpY2Vuc29yIGZvciBpbmNsdXNpb24gaW4gdGhlIFdvcmsgYnkgdGhlIGNvcHlyaWdodCBvd25lclxuICAgICAgb3IgYnkgYW4gaW5kaXZpZHVhbCBvciBMZWdhbCBFbnRpdHkgYXV0aG9yaXplZCB0byBzdWJtaXQgb24gYmVoYWxmIG9mXG4gICAgICB0aGUgY29weXJpZ2h0IG93bmVyLiBGb3IgdGhlIHB1cnBvc2VzIG9mIHRoaXMgZGVmaW5pdGlvbiwgXCJzdWJtaXR0ZWRcIlxuICAgICAgbWVhbnMgYW55IGZvcm0gb2YgZWxlY3Ryb25pYywgdmVyYmFsLCBvciB3cml0dGVuIGNvbW11bmljYXRpb24gc2VudFxuICAgICAgdG8gdGhlIExpY2Vuc29yIG9yIGl0cyByZXByZXNlbnRhdGl2ZXMsIGluY2x1ZGluZyBidXQgbm90IGxpbWl0ZWQgdG9cbiAgICAgIGNvbW11bmljYXRpb24gb24gZWxlY3Ryb25pYyBtYWlsaW5nIGxpc3RzLCBzb3VyY2UgY29kZSBjb250cm9sIHN5c3RlbXMsXG4gICAgICBhbmQgaXNzdWUgdHJhY2tpbmcgc3lzdGVtcyB0aGF0IGFyZSBtYW5hZ2VkIGJ5LCBvciBvbiBiZWhhbGYgb2YsIHRoZVxuICAgICAgTGljZW5zb3IgZm9yIHRoZSBwdXJwb3NlIG9mIGRpc2N1c3NpbmcgYW5kIGltcHJvdmluZyB0aGUgV29yaywgYnV0XG4gICAgICBleGNsdWRpbmcgY29tbXVuaWNhdGlvbiB0aGF0IGlzIGNvbnNwaWN1b3VzbHkgbWFya2VkIG9yIG90aGVyd2lzZVxuICAgICAgZGVzaWduYXRlZCBpbiB3cml0aW5nIGJ5IHRoZSBjb3B5cmlnaHQgb3duZXIgYXMgXCJOb3QgYSBDb250cmlidXRpb24uXCJcblxuICAgICAgXCJDb250cmlidXRvclwiIHNoYWxsIG1lYW4gTGljZW5zb3IgYW5kIGFueSBpbmRpdmlkdWFsIG9yIExlZ2FsIEVudGl0eVxuICAgICAgb24gYmVoYWxmIG9mIHdob20gYSBDb250cmlidXRpb24gaGFzIGJlZW4gcmVjZWl2ZWQgYnkgTGljZW5zb3IgYW5kXG4gICAgICBzdWJzZXF1ZW50bHkgaW5jb3Jwb3JhdGVkIHdpdGhpbiB0aGUgV29yay5cblxuICAgMi4gR3JhbnQgb2YgQ29weXJpZ2h0IExpY2Vuc2UuIFN1YmplY3QgdG8gdGhlIHRlcm1zIGFuZCBjb25kaXRpb25zIG9mXG4gICAgICB0aGlzIExpY2Vuc2UsIGVhY2ggQ29udHJpYnV0b3IgaGVyZWJ5IGdyYW50cyB0byBZb3UgYSBwZXJwZXR1YWwsXG4gICAgICB3b3JsZHdpZGUsIG5vbi1leGNsdXNpdmUsIG5vLWNoYXJnZSwgcm95YWx0eS1mcmVlLCBpcnJldm9jYWJsZVxuICAgICAgY29weXJpZ2h0IGxpY2Vuc2UgdG8gcmVwcm9kdWNlLCBwcmVwYXJlIERlcml2YXRpdmUgV29ya3Mgb2YsXG4gICAgICBwdWJsaWNseSBkaXNwbGF5LCBwdWJsaWNseSBwZXJmb3JtLCBzdWJsaWNlbnNlLCBhbmQgZGlzdHJpYnV0ZSB0aGVcbiAgICAgIFdvcmsgYW5kIHN1Y2ggRGVyaXZhdGl2ZSBXb3JrcyBpbiBTb3VyY2Ugb3IgT2JqZWN0IGZvcm0uXG5cbiAgIDMuIEdyYW50IG9mIFBhdGVudCBMaWNlbnNlLiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhbmQgY29uZGl0aW9ucyBvZlxuICAgICAgdGhpcyBMaWNlbnNlLCBlYWNoIENvbnRyaWJ1dG9yIGhlcmVieSBncmFudHMgdG8gWW91IGEgcGVycGV0dWFsLFxuICAgICAgd29ybGR3aWRlLCBub24tZXhjbHVzaXZlLCBuby1jaGFyZ2UsIHJveWFsdHktZnJlZSwgaXJyZXZvY2FibGVcbiAgICAgIChleGNlcHQgYXMgc3RhdGVkIGluIHRoaXMgc2VjdGlvbikgcGF0ZW50IGxpY2Vuc2UgdG8gbWFrZSwgaGF2ZSBtYWRlLFxuICAgICAgdXNlLCBvZmZlciB0byBzZWxsLCBzZWxsLCBpbXBvcnQsIGFuZCBvdGhlcndpc2UgdHJhbnNmZXIgdGhlIFdvcmssXG4gICAgICB3aGVyZSBzdWNoIGxpY2Vuc2UgYXBwbGllcyBvbmx5IHRvIHRob3NlIHBhdGVudCBjbGFpbXMgbGljZW5zYWJsZVxuICAgICAgYnkgc3VjaCBDb250cmlidXRvciB0aGF0IGFyZSBuZWNlc3NhcmlseSBpbmZyaW5nZWQgYnkgdGhlaXJcbiAgICAgIENvbnRyaWJ1dGlvbihzKSBhbG9uZSBvciBieSBjb21iaW5hdGlvbiBvZiB0aGVpciBDb250cmlidXRpb24ocylcbiAgICAgIHdpdGggdGhlIFdvcmsgdG8gd2hpY2ggc3VjaCBDb250cmlidXRpb24ocykgd2FzIHN1Ym1pdHRlZC4gSWYgWW91XG4gICAgICBpbnN0aXR1dGUgcGF0ZW50IGxpdGlnYXRpb24gYWdhaW5zdCBhbnkgZW50aXR5IChpbmNsdWRpbmcgYVxuICAgICAgY3Jvc3MtY2xhaW0gb3IgY291bnRlcmNsYWltIGluIGEgbGF3c3VpdCkgYWxsZWdpbmcgdGhhdCB0aGUgV29ya1xuICAgICAgb3IgYSBDb250cmlidXRpb24gaW5jb3Jwb3JhdGVkIHdpdGhpbiB0aGUgV29yayBjb25zdGl0dXRlcyBkaXJlY3RcbiAgICAgIG9yIGNvbnRyaWJ1dG9yeSBwYXRlbnQgaW5mcmluZ2VtZW50LCB0aGVuIGFueSBwYXRlbnQgbGljZW5zZXNcbiAgICAgIGdyYW50ZWQgdG8gWW91IHVuZGVyIHRoaXMgTGljZW5zZSBmb3IgdGhhdCBXb3JrIHNoYWxsIHRlcm1pbmF0ZVxuICAgICAgYXMgb2YgdGhlIGRhdGUgc3VjaCBsaXRpZ2F0aW9uIGlzIGZpbGVkLlxuXG4gICA0LiBSZWRpc3RyaWJ1dGlvbi4gWW91IG1heSByZXByb2R1Y2UgYW5kIGRpc3RyaWJ1dGUgY29waWVzIG9mIHRoZVxuICAgICAgV29yayBvciBEZXJpdmF0aXZlIFdvcmtzIHRoZXJlb2YgaW4gYW55IG1lZGl1bSwgd2l0aCBvciB3aXRob3V0XG4gICAgICBtb2RpZmljYXRpb25zLCBhbmQgaW4gU291cmNlIG9yIE9iamVjdCBmb3JtLCBwcm92aWRlZCB0aGF0IFlvdVxuICAgICAgbWVldCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgICAgIChhKSBZb3UgbXVzdCBnaXZlIGFueSBvdGhlciByZWNpcGllbnRzIG9mIHRoZSBXb3JrIG9yXG4gICAgICAgICAgRGVyaXZhdGl2ZSBXb3JrcyBhIGNvcHkgb2YgdGhpcyBMaWNlbnNlOyBhbmRcblxuICAgICAgKGIpIFlvdSBtdXN0IGNhdXNlIGFueSBtb2RpZmllZCBmaWxlcyB0byBjYXJyeSBwcm9taW5lbnQgbm90aWNlc1xuICAgICAgICAgIHN0YXRpbmcgdGhhdCBZb3UgY2hhbmdlZCB0aGUgZmlsZXM7IGFuZFxuXG4gICAgICAoYykgWW91IG11c3QgcmV0YWluLCBpbiB0aGUgU291cmNlIGZvcm0gb2YgYW55IERlcml2YXRpdmUgV29ya3NcbiAgICAgICAgICB0aGF0IFlvdSBkaXN0cmlidXRlLCBhbGwgY29weXJpZ2h0LCBwYXRlbnQsIHRyYWRlbWFyaywgYW5kXG4gICAgICAgICAgYXR0cmlidXRpb24gbm90aWNlcyBmcm9tIHRoZSBTb3VyY2UgZm9ybSBvZiB0aGUgV29yayxcbiAgICAgICAgICBleGNsdWRpbmcgdGhvc2Ugbm90aWNlcyB0aGF0IGRvIG5vdCBwZXJ0YWluIHRvIGFueSBwYXJ0IG9mXG4gICAgICAgICAgdGhlIERlcml2YXRpdmUgV29ya3M7IGFuZFxuXG4gICAgICAoZCkgSWYgdGhlIFdvcmsgaW5jbHVkZXMgYSBcIk5PVElDRVwiIHRleHQgZmlsZSBhcyBwYXJ0IG9mIGl0c1xuICAgICAgICAgIGRpc3RyaWJ1dGlvbiwgdGhlbiBhbnkgRGVyaXZhdGl2ZSBXb3JrcyB0aGF0IFlvdSBkaXN0cmlidXRlIG11c3RcbiAgICAgICAgICBpbmNsdWRlIGEgcmVhZGFibGUgY29weSBvZiB0aGUgYXR0cmlidXRpb24gbm90aWNlcyBjb250YWluZWRcbiAgICAgICAgICB3aXRoaW4gc3VjaCBOT1RJQ0UgZmlsZSwgZXhjbHVkaW5nIHRob3NlIG5vdGljZXMgdGhhdCBkbyBub3RcbiAgICAgICAgICBwZXJ0YWluIHRvIGFueSBwYXJ0IG9mIHRoZSBEZXJpdmF0aXZlIFdvcmtzLCBpbiBhdCBsZWFzdCBvbmVcbiAgICAgICAgICBvZiB0aGUgZm9sbG93aW5nIHBsYWNlczogd2l0aGluIGEgTk9USUNFIHRleHQgZmlsZSBkaXN0cmlidXRlZFxuICAgICAgICAgIGFzIHBhcnQgb2YgdGhlIERlcml2YXRpdmUgV29ya3M7IHdpdGhpbiB0aGUgU291cmNlIGZvcm0gb3JcbiAgICAgICAgICBkb2N1bWVudGF0aW9uLCBpZiBwcm92aWRlZCBhbG9uZyB3aXRoIHRoZSBEZXJpdmF0aXZlIFdvcmtzOyBvcixcbiAgICAgICAgICB3aXRoaW4gYSBkaXNwbGF5IGdlbmVyYXRlZCBieSB0aGUgRGVyaXZhdGl2ZSBXb3JrcywgaWYgYW5kXG4gICAgICAgICAgd2hlcmV2ZXIgc3VjaCB0aGlyZC1wYXJ0eSBub3RpY2VzIG5vcm1hbGx5IGFwcGVhci4gVGhlIGNvbnRlbnRzXG4gICAgICAgICAgb2YgdGhlIE5PVElDRSBmaWxlIGFyZSBmb3IgaW5mb3JtYXRpb25hbCBwdXJwb3NlcyBvbmx5IGFuZFxuICAgICAgICAgIGRvIG5vdCBtb2RpZnkgdGhlIExpY2Vuc2UuIFlvdSBtYXkgYWRkIFlvdXIgb3duIGF0dHJpYnV0aW9uXG4gICAgICAgICAgbm90aWNlcyB3aXRoaW4gRGVyaXZhdGl2ZSBXb3JrcyB0aGF0IFlvdSBkaXN0cmlidXRlLCBhbG9uZ3NpZGVcbiAgICAgICAgICBvciBhcyBhbiBhZGRlbmR1bSB0byB0aGUgTk9USUNFIHRleHQgZnJvbSB0aGUgV29yaywgcHJvdmlkZWRcbiAgICAgICAgICB0aGF0IHN1Y2ggYWRkaXRpb25hbCBhdHRyaWJ1dGlvbiBub3RpY2VzIGNhbm5vdCBiZSBjb25zdHJ1ZWRcbiAgICAgICAgICBhcyBtb2RpZnlpbmcgdGhlIExpY2Vuc2UuXG5cbiAgICAgIFlvdSBtYXkgYWRkIFlvdXIgb3duIGNvcHlyaWdodCBzdGF0ZW1lbnQgdG8gWW91ciBtb2RpZmljYXRpb25zIGFuZFxuICAgICAgbWF5IHByb3ZpZGUgYWRkaXRpb25hbCBvciBkaWZmZXJlbnQgbGljZW5zZSB0ZXJtcyBhbmQgY29uZGl0aW9uc1xuICAgICAgZm9yIHVzZSwgcmVwcm9kdWN0aW9uLCBvciBkaXN0cmlidXRpb24gb2YgWW91ciBtb2RpZmljYXRpb25zLCBvclxuICAgICAgZm9yIGFueSBzdWNoIERlcml2YXRpdmUgV29ya3MgYXMgYSB3aG9sZSwgcHJvdmlkZWQgWW91ciB1c2UsXG4gICAgICByZXByb2R1Y3Rpb24sIGFuZCBkaXN0cmlidXRpb24gb2YgdGhlIFdvcmsgb3RoZXJ3aXNlIGNvbXBsaWVzIHdpdGhcbiAgICAgIHRoZSBjb25kaXRpb25zIHN0YXRlZCBpbiB0aGlzIExpY2Vuc2UuXG5cbiAgIDUuIFN1Ym1pc3Npb24gb2YgQ29udHJpYnV0aW9ucy4gVW5sZXNzIFlvdSBleHBsaWNpdGx5IHN0YXRlIG90aGVyd2lzZSxcbiAgICAgIGFueSBDb250cmlidXRpb24gaW50ZW50aW9uYWxseSBzdWJtaXR0ZWQgZm9yIGluY2x1c2lvbiBpbiB0aGUgV29ya1xuICAgICAgYnkgWW91IHRvIHRoZSBMaWNlbnNvciBzaGFsbCBiZSB1bmRlciB0aGUgdGVybXMgYW5kIGNvbmRpdGlvbnMgb2ZcbiAgICAgIHRoaXMgTGljZW5zZSwgd2l0aG91dCBhbnkgYWRkaXRpb25hbCB0ZXJtcyBvciBjb25kaXRpb25zLlxuICAgICAgTm90d2l0aHN0YW5kaW5nIHRoZSBhYm92ZSwgbm90aGluZyBoZXJlaW4gc2hhbGwgc3VwZXJzZWRlIG9yIG1vZGlmeVxuICAgICAgdGhlIHRlcm1zIG9mIGFueSBzZXBhcmF0ZSBsaWNlbnNlIGFncmVlbWVudCB5b3UgbWF5IGhhdmUgZXhlY3V0ZWRcbiAgICAgIHdpdGggTGljZW5zb3IgcmVnYXJkaW5nIHN1Y2ggQ29udHJpYnV0aW9ucy5cblxuICAgNi4gVHJhZGVtYXJrcy4gVGhpcyBMaWNlbnNlIGRvZXMgbm90IGdyYW50IHBlcm1pc3Npb24gdG8gdXNlIHRoZSB0cmFkZVxuICAgICAgbmFtZXMsIHRyYWRlbWFya3MsIHNlcnZpY2UgbWFya3MsIG9yIHByb2R1Y3QgbmFtZXMgb2YgdGhlIExpY2Vuc29yLFxuICAgICAgZXhjZXB0IGFzIHJlcXVpcmVkIGZvciByZWFzb25hYmxlIGFuZCBjdXN0b21hcnkgdXNlIGluIGRlc2NyaWJpbmcgdGhlXG4gICAgICBvcmlnaW4gb2YgdGhlIFdvcmsgYW5kIHJlcHJvZHVjaW5nIHRoZSBjb250ZW50IG9mIHRoZSBOT1RJQ0UgZmlsZS5cblxuICAgNy4gRGlzY2xhaW1lciBvZiBXYXJyYW50eS4gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yXG4gICAgICBhZ3JlZWQgdG8gaW4gd3JpdGluZywgTGljZW5zb3IgcHJvdmlkZXMgdGhlIFdvcmsgKGFuZCBlYWNoXG4gICAgICBDb250cmlidXRvciBwcm92aWRlcyBpdHMgQ29udHJpYnV0aW9ucykgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICAgICAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yXG4gICAgICBpbXBsaWVkLCBpbmNsdWRpbmcsIHdpdGhvdXQgbGltaXRhdGlvbiwgYW55IHdhcnJhbnRpZXMgb3IgY29uZGl0aW9uc1xuICAgICAgb2YgVElUTEUsIE5PTi1JTkZSSU5HRU1FTlQsIE1FUkNIQU5UQUJJTElUWSwgb3IgRklUTkVTUyBGT1IgQVxuICAgICAgUEFSVElDVUxBUiBQVVJQT1NFLiBZb3UgYXJlIHNvbGVseSByZXNwb25zaWJsZSBmb3IgZGV0ZXJtaW5pbmcgdGhlXG4gICAgICBhcHByb3ByaWF0ZW5lc3Mgb2YgdXNpbmcgb3IgcmVkaXN0cmlidXRpbmcgdGhlIFdvcmsgYW5kIGFzc3VtZSBhbnlcbiAgICAgIHJpc2tzIGFzc29jaWF0ZWQgd2l0aCBZb3VyIGV4ZXJjaXNlIG9mIHBlcm1pc3Npb25zIHVuZGVyIHRoaXMgTGljZW5zZS5cblxuICAgOC4gTGltaXRhdGlvbiBvZiBMaWFiaWxpdHkuIEluIG5vIGV2ZW50IGFuZCB1bmRlciBubyBsZWdhbCB0aGVvcnksXG4gICAgICB3aGV0aGVyIGluIHRvcnQgKGluY2x1ZGluZyBuZWdsaWdlbmNlKSwgY29udHJhY3QsIG9yIG90aGVyd2lzZSxcbiAgICAgIHVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyAoc3VjaCBhcyBkZWxpYmVyYXRlIGFuZCBncm9zc2x5XG4gICAgICBuZWdsaWdlbnQgYWN0cykgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNoYWxsIGFueSBDb250cmlidXRvciBiZVxuICAgICAgbGlhYmxlIHRvIFlvdSBmb3IgZGFtYWdlcywgaW5jbHVkaW5nIGFueSBkaXJlY3QsIGluZGlyZWN0LCBzcGVjaWFsLFxuICAgICAgaW5jaWRlbnRhbCwgb3IgY29uc2VxdWVudGlhbCBkYW1hZ2VzIG9mIGFueSBjaGFyYWN0ZXIgYXJpc2luZyBhcyBhXG4gICAgICByZXN1bHQgb2YgdGhpcyBMaWNlbnNlIG9yIG91dCBvZiB0aGUgdXNlIG9yIGluYWJpbGl0eSB0byB1c2UgdGhlXG4gICAgICBXb3JrIChpbmNsdWRpbmcgYnV0IG5vdCBsaW1pdGVkIHRvIGRhbWFnZXMgZm9yIGxvc3Mgb2YgZ29vZHdpbGwsXG4gICAgICB3b3JrIHN0b3BwYWdlLCBjb21wdXRlciBmYWlsdXJlIG9yIG1hbGZ1bmN0aW9uLCBvciBhbnkgYW5kIGFsbFxuICAgICAgb3RoZXIgY29tbWVyY2lhbCBkYW1hZ2VzIG9yIGxvc3NlcyksIGV2ZW4gaWYgc3VjaCBDb250cmlidXRvclxuICAgICAgaGFzIGJlZW4gYWR2aXNlZCBvZiB0aGUgcG9zc2liaWxpdHkgb2Ygc3VjaCBkYW1hZ2VzLlxuXG4gICA5LiBBY2NlcHRpbmcgV2FycmFudHkgb3IgQWRkaXRpb25hbCBMaWFiaWxpdHkuIFdoaWxlIHJlZGlzdHJpYnV0aW5nXG4gICAgICB0aGUgV29yayBvciBEZXJpdmF0aXZlIFdvcmtzIHRoZXJlb2YsIFlvdSBtYXkgY2hvb3NlIHRvIG9mZmVyLFxuICAgICAgYW5kIGNoYXJnZSBhIGZlZSBmb3IsIGFjY2VwdGFuY2Ugb2Ygc3VwcG9ydCwgd2FycmFudHksIGluZGVtbml0eSxcbiAgICAgIG9yIG90aGVyIGxpYWJpbGl0eSBvYmxpZ2F0aW9ucyBhbmQvb3IgcmlnaHRzIGNvbnNpc3RlbnQgd2l0aCB0aGlzXG4gICAgICBMaWNlbnNlLiBIb3dldmVyLCBpbiBhY2NlcHRpbmcgc3VjaCBvYmxpZ2F0aW9ucywgWW91IG1heSBhY3Qgb25seVxuICAgICAgb24gWW91ciBvd24gYmVoYWxmIGFuZCBvbiBZb3VyIHNvbGUgcmVzcG9uc2liaWxpdHksIG5vdCBvbiBiZWhhbGZcbiAgICAgIG9mIGFueSBvdGhlciBDb250cmlidXRvciwgYW5kIG9ubHkgaWYgWW91IGFncmVlIHRvIGluZGVtbmlmeSxcbiAgICAgIGRlZmVuZCwgYW5kIGhvbGQgZWFjaCBDb250cmlidXRvciBoYXJtbGVzcyBmb3IgYW55IGxpYWJpbGl0eVxuICAgICAgaW5jdXJyZWQgYnksIG9yIGNsYWltcyBhc3NlcnRlZCBhZ2FpbnN0LCBzdWNoIENvbnRyaWJ1dG9yIGJ5IHJlYXNvblxuICAgICAgb2YgeW91ciBhY2NlcHRpbmcgYW55IHN1Y2ggd2FycmFudHkgb3IgYWRkaXRpb25hbCBsaWFiaWxpdHkuXG5cbiAgIEVORCBPRiBURVJNUyBBTkQgQ09ORElUSU9OU1xuXG4gICBBUFBFTkRJWDogSG93IHRvIGFwcGx5IHRoZSBBcGFjaGUgTGljZW5zZSB0byB5b3VyIHdvcmsuXG5cbiAgICAgIFRvIGFwcGx5IHRoZSBBcGFjaGUgTGljZW5zZSB0byB5b3VyIHdvcmssIGF0dGFjaCB0aGUgZm9sbG93aW5nXG4gICAgICBib2lsZXJwbGF0ZSBub3RpY2UsIHdpdGggdGhlIGZpZWxkcyBlbmNsb3NlZCBieSBicmFja2V0cyBcInt9XCJcbiAgICAgIHJlcGxhY2VkIHdpdGggeW91ciBvd24gaWRlbnRpZnlpbmcgaW5mb3JtYXRpb24uIChEb24ndCBpbmNsdWRlXG4gICAgICB0aGUgYnJhY2tldHMhKSAgVGhlIHRleHQgc2hvdWxkIGJlIGVuY2xvc2VkIGluIHRoZSBhcHByb3ByaWF0ZVxuICAgICAgY29tbWVudCBzeW50YXggZm9yIHRoZSBmaWxlIGZvcm1hdC4gV2UgYWxzbyByZWNvbW1lbmQgdGhhdCBhXG4gICAgICBmaWxlIG9yIGNsYXNzIG5hbWUgYW5kIGRlc2NyaXB0aW9uIG9mIHB1cnBvc2UgYmUgaW5jbHVkZWQgb24gdGhlXG4gICAgICBzYW1lIFwicHJpbnRlZCBwYWdlXCIgYXMgdGhlIGNvcHlyaWdodCBub3RpY2UgZm9yIGVhc2llclxuICAgICAgaWRlbnRpZmljYXRpb24gd2l0aGluIHRoaXJkLXBhcnR5IGFyY2hpdmVzLlxuXG4gICBDb3B5cmlnaHQge3l5eXl9IHtuYW1lIG9mIGNvcHlyaWdodCBvd25lcn1cblxuICAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAgIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5TVkQuc3ZkID0gZnVuY3Rpb24gKEEpIHtcbiAgdGhpcy5VID0gbnVsbDtcbiAgdGhpcy5WID0gbnVsbDtcbiAgdGhpcy5zID0gbnVsbDtcbiAgdGhpcy5tID0gMDtcbiAgdGhpcy5uID0gMDtcbiAgdGhpcy5tID0gQS5sZW5ndGg7XG4gIHRoaXMubiA9IEFbMF0ubGVuZ3RoO1xuICB2YXIgbnUgPSBNYXRoLm1pbih0aGlzLm0sIHRoaXMubik7XG4gIHRoaXMucyA9IGZ1bmN0aW9uIChzKSB7XG4gICAgdmFyIGEgPSBbXTtcbiAgICB3aGlsZSAocy0tID4gMCkge1xuICAgICAgYS5wdXNoKDApO1xuICAgIH1yZXR1cm4gYTtcbiAgfShNYXRoLm1pbih0aGlzLm0gKyAxLCB0aGlzLm4pKTtcbiAgdGhpcy5VID0gZnVuY3Rpb24gKGRpbXMpIHtcbiAgICB2YXIgYWxsb2NhdGUgPSBmdW5jdGlvbiBhbGxvY2F0ZShkaW1zKSB7XG4gICAgICBpZiAoZGltcy5sZW5ndGggPT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbXNbMF07IGkrKykge1xuICAgICAgICAgIGFycmF5LnB1c2goYWxsb2NhdGUoZGltcy5zbGljZSgxKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBhbGxvY2F0ZShkaW1zKTtcbiAgfShbdGhpcy5tLCBudV0pO1xuICB0aGlzLlYgPSBmdW5jdGlvbiAoZGltcykge1xuICAgIHZhciBhbGxvY2F0ZSA9IGZ1bmN0aW9uIGFsbG9jYXRlKGRpbXMpIHtcbiAgICAgIGlmIChkaW1zLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltc1swXTsgaSsrKSB7XG4gICAgICAgICAgYXJyYXkucHVzaChhbGxvY2F0ZShkaW1zLnNsaWNlKDEpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGFsbG9jYXRlKGRpbXMpO1xuICB9KFt0aGlzLm4sIHRoaXMubl0pO1xuICB2YXIgZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgdmFyIGEgPSBbXTtcbiAgICB3aGlsZSAocy0tID4gMCkge1xuICAgICAgYS5wdXNoKDApO1xuICAgIH1yZXR1cm4gYTtcbiAgfSh0aGlzLm4pO1xuICB2YXIgd29yayA9IGZ1bmN0aW9uIChzKSB7XG4gICAgdmFyIGEgPSBbXTtcbiAgICB3aGlsZSAocy0tID4gMCkge1xuICAgICAgYS5wdXNoKDApO1xuICAgIH1yZXR1cm4gYTtcbiAgfSh0aGlzLm0pO1xuICB2YXIgd2FudHUgPSB0cnVlO1xuICB2YXIgd2FudHYgPSB0cnVlO1xuICB2YXIgbmN0ID0gTWF0aC5taW4odGhpcy5tIC0gMSwgdGhpcy5uKTtcbiAgdmFyIG5ydCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMubiAtIDIsIHRoaXMubSkpO1xuICBmb3IgKHZhciBrID0gMDsgayA8IE1hdGgubWF4KG5jdCwgbnJ0KTsgaysrKSB7XG4gICAgaWYgKGsgPCBuY3QpIHtcbiAgICAgIHRoaXMuc1trXSA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gazsgaSA8IHRoaXMubTsgaSsrKSB7XG4gICAgICAgIHRoaXMuc1trXSA9IFNWRC5oeXBvdCh0aGlzLnNba10sIEFbaV1ba10pO1xuICAgICAgfVxuICAgICAgO1xuICAgICAgaWYgKHRoaXMuc1trXSAhPT0gMC4wKSB7XG4gICAgICAgIGlmIChBW2tdW2tdIDwgMC4wKSB7XG4gICAgICAgICAgdGhpcy5zW2tdID0gLXRoaXMuc1trXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfaSA9IGs7IF9pIDwgdGhpcy5tOyBfaSsrKSB7XG4gICAgICAgICAgQVtfaV1ba10gLz0gdGhpcy5zW2tdO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgQVtrXVtrXSArPSAxLjA7XG4gICAgICB9XG4gICAgICB0aGlzLnNba10gPSAtdGhpcy5zW2tdO1xuICAgIH1cbiAgICBmb3IgKHZhciBqID0gayArIDE7IGogPCB0aGlzLm47IGorKykge1xuICAgICAgaWYgKGZ1bmN0aW9uIChsaHMsIHJocykge1xuICAgICAgICByZXR1cm4gbGhzICYmIHJocztcbiAgICAgIH0oayA8IG5jdCwgdGhpcy5zW2tdICE9PSAwLjApKSB7XG4gICAgICAgIHZhciB0ID0gMDtcbiAgICAgICAgZm9yICh2YXIgX2kyID0gazsgX2kyIDwgdGhpcy5tOyBfaTIrKykge1xuICAgICAgICAgIHQgKz0gQVtfaTJdW2tdICogQVtfaTJdW2pdO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgdCA9IC10IC8gQVtrXVtrXTtcbiAgICAgICAgZm9yICh2YXIgX2kzID0gazsgX2kzIDwgdGhpcy5tOyBfaTMrKykge1xuICAgICAgICAgIEFbX2kzXVtqXSArPSB0ICogQVtfaTNdW2tdO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgIH1cbiAgICAgIGVbal0gPSBBW2tdW2pdO1xuICAgIH1cbiAgICA7XG4gICAgaWYgKGZ1bmN0aW9uIChsaHMsIHJocykge1xuICAgICAgcmV0dXJuIGxocyAmJiByaHM7XG4gICAgfSh3YW50dSwgayA8IG5jdCkpIHtcbiAgICAgIGZvciAodmFyIF9pNCA9IGs7IF9pNCA8IHRoaXMubTsgX2k0KyspIHtcbiAgICAgICAgdGhpcy5VW19pNF1ba10gPSBBW19pNF1ba107XG4gICAgICB9XG4gICAgICA7XG4gICAgfVxuICAgIGlmIChrIDwgbnJ0KSB7XG4gICAgICBlW2tdID0gMDtcbiAgICAgIGZvciAodmFyIF9pNSA9IGsgKyAxOyBfaTUgPCB0aGlzLm47IF9pNSsrKSB7XG4gICAgICAgIGVba10gPSBTVkQuaHlwb3QoZVtrXSwgZVtfaTVdKTtcbiAgICAgIH1cbiAgICAgIDtcbiAgICAgIGlmIChlW2tdICE9PSAwLjApIHtcbiAgICAgICAgaWYgKGVbayArIDFdIDwgMC4wKSB7XG4gICAgICAgICAgZVtrXSA9IC1lW2tdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9pNiA9IGsgKyAxOyBfaTYgPCB0aGlzLm47IF9pNisrKSB7XG4gICAgICAgICAgZVtfaTZdIC89IGVba107XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICBlW2sgKyAxXSArPSAxLjA7XG4gICAgICB9XG4gICAgICBlW2tdID0gLWVba107XG4gICAgICBpZiAoZnVuY3Rpb24gKGxocywgcmhzKSB7XG4gICAgICAgIHJldHVybiBsaHMgJiYgcmhzO1xuICAgICAgfShrICsgMSA8IHRoaXMubSwgZVtrXSAhPT0gMC4wKSkge1xuICAgICAgICBmb3IgKHZhciBfaTcgPSBrICsgMTsgX2k3IDwgdGhpcy5tOyBfaTcrKykge1xuICAgICAgICAgIHdvcmtbX2k3XSA9IDAuMDtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIGZvciAodmFyIF9qID0gayArIDE7IF9qIDwgdGhpcy5uOyBfaisrKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2k4ID0gayArIDE7IF9pOCA8IHRoaXMubTsgX2k4KyspIHtcbiAgICAgICAgICAgIHdvcmtbX2k4XSArPSBlW19qXSAqIEFbX2k4XVtfal07XG4gICAgICAgICAgfVxuICAgICAgICAgIDtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIGZvciAodmFyIF9qMiA9IGsgKyAxOyBfajIgPCB0aGlzLm47IF9qMisrKSB7XG4gICAgICAgICAgdmFyIF90ID0gLWVbX2oyXSAvIGVbayArIDFdO1xuICAgICAgICAgIGZvciAodmFyIF9pOSA9IGsgKyAxOyBfaTkgPCB0aGlzLm07IF9pOSsrKSB7XG4gICAgICAgICAgICBBW19pOV1bX2oyXSArPSBfdCAqIHdvcmtbX2k5XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgO1xuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgIH1cbiAgICAgIGlmICh3YW50dikge1xuICAgICAgICBmb3IgKHZhciBfaTEwID0gayArIDE7IF9pMTAgPCB0aGlzLm47IF9pMTArKykge1xuICAgICAgICAgIHRoaXMuVltfaTEwXVtrXSA9IGVbX2kxMF07XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgcCA9IE1hdGgubWluKHRoaXMubiwgdGhpcy5tICsgMSk7XG4gIGlmIChuY3QgPCB0aGlzLm4pIHtcbiAgICB0aGlzLnNbbmN0XSA9IEFbbmN0XVtuY3RdO1xuICB9XG4gIGlmICh0aGlzLm0gPCBwKSB7XG4gICAgdGhpcy5zW3AgLSAxXSA9IDAuMDtcbiAgfVxuICBpZiAobnJ0ICsgMSA8IHApIHtcbiAgICBlW25ydF0gPSBBW25ydF1bcCAtIDFdO1xuICB9XG4gIGVbcCAtIDFdID0gMC4wO1xuICBpZiAod2FudHUpIHtcbiAgICBmb3IgKHZhciBfajMgPSBuY3Q7IF9qMyA8IG51OyBfajMrKykge1xuICAgICAgZm9yICh2YXIgX2kxMSA9IDA7IF9pMTEgPCB0aGlzLm07IF9pMTErKykge1xuICAgICAgICB0aGlzLlVbX2kxMV1bX2ozXSA9IDAuMDtcbiAgICAgIH1cbiAgICAgIDtcbiAgICAgIHRoaXMuVVtfajNdW19qM10gPSAxLjA7XG4gICAgfTtcbiAgICBmb3IgKHZhciBfayA9IG5jdCAtIDE7IF9rID49IDA7IF9rLS0pIHtcbiAgICAgIGlmICh0aGlzLnNbX2tdICE9PSAwLjApIHtcbiAgICAgICAgZm9yICh2YXIgX2o0ID0gX2sgKyAxOyBfajQgPCBudTsgX2o0KyspIHtcbiAgICAgICAgICB2YXIgX3QyID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBfaTEyID0gX2s7IF9pMTIgPCB0aGlzLm07IF9pMTIrKykge1xuICAgICAgICAgICAgX3QyICs9IHRoaXMuVVtfaTEyXVtfa10gKiB0aGlzLlVbX2kxMl1bX2o0XTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIF90MiA9IC1fdDIgLyB0aGlzLlVbX2tdW19rXTtcbiAgICAgICAgICBmb3IgKHZhciBfaTEzID0gX2s7IF9pMTMgPCB0aGlzLm07IF9pMTMrKykge1xuICAgICAgICAgICAgdGhpcy5VW19pMTNdW19qNF0gKz0gX3QyICogdGhpcy5VW19pMTNdW19rXTtcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBfaTE0ID0gX2s7IF9pMTQgPCB0aGlzLm07IF9pMTQrKykge1xuICAgICAgICAgIHRoaXMuVVtfaTE0XVtfa10gPSAtdGhpcy5VW19pMTRdW19rXTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5VW19rXVtfa10gPSAxLjAgKyB0aGlzLlVbX2tdW19rXTtcbiAgICAgICAgZm9yICh2YXIgX2kxNSA9IDA7IF9pMTUgPCBfayAtIDE7IF9pMTUrKykge1xuICAgICAgICAgIHRoaXMuVVtfaTE1XVtfa10gPSAwLjA7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBfaTE2ID0gMDsgX2kxNiA8IHRoaXMubTsgX2kxNisrKSB7XG4gICAgICAgICAgdGhpcy5VW19pMTZdW19rXSA9IDAuMDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5VW19rXVtfa10gPSAxLjA7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBpZiAod2FudHYpIHtcbiAgICBmb3IgKHZhciBfazIgPSB0aGlzLm4gLSAxOyBfazIgPj0gMDsgX2syLS0pIHtcbiAgICAgIGlmIChmdW5jdGlvbiAobGhzLCByaHMpIHtcbiAgICAgICAgcmV0dXJuIGxocyAmJiByaHM7XG4gICAgICB9KF9rMiA8IG5ydCwgZVtfazJdICE9PSAwLjApKSB7XG4gICAgICAgIGZvciAodmFyIF9qNSA9IF9rMiArIDE7IF9qNSA8IG51OyBfajUrKykge1xuICAgICAgICAgIHZhciBfdDMgPSAwO1xuICAgICAgICAgIGZvciAodmFyIF9pMTcgPSBfazIgKyAxOyBfaTE3IDwgdGhpcy5uOyBfaTE3KyspIHtcbiAgICAgICAgICAgIF90MyArPSB0aGlzLlZbX2kxN11bX2syXSAqIHRoaXMuVltfaTE3XVtfajVdO1xuICAgICAgICAgIH07XG4gICAgICAgICAgX3QzID0gLV90MyAvIHRoaXMuVltfazIgKyAxXVtfazJdO1xuICAgICAgICAgIGZvciAodmFyIF9pMTggPSBfazIgKyAxOyBfaTE4IDwgdGhpcy5uOyBfaTE4KyspIHtcbiAgICAgICAgICAgIHRoaXMuVltfaTE4XVtfajVdICs9IF90MyAqIHRoaXMuVltfaTE4XVtfazJdO1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfaTE5ID0gMDsgX2kxOSA8IHRoaXMubjsgX2kxOSsrKSB7XG4gICAgICAgIHRoaXMuVltfaTE5XVtfazJdID0gMC4wO1xuICAgICAgfTtcbiAgICAgIHRoaXMuVltfazJdW19rMl0gPSAxLjA7XG4gICAgfTtcbiAgfVxuICB2YXIgcHAgPSBwIC0gMTtcbiAgdmFyIGl0ZXIgPSAwO1xuICB2YXIgZXBzID0gTWF0aC5wb3coMi4wLCAtNTIuMCk7XG4gIHZhciB0aW55ID0gTWF0aC5wb3coMi4wLCAtOTY2LjApO1xuICB3aGlsZSAocCA+IDApIHtcbiAgICB2YXIgX2szID0gdm9pZCAwO1xuICAgIHZhciBrYXNlID0gdm9pZCAwO1xuICAgIGZvciAoX2szID0gcCAtIDI7IF9rMyA+PSAtMTsgX2szLS0pIHtcbiAgICAgIGlmIChfazMgPT09IC0xKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKE1hdGguYWJzKGVbX2szXSkgPD0gdGlueSArIGVwcyAqIChNYXRoLmFicyh0aGlzLnNbX2szXSkgKyBNYXRoLmFicyh0aGlzLnNbX2szICsgMV0pKSkge1xuICAgICAgICBlW19rM10gPSAwLjA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKF9rMyA9PT0gcCAtIDIpIHtcbiAgICAgIGthc2UgPSA0O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga3MgPSB2b2lkIDA7XG4gICAgICBmb3IgKGtzID0gcCAtIDE7IGtzID49IF9rMzsga3MtLSkge1xuICAgICAgICBpZiAoa3MgPT09IF9rMykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfdDQgPSAoa3MgIT09IHAgPyBNYXRoLmFicyhlW2tzXSkgOiAwLjApICsgKGtzICE9PSBfazMgKyAxID8gTWF0aC5hYnMoZVtrcyAtIDFdKSA6IDAuMCk7XG4gICAgICAgIGlmIChNYXRoLmFicyh0aGlzLnNba3NdKSA8PSB0aW55ICsgZXBzICogX3Q0KSB7XG4gICAgICAgICAgdGhpcy5zW2tzXSA9IDAuMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChrcyA9PT0gX2szKSB7XG4gICAgICAgIGthc2UgPSAzO1xuICAgICAgfSBlbHNlIGlmIChrcyA9PT0gcCAtIDEpIHtcbiAgICAgICAga2FzZSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrYXNlID0gMjtcbiAgICAgICAgX2szID0ga3M7XG4gICAgICB9XG4gICAgfVxuICAgIF9rMysrO1xuICAgIHN3aXRjaCAoa2FzZSkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGYgPSBlW3AgLSAyXTtcbiAgICAgICAgICBlW3AgLSAyXSA9IDAuMDtcbiAgICAgICAgICBmb3IgKHZhciBfajYgPSBwIC0gMjsgX2o2ID49IF9rMzsgX2o2LS0pIHtcbiAgICAgICAgICAgIHZhciBfdDUgPSBTVkQuaHlwb3QodGhpcy5zW19qNl0sIGYpO1xuICAgICAgICAgICAgdmFyIGNzID0gdGhpcy5zW19qNl0gLyBfdDU7XG4gICAgICAgICAgICB2YXIgc24gPSBmIC8gX3Q1O1xuICAgICAgICAgICAgdGhpcy5zW19qNl0gPSBfdDU7XG4gICAgICAgICAgICBpZiAoX2o2ICE9PSBfazMpIHtcbiAgICAgICAgICAgICAgZiA9IC1zbiAqIGVbX2o2IC0gMV07XG4gICAgICAgICAgICAgIGVbX2o2IC0gMV0gPSBjcyAqIGVbX2o2IC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2FudHYpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2kyMCA9IDA7IF9pMjAgPCB0aGlzLm47IF9pMjArKykge1xuICAgICAgICAgICAgICAgIF90NSA9IGNzICogdGhpcy5WW19pMjBdW19qNl0gKyBzbiAqIHRoaXMuVltfaTIwXVtwIC0gMV07XG4gICAgICAgICAgICAgICAgdGhpcy5WW19pMjBdW3AgLSAxXSA9IC1zbiAqIHRoaXMuVltfaTIwXVtfajZdICsgY3MgKiB0aGlzLlZbX2kyMF1bcCAtIDFdO1xuICAgICAgICAgICAgICAgIHRoaXMuVltfaTIwXVtfajZdID0gX3Q1O1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9mID0gZVtfazMgLSAxXTtcbiAgICAgICAgICBlW19rMyAtIDFdID0gMC4wO1xuICAgICAgICAgIGZvciAodmFyIF9qNyA9IF9rMzsgX2o3IDwgcDsgX2o3KyspIHtcbiAgICAgICAgICAgIHZhciBfdDYgPSBTVkQuaHlwb3QodGhpcy5zW19qN10sIF9mKTtcbiAgICAgICAgICAgIHZhciBfY3MgPSB0aGlzLnNbX2o3XSAvIF90NjtcbiAgICAgICAgICAgIHZhciBfc24gPSBfZiAvIF90NjtcbiAgICAgICAgICAgIHRoaXMuc1tfajddID0gX3Q2O1xuICAgICAgICAgICAgX2YgPSAtX3NuICogZVtfajddO1xuICAgICAgICAgICAgZVtfajddID0gX2NzICogZVtfajddO1xuICAgICAgICAgICAgaWYgKHdhbnR1KSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pMjEgPSAwOyBfaTIxIDwgdGhpcy5tOyBfaTIxKyspIHtcbiAgICAgICAgICAgICAgICBfdDYgPSBfY3MgKiB0aGlzLlVbX2kyMV1bX2o3XSArIF9zbiAqIHRoaXMuVVtfaTIxXVtfazMgLSAxXTtcbiAgICAgICAgICAgICAgICB0aGlzLlVbX2kyMV1bX2szIC0gMV0gPSAtX3NuICogdGhpcy5VW19pMjFdW19qN10gKyBfY3MgKiB0aGlzLlVbX2kyMV1bX2szIC0gMV07XG4gICAgICAgICAgICAgICAgdGhpcy5VW19pMjFdW19qN10gPSBfdDY7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgc2NhbGUgPSBNYXRoLm1heChNYXRoLm1heChNYXRoLm1heChNYXRoLm1heChNYXRoLmFicyh0aGlzLnNbcCAtIDFdKSwgTWF0aC5hYnModGhpcy5zW3AgLSAyXSkpLCBNYXRoLmFicyhlW3AgLSAyXSkpLCBNYXRoLmFicyh0aGlzLnNbX2szXSkpLCBNYXRoLmFicyhlW19rM10pKTtcbiAgICAgICAgICB2YXIgc3AgPSB0aGlzLnNbcCAtIDFdIC8gc2NhbGU7XG4gICAgICAgICAgdmFyIHNwbTEgPSB0aGlzLnNbcCAtIDJdIC8gc2NhbGU7XG4gICAgICAgICAgdmFyIGVwbTEgPSBlW3AgLSAyXSAvIHNjYWxlO1xuICAgICAgICAgIHZhciBzayA9IHRoaXMuc1tfazNdIC8gc2NhbGU7XG4gICAgICAgICAgdmFyIGVrID0gZVtfazNdIC8gc2NhbGU7XG4gICAgICAgICAgdmFyIGIgPSAoKHNwbTEgKyBzcCkgKiAoc3BtMSAtIHNwKSArIGVwbTEgKiBlcG0xKSAvIDIuMDtcbiAgICAgICAgICB2YXIgYyA9IHNwICogZXBtMSAqIChzcCAqIGVwbTEpO1xuICAgICAgICAgIHZhciBzaGlmdCA9IDAuMDtcbiAgICAgICAgICBpZiAoZnVuY3Rpb24gKGxocywgcmhzKSB7XG4gICAgICAgICAgICByZXR1cm4gbGhzIHx8IHJocztcbiAgICAgICAgICB9KGIgIT09IDAuMCwgYyAhPT0gMC4wKSkge1xuICAgICAgICAgICAgc2hpZnQgPSBNYXRoLnNxcnQoYiAqIGIgKyBjKTtcbiAgICAgICAgICAgIGlmIChiIDwgMC4wKSB7XG4gICAgICAgICAgICAgIHNoaWZ0ID0gLXNoaWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2hpZnQgPSBjIC8gKGIgKyBzaGlmdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBfZjIgPSAoc2sgKyBzcCkgKiAoc2sgLSBzcCkgKyBzaGlmdDtcbiAgICAgICAgICB2YXIgZyA9IHNrICogZWs7XG4gICAgICAgICAgZm9yICh2YXIgX2o4ID0gX2szOyBfajggPCBwIC0gMTsgX2o4KyspIHtcbiAgICAgICAgICAgIHZhciBfdDcgPSBTVkQuaHlwb3QoX2YyLCBnKTtcbiAgICAgICAgICAgIHZhciBfY3MyID0gX2YyIC8gX3Q3O1xuICAgICAgICAgICAgdmFyIF9zbjIgPSBnIC8gX3Q3O1xuICAgICAgICAgICAgaWYgKF9qOCAhPT0gX2szKSB7XG4gICAgICAgICAgICAgIGVbX2o4IC0gMV0gPSBfdDc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfZjIgPSBfY3MyICogdGhpcy5zW19qOF0gKyBfc24yICogZVtfajhdO1xuICAgICAgICAgICAgZVtfajhdID0gX2NzMiAqIGVbX2o4XSAtIF9zbjIgKiB0aGlzLnNbX2o4XTtcbiAgICAgICAgICAgIGcgPSBfc24yICogdGhpcy5zW19qOCArIDFdO1xuICAgICAgICAgICAgdGhpcy5zW19qOCArIDFdID0gX2NzMiAqIHRoaXMuc1tfajggKyAxXTtcbiAgICAgICAgICAgIGlmICh3YW50dikge1xuICAgICAgICAgICAgICBmb3IgKHZhciBfaTIyID0gMDsgX2kyMiA8IHRoaXMubjsgX2kyMisrKSB7XG4gICAgICAgICAgICAgICAgX3Q3ID0gX2NzMiAqIHRoaXMuVltfaTIyXVtfajhdICsgX3NuMiAqIHRoaXMuVltfaTIyXVtfajggKyAxXTtcbiAgICAgICAgICAgICAgICB0aGlzLlZbX2kyMl1bX2o4ICsgMV0gPSAtX3NuMiAqIHRoaXMuVltfaTIyXVtfajhdICsgX2NzMiAqIHRoaXMuVltfaTIyXVtfajggKyAxXTtcbiAgICAgICAgICAgICAgICB0aGlzLlZbX2kyMl1bX2o4XSA9IF90NztcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90NyA9IFNWRC5oeXBvdChfZjIsIGcpO1xuICAgICAgICAgICAgX2NzMiA9IF9mMiAvIF90NztcbiAgICAgICAgICAgIF9zbjIgPSBnIC8gX3Q3O1xuICAgICAgICAgICAgdGhpcy5zW19qOF0gPSBfdDc7XG4gICAgICAgICAgICBfZjIgPSBfY3MyICogZVtfajhdICsgX3NuMiAqIHRoaXMuc1tfajggKyAxXTtcbiAgICAgICAgICAgIHRoaXMuc1tfajggKyAxXSA9IC1fc24yICogZVtfajhdICsgX2NzMiAqIHRoaXMuc1tfajggKyAxXTtcbiAgICAgICAgICAgIGcgPSBfc24yICogZVtfajggKyAxXTtcbiAgICAgICAgICAgIGVbX2o4ICsgMV0gPSBfY3MyICogZVtfajggKyAxXTtcbiAgICAgICAgICAgIGlmICh3YW50dSAmJiBfajggPCB0aGlzLm0gLSAxKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pMjMgPSAwOyBfaTIzIDwgdGhpcy5tOyBfaTIzKyspIHtcbiAgICAgICAgICAgICAgICBfdDcgPSBfY3MyICogdGhpcy5VW19pMjNdW19qOF0gKyBfc24yICogdGhpcy5VW19pMjNdW19qOCArIDFdO1xuICAgICAgICAgICAgICAgIHRoaXMuVVtfaTIzXVtfajggKyAxXSA9IC1fc24yICogdGhpcy5VW19pMjNdW19qOF0gKyBfY3MyICogdGhpcy5VW19pMjNdW19qOCArIDFdO1xuICAgICAgICAgICAgICAgIHRoaXMuVVtfaTIzXVtfajhdID0gX3Q3O1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgZVtwIC0gMl0gPSBfZjI7XG4gICAgICAgICAgaXRlciA9IGl0ZXIgKyAxO1xuICAgICAgICB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0aGlzLnNbX2szXSA8PSAwLjApIHtcbiAgICAgICAgICAgIHRoaXMuc1tfazNdID0gdGhpcy5zW19rM10gPCAwLjAgPyAtdGhpcy5zW19rM10gOiAwLjA7XG4gICAgICAgICAgICBpZiAod2FudHYpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2kyNCA9IDA7IF9pMjQgPD0gcHA7IF9pMjQrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuVltfaTI0XVtfazNdID0gLXRoaXMuVltfaTI0XVtfazNdO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoX2szIDwgcHApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNbX2szXSA+PSB0aGlzLnNbX2szICsgMV0pIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX3Q4ID0gdGhpcy5zW19rM107XG4gICAgICAgICAgICB0aGlzLnNbX2szXSA9IHRoaXMuc1tfazMgKyAxXTtcbiAgICAgICAgICAgIHRoaXMuc1tfazMgKyAxXSA9IF90ODtcbiAgICAgICAgICAgIGlmICh3YW50diAmJiBfazMgPCB0aGlzLm4gLSAxKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIF9pMjUgPSAwOyBfaTI1IDwgdGhpcy5uOyBfaTI1KyspIHtcbiAgICAgICAgICAgICAgICBfdDggPSB0aGlzLlZbX2kyNV1bX2szICsgMV07XG4gICAgICAgICAgICAgICAgdGhpcy5WW19pMjVdW19rMyArIDFdID0gdGhpcy5WW19pMjVdW19rM107XG4gICAgICAgICAgICAgICAgdGhpcy5WW19pMjVdW19rM10gPSBfdDg7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2FudHUgJiYgX2szIDwgdGhpcy5tIC0gMSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBfaTI2ID0gMDsgX2kyNiA8IHRoaXMubTsgX2kyNisrKSB7XG4gICAgICAgICAgICAgICAgX3Q4ID0gdGhpcy5VW19pMjZdW19rMyArIDFdO1xuICAgICAgICAgICAgICAgIHRoaXMuVVtfaTI2XVtfazMgKyAxXSA9IHRoaXMuVVtfaTI2XVtfazNdO1xuICAgICAgICAgICAgICAgIHRoaXMuVVtfaTI2XVtfazNdID0gX3Q4O1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2szKys7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpdGVyID0gMDtcbiAgICAgICAgICBwLS07XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcbiAgdmFyIHJlc3VsdCA9IHsgVTogdGhpcy5VLCBWOiB0aGlzLlYsIFM6IHRoaXMucyB9O1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gc3FydChhXjIgKyBiXjIpIHdpdGhvdXQgdW5kZXIvb3ZlcmZsb3cuXG5TVkQuaHlwb3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICB2YXIgciA9IHZvaWQgMDtcbiAgaWYgKE1hdGguYWJzKGEpID4gTWF0aC5hYnMoYikpIHtcbiAgICByID0gYiAvIGE7XG4gICAgciA9IE1hdGguYWJzKGEpICogTWF0aC5zcXJ0KDEgKyByICogcik7XG4gIH0gZWxzZSBpZiAoYiAhPSAwKSB7XG4gICAgciA9IGEgLyBiO1xuICAgIHIgPSBNYXRoLmFicyhiKSAqIE1hdGguc3FydCgxICsgciAqIHIpO1xuICB9IGVsc2Uge1xuICAgIHIgPSAwLjA7XG4gIH1cbiAgcmV0dXJuIHI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNWRDtcblxuLyoqKi8gfSksXG4vKiAyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqICAgTmVlZGxlbWFuLVd1bnNjaCBhbGdvcml0aG0gaXMgYW4gcHJvY2VkdXJlIHRvIGNvbXB1dGUgdGhlIG9wdGltYWwgZ2xvYmFsIGFsaWdubWVudCBvZiB0d28gc3RyaW5nXG4gKiAgIHNlcXVlbmNlcyBieSBTLkIuTmVlZGxlbWFuIGFuZCBDLkQuV3Vuc2NoICgxOTcwKS5cbiAqXG4gKiAgIEFzaWRlIGZyb20gdGhlIGlucHV0cywgeW91IGNhbiBhc3NpZ24gdGhlIHNjb3JlcyBmb3IsXG4gKiAgIC0gTWF0Y2g6IFRoZSB0d28gY2hhcmFjdGVycyBhdCB0aGUgY3VycmVudCBpbmRleCBhcmUgc2FtZS5cbiAqICAgLSBNaXNtYXRjaDogVGhlIHR3byBjaGFyYWN0ZXJzIGF0IHRoZSBjdXJyZW50IGluZGV4IGFyZSBkaWZmZXJlbnQuXG4gKiAgIC0gSW5zZXJ0aW9uL0RlbGV0aW9uKGdhcHMpOiBUaGUgYmVzdCBhbGlnbm1lbnQgaW52b2x2ZXMgb25lIGxldHRlciBhbGlnbmluZyB0byBhIGdhcCBpbiB0aGUgb3RoZXIgc3RyaW5nLlxuICovXG5cbnZhciBOZWVkbGVtYW5XdW5zY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmVlZGxlbWFuV3Vuc2NoKHNlcXVlbmNlMSwgc2VxdWVuY2UyKSB7XG4gICAgICAgIHZhciBtYXRjaF9zY29yZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcbiAgICAgICAgdmFyIG1pc21hdGNoX3BlbmFsdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IC0xO1xuICAgICAgICB2YXIgZ2FwX3BlbmFsdHkgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IC0xO1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOZWVkbGVtYW5XdW5zY2gpO1xuXG4gICAgICAgIHRoaXMuc2VxdWVuY2UxID0gc2VxdWVuY2UxO1xuICAgICAgICB0aGlzLnNlcXVlbmNlMiA9IHNlcXVlbmNlMjtcbiAgICAgICAgdGhpcy5tYXRjaF9zY29yZSA9IG1hdGNoX3Njb3JlO1xuICAgICAgICB0aGlzLm1pc21hdGNoX3BlbmFsdHkgPSBtaXNtYXRjaF9wZW5hbHR5O1xuICAgICAgICB0aGlzLmdhcF9wZW5hbHR5ID0gZ2FwX3BlbmFsdHk7XG5cbiAgICAgICAgLy8gSnVzdCB0aGUgcmVtb3ZlIHJlZHVuZGFuY3lcbiAgICAgICAgdGhpcy5pTWF4ID0gc2VxdWVuY2UxLmxlbmd0aCArIDE7XG4gICAgICAgIHRoaXMuak1heCA9IHNlcXVlbmNlMi5sZW5ndGggKyAxO1xuXG4gICAgICAgIC8vIEdyaWQgbWF0cml4IG9mIHNjb3Jlc1xuICAgICAgICB0aGlzLmdyaWQgPSBuZXcgQXJyYXkodGhpcy5pTWF4KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmlNYXg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5ncmlkW2ldID0gbmV3IEFycmF5KHRoaXMuak1heCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5qTWF4OyBqKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWRbaV1bal0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJhY2ViYWNrIG1hdHJpeCAoMkQgYXJyYXksIGVhY2ggY2VsbCBpcyBhbiBhcnJheSBvZiBib29sZWFuIHZhbHVlcyBmb3IgW2BEaWFnYCwgYFVwYCwgYExlZnRgXSBwb3NpdGlvbnMpXG4gICAgICAgIHRoaXMudHJhY2ViYWNrR3JpZCA9IG5ldyBBcnJheSh0aGlzLmlNYXgpO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdGhpcy5pTWF4OyBfaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlYmFja0dyaWRbX2ldID0gbmV3IEFycmF5KHRoaXMuak1heCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCB0aGlzLmpNYXg7IF9qKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlYmFja0dyaWRbX2ldW19qXSA9IFtudWxsLCBudWxsLCBudWxsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBhbGlnbmVkIHNlcXVlbmNlcyAocmV0dXJuIG11bHRpcGxlIHBvc3NpYmlsaXRpZXMpXG4gICAgICAgIHRoaXMuYWxpZ25tZW50cyA9IFtdO1xuXG4gICAgICAgIC8vIEZpbmFsIGFsaWdubWVudCBzY29yZVxuICAgICAgICB0aGlzLnNjb3JlID0gLTE7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHNjb3JlcyBhbmQgdHJhY2ViYWNrc1xuICAgICAgICB0aGlzLmNvbXB1dGVHcmlkcygpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhOZWVkbGVtYW5XdW5zY2gsIFt7XG4gICAgICAgIGtleTogXCJnZXRTY29yZVwiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2NvcmUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY29yZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImdldEFsaWdubWVudHNcIixcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFsaWdubWVudHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbGlnbm1lbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFpbiBkeW5hbWljIHByb2dyYW1taW5nIHByb2NlZHVyZVxuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiY29tcHV0ZUdyaWRzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wdXRlR3JpZHMoKSB7XG4gICAgICAgICAgICAvLyBGaWxsIGluIHRoZSBmaXJzdCByb3dcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgdGhpcy5qTWF4OyBqKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWRbMF1bal0gPSB0aGlzLmdyaWRbMF1baiAtIDFdICsgdGhpcy5nYXBfcGVuYWx0eTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlYmFja0dyaWRbMF1bal0gPSBbZmFsc2UsIGZhbHNlLCB0cnVlXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRmlsbCBpbiB0aGUgZmlyc3QgY29sdW1uXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRoaXMuaU1heDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkW2ldWzBdID0gdGhpcy5ncmlkW2kgLSAxXVswXSArIHRoaXMuZ2FwX3BlbmFsdHk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZWJhY2tHcmlkW2ldWzBdID0gW2ZhbHNlLCB0cnVlLCBmYWxzZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpbGwgdGhlIHJlc3Qgb2YgdGhlIGdyaWRcbiAgICAgICAgICAgIGZvciAodmFyIF9pMiA9IDE7IF9pMiA8IHRoaXMuaU1heDsgX2kyKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfajIgPSAxOyBfajIgPCB0aGlzLmpNYXg7IF9qMisrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIG1heCBzY29yZShzKSBhbW9uZyBbYERpYWdgLCBgVXBgLCBgTGVmdGBdXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaWFnID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXF1ZW5jZTFbX2kyIC0gMV0gPT09IHRoaXMuc2VxdWVuY2UyW19qMiAtIDFdKSBkaWFnID0gdGhpcy5ncmlkW19pMiAtIDFdW19qMiAtIDFdICsgdGhpcy5tYXRjaF9zY29yZTtlbHNlIGRpYWcgPSB0aGlzLmdyaWRbX2kyIC0gMV1bX2oyIC0gMV0gKyB0aGlzLm1pc21hdGNoX3BlbmFsdHk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwID0gdGhpcy5ncmlkW19pMiAtIDFdW19qMl0gKyB0aGlzLmdhcF9wZW5hbHR5O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IHRoaXMuZ3JpZFtfaTJdW19qMiAtIDFdICsgdGhpcy5nYXBfcGVuYWx0eTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBleGlzdHMgbXVsdGlwbGUgbWF4IHZhbHVlcywgY2FwdHVyZSB0aGVtIGZvciBtdWx0aXBsZSBwYXRoc1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4T2YgPSBbZGlhZywgdXAsIGxlZnRdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kaWNlcyA9IHRoaXMuYXJyYXlBbGxNYXhJbmRleGVzKG1heE9mKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgR3JpZHNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmlkW19pMl1bX2oyXSA9IG1heE9mW2luZGljZXNbMF1dO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlYmFja0dyaWRbX2kyXVtfajJdID0gW2luZGljZXMuaW5jbHVkZXMoMCksIGluZGljZXMuaW5jbHVkZXMoMSksIGluZGljZXMuaW5jbHVkZXMoMildO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXBkYXRlIGFsaWdubWVudCBzY29yZVxuICAgICAgICAgICAgdGhpcy5zY29yZSA9IHRoaXMuZ3JpZFt0aGlzLmlNYXggLSAxXVt0aGlzLmpNYXggLSAxXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldHMgYWxsIHBvc3NpYmxlIHZhbGlkIHNlcXVlbmNlIGNvbWJpbmF0aW9uc1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6IFwiYWxpZ25tZW50VHJhY2ViYWNrXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhbGlnbm1lbnRUcmFjZWJhY2soKSB7XG4gICAgICAgICAgICB2YXIgaW5Qcm9jZXNzQWxpZ25tZW50cyA9IFtdO1xuXG4gICAgICAgICAgICBpblByb2Nlc3NBbGlnbm1lbnRzLnB1c2goeyBwb3M6IFt0aGlzLnNlcXVlbmNlMS5sZW5ndGgsIHRoaXMuc2VxdWVuY2UyLmxlbmd0aF0sXG4gICAgICAgICAgICAgICAgc2VxMTogXCJcIixcbiAgICAgICAgICAgICAgICBzZXEyOiBcIlwiXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgd2hpbGUgKGluUHJvY2Vzc0FsaWdubWVudHNbMF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudCA9IGluUHJvY2Vzc0FsaWdubWVudHNbMF07XG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvbnMgPSB0aGlzLnRyYWNlYmFja0dyaWRbY3VycmVudC5wb3NbMF1dW2N1cnJlbnQucG9zWzFdXTtcblxuICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25zWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIGluUHJvY2Vzc0FsaWdubWVudHMucHVzaCh7IHBvczogW2N1cnJlbnQucG9zWzBdIC0gMSwgY3VycmVudC5wb3NbMV0gLSAxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcTE6IHRoaXMuc2VxdWVuY2UxW2N1cnJlbnQucG9zWzBdIC0gMV0gKyBjdXJyZW50LnNlcTEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXEyOiB0aGlzLnNlcXVlbmNlMltjdXJyZW50LnBvc1sxXSAtIDFdICsgY3VycmVudC5zZXEyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICBpblByb2Nlc3NBbGlnbm1lbnRzLnB1c2goeyBwb3M6IFtjdXJyZW50LnBvc1swXSAtIDEsIGN1cnJlbnQucG9zWzFdXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcTE6IHRoaXMuc2VxdWVuY2UxW2N1cnJlbnQucG9zWzBdIC0gMV0gKyBjdXJyZW50LnNlcTEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXEyOiAnLScgKyBjdXJyZW50LnNlcTJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25zWzJdKSB7XG4gICAgICAgICAgICAgICAgICAgIGluUHJvY2Vzc0FsaWdubWVudHMucHVzaCh7IHBvczogW2N1cnJlbnQucG9zWzBdLCBjdXJyZW50LnBvc1sxXSAtIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxMTogJy0nICsgY3VycmVudC5zZXExLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VxMjogdGhpcy5zZXF1ZW5jZTJbY3VycmVudC5wb3NbMV0gLSAxXSArIGN1cnJlbnQuc2VxMlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5wb3NbMF0gPT09IDAgJiYgY3VycmVudC5wb3NbMV0gPT09IDApIHRoaXMuYWxpZ25tZW50cy5wdXNoKHsgc2VxdWVuY2UxOiBjdXJyZW50LnNlcTEsXG4gICAgICAgICAgICAgICAgICAgIHNlcXVlbmNlMjogY3VycmVudC5zZXEyXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpblByb2Nlc3NBbGlnbm1lbnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFsaWdubWVudHM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIZWxwZXIgRnVuY3Rpb25zXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogXCJnZXRBbGxJbmRleGVzXCIsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBbGxJbmRleGVzKGFyciwgdmFsKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXhlcyA9IFtdLFxuICAgICAgICAgICAgICAgIGkgPSAtMTtcbiAgICAgICAgICAgIHdoaWxlICgoaSA9IGFyci5pbmRleE9mKHZhbCwgaSArIDEpKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpbmRleGVzLnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5kZXhlcztcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiBcImFycmF5QWxsTWF4SW5kZXhlc1wiLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXJyYXlBbGxNYXhJbmRleGVzKGFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBbGxJbmRleGVzKGFycmF5LCBNYXRoLm1heC5hcHBseShudWxsLCBhcnJheSkpO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIE5lZWRsZW1hbld1bnNjaDtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBOZWVkbGVtYW5XdW5zY2g7XG5cbi8qKiovIH0pLFxuLyogMjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIGxheW91dEJhc2UgPSBmdW5jdGlvbiBsYXlvdXRCYXNlKCkge1xuICByZXR1cm47XG59O1xuXG5sYXlvdXRCYXNlLkZETGF5b3V0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG5sYXlvdXRCYXNlLkZETGF5b3V0Q29uc3RhbnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbmxheW91dEJhc2UuRkRMYXlvdXRFZGdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5sYXlvdXRCYXNlLkZETGF5b3V0Tm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xubGF5b3V0QmFzZS5EaW1lbnNpb25EID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG5sYXlvdXRCYXNlLkhhc2hNYXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcbmxheW91dEJhc2UuSGFzaFNldCA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xubGF5b3V0QmFzZS5JR2VvbWV0cnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xubGF5b3V0QmFzZS5JTWF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5sYXlvdXRCYXNlLkludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcbmxheW91dEJhc2UuUG9pbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcbmxheW91dEJhc2UuUG9pbnREID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbmxheW91dEJhc2UuUmFuZG9tU2VlZCA9IF9fd2VicGFja19yZXF1aXJlX18oMTYpO1xubGF5b3V0QmFzZS5SZWN0YW5nbGVEID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5sYXlvdXRCYXNlLlRyYW5zZm9ybSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xubGF5b3V0QmFzZS5VbmlxdWVJREdlbmVyZXRvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xubGF5b3V0QmFzZS5RdWlja3NvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcbmxheW91dEJhc2UuTGlua2VkTGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xubGF5b3V0QmFzZS5MR3JhcGhPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xubGF5b3V0QmFzZS5MR3JhcGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xubGF5b3V0QmFzZS5MRWRnZSA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5sYXlvdXRCYXNlLkxHcmFwaE1hbmFnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xubGF5b3V0QmFzZS5MTm9kZSA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5sYXlvdXRCYXNlLkxheW91dCA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xubGF5b3V0QmFzZS5MYXlvdXRDb25zdGFudHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xubGF5b3V0QmFzZS5OZWVkbGVtYW5XdW5zY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcbmxheW91dEJhc2UuTWF0cml4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5sYXlvdXRCYXNlLlNWRCA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxheW91dEJhc2U7XG5cbi8qKiovIH0pLFxuLyogMjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gRW1pdHRlcigpIHtcbiAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbn1cblxudmFyIHAgPSBFbWl0dGVyLnByb3RvdHlwZTtcblxucC5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2spIHtcbiAgdGhpcy5saXN0ZW5lcnMucHVzaCh7XG4gICAgZXZlbnQ6IGV2ZW50LFxuICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICB9KTtcbn07XG5cbnAucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQsIGNhbGxiYWNrKSB7XG4gIGZvciAodmFyIGkgPSB0aGlzLmxpc3RlbmVycy5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGwgPSB0aGlzLmxpc3RlbmVyc1tpXTtcblxuICAgIGlmIChsLmV2ZW50ID09PSBldmVudCAmJiBsLmNhbGxiYWNrID09PSBjYWxsYmFjaykge1xuICAgICAgdGhpcy5saXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxufTtcblxucC5lbWl0ID0gZnVuY3Rpb24gKGV2ZW50LCBkYXRhKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbCA9IHRoaXMubGlzdGVuZXJzW2ldO1xuXG4gICAgaWYgKGV2ZW50ID09PSBsLmV2ZW50KSB7XG4gICAgICBsLmNhbGxiYWNrKGRhdGEpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/cytoscape-fcose/node_modules/layout-base/layout-base.js\n");

/***/ }),

/***/ "./node_modules/mermaid/dist/chunks/mermaid.core/architectureDiagram-UYN6MBPD.mjs":
/*!****************************************************************************************!*\
  !*** ./node_modules/mermaid/dist/chunks/mermaid.core/architectureDiagram-UYN6MBPD.mjs ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   diagram: () => (/* binding */ diagram)\n/* harmony export */ });\n/* harmony import */ var _chunk_OPO4IU42_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-OPO4IU42.mjs */ \"./node_modules/mermaid/dist/chunks/mermaid.core/chunk-OPO4IU42.mjs\");\n/* harmony import */ var _chunk_6JOS74DS_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-6JOS74DS.mjs */ \"./node_modules/mermaid/dist/chunks/mermaid.core/chunk-6JOS74DS.mjs\");\n/* harmony import */ var _chunk_TMUBEWPD_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-TMUBEWPD.mjs */ \"./node_modules/mermaid/dist/chunks/mermaid.core/chunk-TMUBEWPD.mjs\");\n/* harmony import */ var _chunk_KFBOBJHC_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chunk-KFBOBJHC.mjs */ \"./node_modules/mermaid/dist/chunks/mermaid.core/chunk-KFBOBJHC.mjs\");\n/* harmony import */ var _chunk_7DKRZKHE_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./chunk-7DKRZKHE.mjs */ \"./node_modules/mermaid/dist/chunks/mermaid.core/chunk-7DKRZKHE.mjs\");\n/* harmony import */ var _chunk_EJ4ZWXGL_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./chunk-EJ4ZWXGL.mjs */ \"./node_modules/mermaid/dist/chunks/mermaid.core/chunk-EJ4ZWXGL.mjs\");\n/* harmony import */ var _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./chunk-6DBFFHIP.mjs */ \"./node_modules/mermaid/dist/chunks/mermaid.core/chunk-6DBFFHIP.mjs\");\n/* harmony import */ var _mermaid_js_parser__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @mermaid-js/parser */ \"./node_modules/@mermaid-js/parser/dist/mermaid-parser.core.mjs\");\n/* harmony import */ var cytoscape__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! cytoscape */ \"./node_modules/cytoscape/dist/cytoscape.esm.mjs\");\n/* harmony import */ var cytoscape_fcose__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! cytoscape-fcose */ \"./node_modules/cytoscape-fcose/cytoscape-fcose.js\");\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3 */ \"./node_modules/d3/src/index.js\");\n\n\n\n\n\n\n\n\n// src/diagrams/architecture/architectureParser.ts\n\n\n// src/diagrams/architecture/architectureTypes.ts\nvar ArchitectureDirectionName = {\n  L: \"left\",\n  R: \"right\",\n  T: \"top\",\n  B: \"bottom\"\n};\nvar ArchitectureDirectionArrow = {\n  L: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((scale) => `${scale},${scale / 2} 0,${scale} 0,0`, \"L\"),\n  R: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((scale) => `0,${scale / 2} ${scale},0 ${scale},${scale}`, \"R\"),\n  T: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((scale) => `0,0 ${scale},0 ${scale / 2},${scale}`, \"T\"),\n  B: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((scale) => `${scale / 2},0 ${scale},${scale} 0,${scale}`, \"B\")\n};\nvar ArchitectureDirectionArrowShift = {\n  L: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((orig, arrowSize) => orig - arrowSize + 2, \"L\"),\n  R: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((orig, _arrowSize) => orig - 2, \"R\"),\n  T: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((orig, arrowSize) => orig - arrowSize + 2, \"T\"),\n  B: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((orig, _arrowSize) => orig - 2, \"B\")\n};\nvar getOppositeArchitectureDirection = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function(x) {\n  if (isArchitectureDirectionX(x)) {\n    return x === \"L\" ? \"R\" : \"L\";\n  } else {\n    return x === \"T\" ? \"B\" : \"T\";\n  }\n}, \"getOppositeArchitectureDirection\");\nvar isArchitectureDirection = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function(x) {\n  const temp = x;\n  return temp === \"L\" || temp === \"R\" || temp === \"T\" || temp === \"B\";\n}, \"isArchitectureDirection\");\nvar isArchitectureDirectionX = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function(x) {\n  const temp = x;\n  return temp === \"L\" || temp === \"R\";\n}, \"isArchitectureDirectionX\");\nvar isArchitectureDirectionY = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function(x) {\n  const temp = x;\n  return temp === \"T\" || temp === \"B\";\n}, \"isArchitectureDirectionY\");\nvar isArchitectureDirectionXY = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function(a, b) {\n  const aX_bY = isArchitectureDirectionX(a) && isArchitectureDirectionY(b);\n  const aY_bX = isArchitectureDirectionY(a) && isArchitectureDirectionX(b);\n  return aX_bY || aY_bX;\n}, \"isArchitectureDirectionXY\");\nvar isArchitecturePairXY = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function(pair) {\n  const lhs = pair[0];\n  const rhs = pair[1];\n  const aX_bY = isArchitectureDirectionX(lhs) && isArchitectureDirectionY(rhs);\n  const aY_bX = isArchitectureDirectionY(lhs) && isArchitectureDirectionX(rhs);\n  return aX_bY || aY_bX;\n}, \"isArchitecturePairXY\");\nvar isValidArchitectureDirectionPair = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function(x) {\n  return x !== \"LL\" && x !== \"RR\" && x !== \"TT\" && x !== \"BB\";\n}, \"isValidArchitectureDirectionPair\");\nvar getArchitectureDirectionPair = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function(sourceDir, targetDir) {\n  const pair = `${sourceDir}${targetDir}`;\n  return isValidArchitectureDirectionPair(pair) ? pair : void 0;\n}, \"getArchitectureDirectionPair\");\nvar shiftPositionByArchitectureDirectionPair = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function([x, y], pair) {\n  const lhs = pair[0];\n  const rhs = pair[1];\n  if (isArchitectureDirectionX(lhs)) {\n    if (isArchitectureDirectionY(rhs)) {\n      return [x + (lhs === \"L\" ? -1 : 1), y + (rhs === \"T\" ? 1 : -1)];\n    } else {\n      return [x + (lhs === \"L\" ? -1 : 1), y];\n    }\n  } else {\n    if (isArchitectureDirectionX(rhs)) {\n      return [x + (rhs === \"L\" ? 1 : -1), y + (lhs === \"T\" ? 1 : -1)];\n    } else {\n      return [x, y + (lhs === \"T\" ? 1 : -1)];\n    }\n  }\n}, \"shiftPositionByArchitectureDirectionPair\");\nvar getArchitectureDirectionXYFactors = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function(pair) {\n  if (pair === \"LT\" || pair === \"TL\") {\n    return [1, 1];\n  } else if (pair === \"BL\" || pair === \"LB\") {\n    return [1, -1];\n  } else if (pair === \"BR\" || pair === \"RB\") {\n    return [-1, -1];\n  } else {\n    return [-1, 1];\n  }\n}, \"getArchitectureDirectionXYFactors\");\nvar isArchitectureService = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function(x) {\n  const temp = x;\n  return temp.type === \"service\";\n}, \"isArchitectureService\");\nvar isArchitectureJunction = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function(x) {\n  const temp = x;\n  return temp.type === \"junction\";\n}, \"isArchitectureJunction\");\nvar edgeData = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((edge) => {\n  return edge.data();\n}, \"edgeData\");\nvar nodeData = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((node) => {\n  return node.data();\n}, \"nodeData\");\n\n// src/diagrams/architecture/architectureDb.ts\nvar DEFAULT_ARCHITECTURE_CONFIG = _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.defaultConfig_default.architecture;\nvar state = new _chunk_KFBOBJHC_mjs__WEBPACK_IMPORTED_MODULE_3__.ImperativeState(() => ({\n  nodes: {},\n  groups: {},\n  edges: [],\n  registeredIds: {},\n  config: DEFAULT_ARCHITECTURE_CONFIG,\n  dataStructures: void 0,\n  elements: {}\n}));\nvar clear2 = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(() => {\n  state.reset();\n  (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.clear)();\n}, \"clear\");\nvar addService = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function({\n  id,\n  icon,\n  in: parent,\n  title,\n  iconText\n}) {\n  if (state.records.registeredIds[id] !== void 0) {\n    throw new Error(\n      `The service id [${id}] is already in use by another ${state.records.registeredIds[id]}`\n    );\n  }\n  if (parent !== void 0) {\n    if (id === parent) {\n      throw new Error(`The service [${id}] cannot be placed within itself`);\n    }\n    if (state.records.registeredIds[parent] === void 0) {\n      throw new Error(\n        `The service [${id}]'s parent does not exist. Please make sure the parent is created before this service`\n      );\n    }\n    if (state.records.registeredIds[parent] === \"node\") {\n      throw new Error(`The service [${id}]'s parent is not a group`);\n    }\n  }\n  state.records.registeredIds[id] = \"node\";\n  state.records.nodes[id] = {\n    id,\n    type: \"service\",\n    icon,\n    iconText,\n    title,\n    edges: [],\n    in: parent\n  };\n}, \"addService\");\nvar getServices = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(() => Object.values(state.records.nodes).filter(isArchitectureService), \"getServices\");\nvar addJunction = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function({ id, in: parent }) {\n  state.records.registeredIds[id] = \"node\";\n  state.records.nodes[id] = {\n    id,\n    type: \"junction\",\n    edges: [],\n    in: parent\n  };\n}, \"addJunction\");\nvar getJunctions = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(() => Object.values(state.records.nodes).filter(isArchitectureJunction), \"getJunctions\");\nvar getNodes = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(() => Object.values(state.records.nodes), \"getNodes\");\nvar getNode = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((id) => state.records.nodes[id], \"getNode\");\nvar addGroup = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function({ id, icon, in: parent, title }) {\n  if (state.records.registeredIds[id] !== void 0) {\n    throw new Error(\n      `The group id [${id}] is already in use by another ${state.records.registeredIds[id]}`\n    );\n  }\n  if (parent !== void 0) {\n    if (id === parent) {\n      throw new Error(`The group [${id}] cannot be placed within itself`);\n    }\n    if (state.records.registeredIds[parent] === void 0) {\n      throw new Error(\n        `The group [${id}]'s parent does not exist. Please make sure the parent is created before this group`\n      );\n    }\n    if (state.records.registeredIds[parent] === \"node\") {\n      throw new Error(`The group [${id}]'s parent is not a group`);\n    }\n  }\n  state.records.registeredIds[id] = \"group\";\n  state.records.groups[id] = {\n    id,\n    icon,\n    title,\n    in: parent\n  };\n}, \"addGroup\");\nvar getGroups = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(() => {\n  return Object.values(state.records.groups);\n}, \"getGroups\");\nvar addEdge = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function({\n  lhsId,\n  rhsId,\n  lhsDir,\n  rhsDir,\n  lhsInto,\n  rhsInto,\n  lhsGroup,\n  rhsGroup,\n  title\n}) {\n  if (!isArchitectureDirection(lhsDir)) {\n    throw new Error(\n      `Invalid direction given for left hand side of edge ${lhsId}--${rhsId}. Expected (L,R,T,B) got ${lhsDir}`\n    );\n  }\n  if (!isArchitectureDirection(rhsDir)) {\n    throw new Error(\n      `Invalid direction given for right hand side of edge ${lhsId}--${rhsId}. Expected (L,R,T,B) got ${rhsDir}`\n    );\n  }\n  if (state.records.nodes[lhsId] === void 0 && state.records.groups[lhsId] === void 0) {\n    throw new Error(\n      `The left-hand id [${lhsId}] does not yet exist. Please create the service/group before declaring an edge to it.`\n    );\n  }\n  if (state.records.nodes[rhsId] === void 0 && state.records.groups[lhsId] === void 0) {\n    throw new Error(\n      `The right-hand id [${rhsId}] does not yet exist. Please create the service/group before declaring an edge to it.`\n    );\n  }\n  const lhsGroupId = state.records.nodes[lhsId].in;\n  const rhsGroupId = state.records.nodes[rhsId].in;\n  if (lhsGroup && lhsGroupId && rhsGroupId && lhsGroupId == rhsGroupId) {\n    throw new Error(\n      `The left-hand id [${lhsId}] is modified to traverse the group boundary, but the edge does not pass through two groups.`\n    );\n  }\n  if (rhsGroup && lhsGroupId && rhsGroupId && lhsGroupId == rhsGroupId) {\n    throw new Error(\n      `The right-hand id [${rhsId}] is modified to traverse the group boundary, but the edge does not pass through two groups.`\n    );\n  }\n  const edge = {\n    lhsId,\n    lhsDir,\n    lhsInto,\n    lhsGroup,\n    rhsId,\n    rhsDir,\n    rhsInto,\n    rhsGroup,\n    title\n  };\n  state.records.edges.push(edge);\n  if (state.records.nodes[lhsId] && state.records.nodes[rhsId]) {\n    state.records.nodes[lhsId].edges.push(state.records.edges[state.records.edges.length - 1]);\n    state.records.nodes[rhsId].edges.push(state.records.edges[state.records.edges.length - 1]);\n  }\n}, \"addEdge\");\nvar getEdges = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(() => state.records.edges, \"getEdges\");\nvar getDataStructures = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(() => {\n  if (state.records.dataStructures === void 0) {\n    const adjList = Object.entries(state.records.nodes).reduce((prevOuter, [id, service]) => {\n      prevOuter[id] = service.edges.reduce((prevInner, edge) => {\n        if (edge.lhsId === id) {\n          const pair = getArchitectureDirectionPair(edge.lhsDir, edge.rhsDir);\n          if (pair) {\n            prevInner[pair] = edge.rhsId;\n          }\n        } else {\n          const pair = getArchitectureDirectionPair(edge.rhsDir, edge.lhsDir);\n          if (pair) {\n            prevInner[pair] = edge.lhsId;\n          }\n        }\n        return prevInner;\n      }, {});\n      return prevOuter;\n    }, {});\n    const firstId = Object.keys(adjList)[0];\n    const visited = { [firstId]: 1 };\n    const notVisited = Object.keys(adjList).reduce(\n      (prev, id) => id === firstId ? prev : { ...prev, [id]: 1 },\n      {}\n    );\n    const BFS = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((startingId) => {\n      const spatialMap = { [startingId]: [0, 0] };\n      const queue = [startingId];\n      while (queue.length > 0) {\n        const id = queue.shift();\n        if (id) {\n          visited[id] = 1;\n          delete notVisited[id];\n          const adj = adjList[id];\n          const [posX, posY] = spatialMap[id];\n          Object.entries(adj).forEach(([dir, rhsId]) => {\n            if (!visited[rhsId]) {\n              spatialMap[rhsId] = shiftPositionByArchitectureDirectionPair(\n                [posX, posY],\n                dir\n              );\n              queue.push(rhsId);\n            }\n          });\n        }\n      }\n      return spatialMap;\n    }, \"BFS\");\n    const spatialMaps = [BFS(firstId)];\n    while (Object.keys(notVisited).length > 0) {\n      spatialMaps.push(BFS(Object.keys(notVisited)[0]));\n    }\n    state.records.dataStructures = {\n      adjList,\n      spatialMaps\n    };\n  }\n  return state.records.dataStructures;\n}, \"getDataStructures\");\nvar setElementForId = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((id, element) => {\n  state.records.elements[id] = element;\n}, \"setElementForId\");\nvar getElementById = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((id) => state.records.elements[id], \"getElementById\");\nvar db = {\n  clear: clear2,\n  setDiagramTitle: _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.setDiagramTitle,\n  getDiagramTitle: _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.getDiagramTitle,\n  setAccTitle: _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.setAccTitle,\n  getAccTitle: _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.getAccTitle,\n  setAccDescription: _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.setAccDescription,\n  getAccDescription: _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.getAccDescription,\n  addService,\n  getServices,\n  addJunction,\n  getJunctions,\n  getNodes,\n  getNode,\n  addGroup,\n  getGroups,\n  addEdge,\n  getEdges,\n  setElementForId,\n  getElementById,\n  getDataStructures\n};\nfunction getConfigField(field) {\n  const arch = (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.getConfig2)().architecture;\n  if (arch?.[field]) {\n    return arch[field];\n  }\n  return DEFAULT_ARCHITECTURE_CONFIG[field];\n}\n(0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(getConfigField, \"getConfigField\");\n\n// src/diagrams/architecture/architectureParser.ts\nvar populateDb = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((ast, db2) => {\n  (0,_chunk_TMUBEWPD_mjs__WEBPACK_IMPORTED_MODULE_2__.populateCommonDb)(ast, db2);\n  ast.groups.map(db2.addGroup);\n  ast.services.map((service) => db2.addService({ ...service, type: \"service\" }));\n  ast.junctions.map((service) => db2.addJunction({ ...service, type: \"junction\" }));\n  ast.edges.map(db2.addEdge);\n}, \"populateDb\");\nvar parser = {\n  parse: /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(async (input) => {\n    const ast = await (0,_mermaid_js_parser__WEBPACK_IMPORTED_MODULE_7__.parse)(\"architecture\", input);\n    _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.log.debug(ast);\n    populateDb(ast, db);\n  }, \"parse\")\n};\n\n// src/diagrams/architecture/architectureStyles.ts\nvar getStyles = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((options) => `\n  .edge {\n    stroke-width: ${options.archEdgeWidth};\n    stroke: ${options.archEdgeColor};\n    fill: none;\n  }\n\n  .arrow {\n    fill: ${options.archEdgeArrowColor};\n  }\n\n  .node-bkg {\n    fill: none;\n    stroke: ${options.archGroupBorderColor};\n    stroke-width: ${options.archGroupBorderWidth};\n    stroke-dasharray: 8;\n  }\n  .node-icon-text {\n    display: flex; \n    align-items: center;\n  }\n  \n  .node-icon-text > div {\n    color: #fff;\n    margin: 1px;\n    height: fit-content;\n    text-align: center;\n    overflow: hidden;\n    display: -webkit-box;\n    -webkit-box-orient: vertical;\n  }\n`, \"getStyles\");\nvar architectureStyles_default = getStyles;\n\n// src/diagrams/architecture/architectureRenderer.ts\n\n\n\n\n// src/diagrams/architecture/architectureIcons.ts\nvar wrapIcon = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((icon) => {\n  return `<g><rect width=\"80\" height=\"80\" style=\"fill: #087ebf; stroke-width: 0px;\"/>${icon}</g>`;\n}, \"wrapIcon\");\nvar architectureIcons = {\n  prefix: \"mermaid-architecture\",\n  height: 80,\n  width: 80,\n  icons: {\n    database: {\n      body: wrapIcon(\n        '<path id=\"b\" data-name=\"4\" d=\"m20,57.86c0,3.94,8.95,7.14,20,7.14s20-3.2,20-7.14\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><path id=\"c\" data-name=\"3\" d=\"m20,45.95c0,3.94,8.95,7.14,20,7.14s20-3.2,20-7.14\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><path id=\"d\" data-name=\"2\" d=\"m20,34.05c0,3.94,8.95,7.14,20,7.14s20-3.2,20-7.14\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><ellipse id=\"e\" data-name=\"1\" cx=\"40\" cy=\"22.14\" rx=\"20\" ry=\"7.14\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"20\" y1=\"57.86\" x2=\"20\" y2=\"22.14\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"60\" y1=\"57.86\" x2=\"60\" y2=\"22.14\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/>'\n      )\n    },\n    server: {\n      body: wrapIcon(\n        '<rect x=\"17.5\" y=\"17.5\" width=\"45\" height=\"45\" rx=\"2\" ry=\"2\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"17.5\" y1=\"32.5\" x2=\"62.5\" y2=\"32.5\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"17.5\" y1=\"47.5\" x2=\"62.5\" y2=\"47.5\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><g><path d=\"m56.25,25c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z\" style=\"fill: #fff; stroke-width: 0px;\"/><path d=\"m56.25,25c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10;\"/></g><g><path d=\"m56.25,40c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z\" style=\"fill: #fff; stroke-width: 0px;\"/><path d=\"m56.25,40c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10;\"/></g><g><path d=\"m56.25,55c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z\" style=\"fill: #fff; stroke-width: 0px;\"/><path d=\"m56.25,55c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10;\"/></g><g><circle cx=\"32.5\" cy=\"25\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/><circle cx=\"27.5\" cy=\"25\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/><circle cx=\"22.5\" cy=\"25\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/></g><g><circle cx=\"32.5\" cy=\"40\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/><circle cx=\"27.5\" cy=\"40\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/><circle cx=\"22.5\" cy=\"40\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/></g><g><circle cx=\"32.5\" cy=\"55\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/><circle cx=\"27.5\" cy=\"55\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/><circle cx=\"22.5\" cy=\"55\" r=\".75\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10;\"/></g>'\n      )\n    },\n    disk: {\n      body: wrapIcon(\n        '<rect x=\"20\" y=\"15\" width=\"40\" height=\"50\" rx=\"1\" ry=\"1\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><ellipse cx=\"24\" cy=\"19.17\" rx=\".8\" ry=\".83\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><ellipse cx=\"56\" cy=\"19.17\" rx=\".8\" ry=\".83\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><ellipse cx=\"24\" cy=\"60.83\" rx=\".8\" ry=\".83\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><ellipse cx=\"56\" cy=\"60.83\" rx=\".8\" ry=\".83\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><ellipse cx=\"40\" cy=\"33.75\" rx=\"14\" ry=\"14.58\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><ellipse cx=\"40\" cy=\"33.75\" rx=\"4\" ry=\"4.17\" style=\"fill: #fff; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><path d=\"m37.51,42.52l-4.83,13.22c-.26.71-1.1,1.02-1.76.64l-4.18-2.42c-.66-.38-.81-1.26-.33-1.84l9.01-10.8c.88-1.05,2.56-.08,2.09,1.2Z\" style=\"fill: #fff; stroke-width: 0px;\"/>'\n      )\n    },\n    internet: {\n      body: wrapIcon(\n        '<circle cx=\"40\" cy=\"40\" r=\"22.5\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"40\" y1=\"17.5\" x2=\"40\" y2=\"62.5\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"17.5\" y1=\"40\" x2=\"62.5\" y2=\"40\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><path d=\"m39.99,17.51c-15.28,11.1-15.28,33.88,0,44.98\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><path d=\"m40.01,17.51c15.28,11.1,15.28,33.88,0,44.98\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"19.75\" y1=\"30.1\" x2=\"60.25\" y2=\"30.1\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/><line x1=\"19.75\" y1=\"49.9\" x2=\"60.25\" y2=\"49.9\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/>'\n      )\n    },\n    cloud: {\n      body: wrapIcon(\n        '<path d=\"m65,47.5c0,2.76-2.24,5-5,5H20c-2.76,0-5-2.24-5-5,0-1.87,1.03-3.51,2.56-4.36-.04-.21-.06-.42-.06-.64,0-2.6,2.48-4.74,5.65-4.97,1.65-4.51,6.34-7.76,11.85-7.76.86,0,1.69.08,2.5.23,2.09-1.57,4.69-2.5,7.5-2.5,6.1,0,11.19,4.38,12.28,10.17,2.14.56,3.72,2.51,3.72,4.83,0,.03,0,.07-.01.1,2.29.46,4.01,2.48,4.01,4.9Z\" style=\"fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;\"/>'\n      )\n    },\n    unknown: _chunk_OPO4IU42_mjs__WEBPACK_IMPORTED_MODULE_0__.unknownIcon,\n    blank: {\n      body: wrapIcon(\"\")\n    }\n  }\n};\n\n// src/diagrams/architecture/svgDraw.ts\nvar drawEdges = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(async function(edgesEl, cy) {\n  const padding = getConfigField(\"padding\");\n  const iconSize = getConfigField(\"iconSize\");\n  const halfIconSize = iconSize / 2;\n  const arrowSize = iconSize / 6;\n  const halfArrowSize = arrowSize / 2;\n  await Promise.all(\n    cy.edges().map(async (edge) => {\n      const {\n        source,\n        sourceDir,\n        sourceArrow,\n        sourceGroup,\n        target,\n        targetDir,\n        targetArrow,\n        targetGroup,\n        label\n      } = edgeData(edge);\n      let { x: startX, y: startY } = edge[0].sourceEndpoint();\n      const { x: midX, y: midY } = edge[0].midpoint();\n      let { x: endX, y: endY } = edge[0].targetEndpoint();\n      const groupEdgeShift = padding + 4;\n      if (sourceGroup) {\n        if (isArchitectureDirectionX(sourceDir)) {\n          startX += sourceDir === \"L\" ? -groupEdgeShift : groupEdgeShift;\n        } else {\n          startY += sourceDir === \"T\" ? -groupEdgeShift : groupEdgeShift + 18;\n        }\n      }\n      if (targetGroup) {\n        if (isArchitectureDirectionX(targetDir)) {\n          endX += targetDir === \"L\" ? -groupEdgeShift : groupEdgeShift;\n        } else {\n          endY += targetDir === \"T\" ? -groupEdgeShift : groupEdgeShift + 18;\n        }\n      }\n      if (!sourceGroup && db.getNode(source)?.type === \"junction\") {\n        if (isArchitectureDirectionX(sourceDir)) {\n          startX += sourceDir === \"L\" ? halfIconSize : -halfIconSize;\n        } else {\n          startY += sourceDir === \"T\" ? halfIconSize : -halfIconSize;\n        }\n      }\n      if (!targetGroup && db.getNode(target)?.type === \"junction\") {\n        if (isArchitectureDirectionX(targetDir)) {\n          endX += targetDir === \"L\" ? halfIconSize : -halfIconSize;\n        } else {\n          endY += targetDir === \"T\" ? halfIconSize : -halfIconSize;\n        }\n      }\n      if (edge[0]._private.rscratch) {\n        const g = edgesEl.insert(\"g\");\n        g.insert(\"path\").attr(\"d\", `M ${startX},${startY} L ${midX},${midY} L${endX},${endY} `).attr(\"class\", \"edge\");\n        if (sourceArrow) {\n          const xShift = isArchitectureDirectionX(sourceDir) ? ArchitectureDirectionArrowShift[sourceDir](startX, arrowSize) : startX - halfArrowSize;\n          const yShift = isArchitectureDirectionY(sourceDir) ? ArchitectureDirectionArrowShift[sourceDir](startY, arrowSize) : startY - halfArrowSize;\n          g.insert(\"polygon\").attr(\"points\", ArchitectureDirectionArrow[sourceDir](arrowSize)).attr(\"transform\", `translate(${xShift},${yShift})`).attr(\"class\", \"arrow\");\n        }\n        if (targetArrow) {\n          const xShift = isArchitectureDirectionX(targetDir) ? ArchitectureDirectionArrowShift[targetDir](endX, arrowSize) : endX - halfArrowSize;\n          const yShift = isArchitectureDirectionY(targetDir) ? ArchitectureDirectionArrowShift[targetDir](endY, arrowSize) : endY - halfArrowSize;\n          g.insert(\"polygon\").attr(\"points\", ArchitectureDirectionArrow[targetDir](arrowSize)).attr(\"transform\", `translate(${xShift},${yShift})`).attr(\"class\", \"arrow\");\n        }\n        if (label) {\n          const axis = !isArchitectureDirectionXY(sourceDir, targetDir) ? isArchitectureDirectionX(sourceDir) ? \"X\" : \"Y\" : \"XY\";\n          let width = 0;\n          if (axis === \"X\") {\n            width = Math.abs(startX - endX);\n          } else if (axis === \"Y\") {\n            width = Math.abs(startY - endY) / 1.5;\n          } else {\n            width = Math.abs(startX - endX) / 2;\n          }\n          const textElem = g.append(\"g\");\n          await (0,_chunk_6JOS74DS_mjs__WEBPACK_IMPORTED_MODULE_1__.createText)(\n            textElem,\n            label,\n            {\n              useHtmlLabels: false,\n              width,\n              classes: \"architecture-service-label\"\n            },\n            (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.getConfig2)()\n          );\n          textElem.attr(\"dy\", \"1em\").attr(\"alignment-baseline\", \"middle\").attr(\"dominant-baseline\", \"middle\").attr(\"text-anchor\", \"middle\");\n          if (axis === \"X\") {\n            textElem.attr(\"transform\", \"translate(\" + midX + \", \" + midY + \")\");\n          } else if (axis === \"Y\") {\n            textElem.attr(\"transform\", \"translate(\" + midX + \", \" + midY + \") rotate(-90)\");\n          } else if (axis === \"XY\") {\n            const pair = getArchitectureDirectionPair(sourceDir, targetDir);\n            if (pair && isArchitecturePairXY(pair)) {\n              const bboxOrig = textElem.node().getBoundingClientRect();\n              const [x, y] = getArchitectureDirectionXYFactors(pair);\n              textElem.attr(\"dominant-baseline\", \"auto\").attr(\"transform\", `rotate(${-1 * x * y * 45})`);\n              const bboxNew = textElem.node().getBoundingClientRect();\n              textElem.attr(\n                \"transform\",\n                `\n                translate(${midX}, ${midY - bboxOrig.height / 2})\n                translate(${x * bboxNew.width / 2}, ${y * bboxNew.height / 2})\n                rotate(${-1 * x * y * 45}, 0, ${bboxOrig.height / 2})\n              `\n              );\n            }\n          }\n        }\n      }\n    })\n  );\n}, \"drawEdges\");\nvar drawGroups = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(async function(groupsEl, cy) {\n  const padding = getConfigField(\"padding\");\n  const groupIconSize = padding * 0.75;\n  const fontSize = getConfigField(\"fontSize\");\n  const iconSize = getConfigField(\"iconSize\");\n  const halfIconSize = iconSize / 2;\n  await Promise.all(\n    cy.nodes().map(async (node) => {\n      const data = nodeData(node);\n      if (data.type === \"group\") {\n        const { h, w, x1, y1 } = node.boundingBox();\n        groupsEl.append(\"rect\").attr(\"x\", x1 + halfIconSize).attr(\"y\", y1 + halfIconSize).attr(\"width\", w).attr(\"height\", h).attr(\"class\", \"node-bkg\");\n        const groupLabelContainer = groupsEl.append(\"g\");\n        let shiftedX1 = x1;\n        let shiftedY1 = y1;\n        if (data.icon) {\n          const bkgElem = groupLabelContainer.append(\"g\");\n          bkgElem.html(\n            `<g>${await (0,_chunk_OPO4IU42_mjs__WEBPACK_IMPORTED_MODULE_0__.getIconSVG)(data.icon, { height: groupIconSize, width: groupIconSize, fallbackPrefix: architectureIcons.prefix })}</g>`\n          );\n          bkgElem.attr(\n            \"transform\",\n            \"translate(\" + (shiftedX1 + halfIconSize + 1) + \", \" + (shiftedY1 + halfIconSize + 1) + \")\"\n          );\n          shiftedX1 += groupIconSize;\n          shiftedY1 += fontSize / 2 - 1 - 2;\n        }\n        if (data.label) {\n          const textElem = groupLabelContainer.append(\"g\");\n          await (0,_chunk_6JOS74DS_mjs__WEBPACK_IMPORTED_MODULE_1__.createText)(\n            textElem,\n            data.label,\n            {\n              useHtmlLabels: false,\n              width: w,\n              classes: \"architecture-service-label\"\n            },\n            (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.getConfig2)()\n          );\n          textElem.attr(\"dy\", \"1em\").attr(\"alignment-baseline\", \"middle\").attr(\"dominant-baseline\", \"start\").attr(\"text-anchor\", \"start\");\n          textElem.attr(\n            \"transform\",\n            \"translate(\" + (shiftedX1 + halfIconSize + 4) + \", \" + (shiftedY1 + halfIconSize + 2) + \")\"\n          );\n        }\n      }\n    })\n  );\n}, \"drawGroups\");\nvar drawServices = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(async function(db2, elem, services) {\n  for (const service of services) {\n    const serviceElem = elem.append(\"g\");\n    const iconSize = getConfigField(\"iconSize\");\n    if (service.title) {\n      const textElem = serviceElem.append(\"g\");\n      await (0,_chunk_6JOS74DS_mjs__WEBPACK_IMPORTED_MODULE_1__.createText)(\n        textElem,\n        service.title,\n        {\n          useHtmlLabels: false,\n          width: iconSize * 1.5,\n          classes: \"architecture-service-label\"\n        },\n        (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.getConfig2)()\n      );\n      textElem.attr(\"dy\", \"1em\").attr(\"alignment-baseline\", \"middle\").attr(\"dominant-baseline\", \"middle\").attr(\"text-anchor\", \"middle\");\n      textElem.attr(\"transform\", \"translate(\" + iconSize / 2 + \", \" + iconSize + \")\");\n    }\n    const bkgElem = serviceElem.append(\"g\");\n    if (service.icon) {\n      bkgElem.html(\n        `<g>${await (0,_chunk_OPO4IU42_mjs__WEBPACK_IMPORTED_MODULE_0__.getIconSVG)(service.icon, { height: iconSize, width: iconSize, fallbackPrefix: architectureIcons.prefix })}</g>`\n      );\n    } else if (service.iconText) {\n      bkgElem.html(\n        `<g>${await (0,_chunk_OPO4IU42_mjs__WEBPACK_IMPORTED_MODULE_0__.getIconSVG)(\"blank\", { height: iconSize, width: iconSize, fallbackPrefix: architectureIcons.prefix })}</g>`\n      );\n      const textElemContainer = bkgElem.append(\"g\");\n      const fo = textElemContainer.append(\"foreignObject\").attr(\"width\", iconSize).attr(\"height\", iconSize);\n      const divElem = fo.append(\"div\").attr(\"class\", \"node-icon-text\").attr(\"style\", `height: ${iconSize}px;`).append(\"div\").html(service.iconText);\n      const fontSize = parseInt(\n        window.getComputedStyle(divElem.node(), null).getPropertyValue(\"font-size\").replace(/\\D/g, \"\")\n      ) ?? 16;\n      divElem.attr(\"style\", `-webkit-line-clamp: ${Math.floor((iconSize - 2) / fontSize)};`);\n    } else {\n      bkgElem.append(\"path\").attr(\"class\", \"node-bkg\").attr(\"id\", \"node-\" + service.id).attr(\n        \"d\",\n        `M0 ${iconSize} v${-iconSize} q0,-5 5,-5 h${iconSize} q5,0 5,5 v${iconSize} H0 Z`\n      );\n    }\n    serviceElem.attr(\"class\", \"architecture-service\");\n    const { width, height } = serviceElem._groups[0][0].getBBox();\n    service.width = width;\n    service.height = height;\n    db2.setElementForId(service.id, serviceElem);\n  }\n  return 0;\n}, \"drawServices\");\nvar drawJunctions = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(function(db2, elem, junctions) {\n  junctions.forEach((junction) => {\n    const junctionElem = elem.append(\"g\");\n    const iconSize = getConfigField(\"iconSize\");\n    const bkgElem = junctionElem.append(\"g\");\n    bkgElem.append(\"rect\").attr(\"id\", \"node-\" + junction.id).attr(\"fill-opacity\", \"0\").attr(\"width\", iconSize).attr(\"height\", iconSize);\n    junctionElem.attr(\"class\", \"architecture-junction\");\n    const { width, height } = junctionElem._groups[0][0].getBBox();\n    junctionElem.width = width;\n    junctionElem.height = height;\n    db2.setElementForId(junction.id, junctionElem);\n  });\n}, \"drawJunctions\");\n\n// src/diagrams/architecture/architectureRenderer.ts\n(0,_chunk_OPO4IU42_mjs__WEBPACK_IMPORTED_MODULE_0__.registerIconPacks)([\n  {\n    name: architectureIcons.prefix,\n    icons: architectureIcons\n  }\n]);\ncytoscape__WEBPACK_IMPORTED_MODULE_8__[\"default\"].use(cytoscape_fcose__WEBPACK_IMPORTED_MODULE_9__);\nfunction addServices(services, cy) {\n  services.forEach((service) => {\n    cy.add({\n      group: \"nodes\",\n      data: {\n        type: \"service\",\n        id: service.id,\n        icon: service.icon,\n        label: service.title,\n        parent: service.in,\n        width: getConfigField(\"iconSize\"),\n        height: getConfigField(\"iconSize\")\n      },\n      classes: \"node-service\"\n    });\n  });\n}\n(0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(addServices, \"addServices\");\nfunction addJunctions(junctions, cy) {\n  junctions.forEach((junction) => {\n    cy.add({\n      group: \"nodes\",\n      data: {\n        type: \"junction\",\n        id: junction.id,\n        parent: junction.in,\n        width: getConfigField(\"iconSize\"),\n        height: getConfigField(\"iconSize\")\n      },\n      classes: \"node-junction\"\n    });\n  });\n}\n(0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(addJunctions, \"addJunctions\");\nfunction positionNodes(db2, cy) {\n  cy.nodes().map((node) => {\n    const data = nodeData(node);\n    if (data.type === \"group\") {\n      return;\n    }\n    data.x = node.position().x;\n    data.y = node.position().y;\n    const nodeElem = db2.getElementById(data.id);\n    nodeElem.attr(\"transform\", \"translate(\" + (data.x || 0) + \",\" + (data.y || 0) + \")\");\n  });\n}\n(0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(positionNodes, \"positionNodes\");\nfunction addGroups(groups, cy) {\n  groups.forEach((group) => {\n    cy.add({\n      group: \"nodes\",\n      data: {\n        type: \"group\",\n        id: group.id,\n        icon: group.icon,\n        label: group.title,\n        parent: group.in\n      },\n      classes: \"node-group\"\n    });\n  });\n}\n(0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(addGroups, \"addGroups\");\nfunction addEdges(edges, cy) {\n  edges.forEach((parsedEdge) => {\n    const { lhsId, rhsId, lhsInto, lhsGroup, rhsInto, lhsDir, rhsDir, rhsGroup, title } = parsedEdge;\n    const edgeType = isArchitectureDirectionXY(parsedEdge.lhsDir, parsedEdge.rhsDir) ? \"segments\" : \"straight\";\n    const edge = {\n      id: `${lhsId}-${rhsId}`,\n      label: title,\n      source: lhsId,\n      sourceDir: lhsDir,\n      sourceArrow: lhsInto,\n      sourceGroup: lhsGroup,\n      sourceEndpoint: lhsDir === \"L\" ? \"0 50%\" : lhsDir === \"R\" ? \"100% 50%\" : lhsDir === \"T\" ? \"50% 0\" : \"50% 100%\",\n      target: rhsId,\n      targetDir: rhsDir,\n      targetArrow: rhsInto,\n      targetGroup: rhsGroup,\n      targetEndpoint: rhsDir === \"L\" ? \"0 50%\" : rhsDir === \"R\" ? \"100% 50%\" : rhsDir === \"T\" ? \"50% 0\" : \"50% 100%\"\n    };\n    cy.add({\n      group: \"edges\",\n      data: edge,\n      classes: edgeType\n    });\n  });\n}\n(0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(addEdges, \"addEdges\");\nfunction getAlignments(spatialMaps) {\n  const alignments = spatialMaps.map((spatialMap) => {\n    const horizontalAlignments = {};\n    const verticalAlignments = {};\n    Object.entries(spatialMap).forEach(([id, [x, y]]) => {\n      if (!horizontalAlignments[y]) {\n        horizontalAlignments[y] = [];\n      }\n      if (!verticalAlignments[x]) {\n        verticalAlignments[x] = [];\n      }\n      horizontalAlignments[y].push(id);\n      verticalAlignments[x].push(id);\n    });\n    return {\n      horiz: Object.values(horizontalAlignments).filter((arr) => arr.length > 1),\n      vert: Object.values(verticalAlignments).filter((arr) => arr.length > 1)\n    };\n  });\n  const [horizontal, vertical] = alignments.reduce(\n    ([prevHoriz, prevVert], { horiz, vert }) => {\n      return [\n        [...prevHoriz, ...horiz],\n        [...prevVert, ...vert]\n      ];\n    },\n    [[], []]\n  );\n  return {\n    horizontal,\n    vertical\n  };\n}\n(0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(getAlignments, \"getAlignments\");\nfunction getRelativeConstraints(spatialMaps) {\n  const relativeConstraints = [];\n  const posToStr = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((pos) => `${pos[0]},${pos[1]}`, \"posToStr\");\n  const strToPos = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)((pos) => pos.split(\",\").map((p) => parseInt(p)), \"strToPos\");\n  spatialMaps.forEach((spatialMap) => {\n    const invSpatialMap = Object.fromEntries(\n      Object.entries(spatialMap).map(([id, pos]) => [posToStr(pos), id])\n    );\n    const queue = [posToStr([0, 0])];\n    const visited = {};\n    const directions = {\n      L: [-1, 0],\n      R: [1, 0],\n      T: [0, 1],\n      B: [0, -1]\n    };\n    while (queue.length > 0) {\n      const curr = queue.shift();\n      if (curr) {\n        visited[curr] = 1;\n        const currId = invSpatialMap[curr];\n        if (currId) {\n          const currPos = strToPos(curr);\n          Object.entries(directions).forEach(([dir, shift]) => {\n            const newPos = posToStr([currPos[0] + shift[0], currPos[1] + shift[1]]);\n            const newId = invSpatialMap[newPos];\n            if (newId && !visited[newPos]) {\n              queue.push(newPos);\n              relativeConstraints.push({\n                [ArchitectureDirectionName[dir]]: newId,\n                [ArchitectureDirectionName[getOppositeArchitectureDirection(dir)]]: currId,\n                gap: 1.5 * getConfigField(\"iconSize\")\n              });\n            }\n          });\n        }\n      }\n    }\n  });\n  return relativeConstraints;\n}\n(0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(getRelativeConstraints, \"getRelativeConstraints\");\nfunction layoutArchitecture(services, junctions, groups, edges, { spatialMaps }) {\n  return new Promise((resolve) => {\n    const renderEl = (0,d3__WEBPACK_IMPORTED_MODULE_10__.select)(\"body\").append(\"div\").attr(\"id\", \"cy\").attr(\"style\", \"display:none\");\n    const cy = (0,cytoscape__WEBPACK_IMPORTED_MODULE_8__[\"default\"])({\n      container: document.getElementById(\"cy\"),\n      style: [\n        {\n          selector: \"edge\",\n          style: {\n            \"curve-style\": \"straight\",\n            label: \"data(label)\",\n            \"source-endpoint\": \"data(sourceEndpoint)\",\n            \"target-endpoint\": \"data(targetEndpoint)\"\n          }\n        },\n        {\n          selector: \"edge.segments\",\n          style: {\n            \"curve-style\": \"segments\",\n            \"segment-weights\": \"0\",\n            \"segment-distances\": [0.5],\n            // @ts-ignore Incorrect library types\n            \"edge-distances\": \"endpoints\",\n            \"source-endpoint\": \"data(sourceEndpoint)\",\n            \"target-endpoint\": \"data(targetEndpoint)\"\n          }\n        },\n        {\n          selector: \"node\",\n          style: {\n            // @ts-ignore Incorrect library types\n            \"compound-sizing-wrt-labels\": \"include\"\n          }\n        },\n        {\n          selector: \"node[label]\",\n          style: {\n            \"text-valign\": \"bottom\",\n            \"text-halign\": \"center\",\n            \"font-size\": `${getConfigField(\"fontSize\")}px`\n          }\n        },\n        {\n          selector: \".node-service\",\n          style: {\n            label: \"data(label)\",\n            width: \"data(width)\",\n            height: \"data(height)\"\n          }\n        },\n        {\n          selector: \".node-junction\",\n          style: {\n            width: \"data(width)\",\n            height: \"data(height)\"\n          }\n        },\n        {\n          selector: \".node-group\",\n          style: {\n            // @ts-ignore Incorrect library types\n            padding: `${getConfigField(\"padding\")}px`\n          }\n        }\n      ]\n    });\n    renderEl.remove();\n    addGroups(groups, cy);\n    addServices(services, cy);\n    addJunctions(junctions, cy);\n    addEdges(edges, cy);\n    const alignmentConstraint = getAlignments(spatialMaps);\n    const relativePlacementConstraint = getRelativeConstraints(spatialMaps);\n    const layout = cy.layout({\n      name: \"fcose\",\n      quality: \"proof\",\n      styleEnabled: false,\n      animate: false,\n      nodeDimensionsIncludeLabels: false,\n      // Adjust the edge parameters if it passes through the border of a group\n      // Hacky fix for: https://github.com/iVis-at-Bilkent/cytoscape.js-fcose/issues/67\n      idealEdgeLength(edge) {\n        const [nodeA, nodeB] = edge.connectedNodes();\n        const { parent: parentA } = nodeData(nodeA);\n        const { parent: parentB } = nodeData(nodeB);\n        const elasticity = parentA === parentB ? 1.5 * getConfigField(\"iconSize\") : 0.5 * getConfigField(\"iconSize\");\n        return elasticity;\n      },\n      edgeElasticity(edge) {\n        const [nodeA, nodeB] = edge.connectedNodes();\n        const { parent: parentA } = nodeData(nodeA);\n        const { parent: parentB } = nodeData(nodeB);\n        const elasticity = parentA === parentB ? 0.45 : 1e-3;\n        return elasticity;\n      },\n      alignmentConstraint,\n      relativePlacementConstraint\n    });\n    layout.one(\"layoutstop\", () => {\n      function getSegmentWeights(source, target, pointX, pointY) {\n        let W, D;\n        const { x: sX, y: sY } = source;\n        const { x: tX, y: tY } = target;\n        D = (pointY - sY + (sX - pointX) * (sY - tY) / (sX - tX)) / Math.sqrt(1 + Math.pow((sY - tY) / (sX - tX), 2));\n        W = Math.sqrt(Math.pow(pointY - sY, 2) + Math.pow(pointX - sX, 2) - Math.pow(D, 2));\n        const distAB = Math.sqrt(Math.pow(tX - sX, 2) + Math.pow(tY - sY, 2));\n        W = W / distAB;\n        let delta1 = (tX - sX) * (pointY - sY) - (tY - sY) * (pointX - sX);\n        switch (true) {\n          case delta1 >= 0:\n            delta1 = 1;\n            break;\n          case delta1 < 0:\n            delta1 = -1;\n            break;\n        }\n        let delta2 = (tX - sX) * (pointX - sX) + (tY - sY) * (pointY - sY);\n        switch (true) {\n          case delta2 >= 0:\n            delta2 = 1;\n            break;\n          case delta2 < 0:\n            delta2 = -1;\n            break;\n        }\n        D = Math.abs(D) * delta1;\n        W = W * delta2;\n        return {\n          distances: D,\n          weights: W\n        };\n      }\n      (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(getSegmentWeights, \"getSegmentWeights\");\n      cy.startBatch();\n      for (const edge of Object.values(cy.edges())) {\n        if (edge.data?.()) {\n          const { x: sX, y: sY } = edge.source().position();\n          const { x: tX, y: tY } = edge.target().position();\n          if (sX !== tX && sY !== tY) {\n            const sEP = edge.sourceEndpoint();\n            const tEP = edge.targetEndpoint();\n            const { sourceDir } = edgeData(edge);\n            const [pointX, pointY] = isArchitectureDirectionY(sourceDir) ? [sEP.x, tEP.y] : [tEP.x, sEP.y];\n            const { weights, distances } = getSegmentWeights(sEP, tEP, pointX, pointY);\n            edge.style(\"segment-distances\", distances);\n            edge.style(\"segment-weights\", weights);\n          }\n        }\n      }\n      cy.endBatch();\n      layout.run();\n    });\n    layout.run();\n    cy.ready((e) => {\n      _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.log.info(\"Ready\", e);\n      resolve(cy);\n    });\n  });\n}\n(0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(layoutArchitecture, \"layoutArchitecture\");\nvar draw = /* @__PURE__ */ (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(async (text, id, _version, diagObj) => {\n  const db2 = diagObj.db;\n  const services = db2.getServices();\n  const junctions = db2.getJunctions();\n  const groups = db2.getGroups();\n  const edges = db2.getEdges();\n  const ds = db2.getDataStructures();\n  const svg = (0,_chunk_EJ4ZWXGL_mjs__WEBPACK_IMPORTED_MODULE_5__.selectSvgElement)(id);\n  const edgesElem = svg.append(\"g\");\n  edgesElem.attr(\"class\", \"architecture-edges\");\n  const servicesElem = svg.append(\"g\");\n  servicesElem.attr(\"class\", \"architecture-services\");\n  const groupElem = svg.append(\"g\");\n  groupElem.attr(\"class\", \"architecture-groups\");\n  await drawServices(db2, servicesElem, services);\n  drawJunctions(db2, servicesElem, junctions);\n  const cy = await layoutArchitecture(services, junctions, groups, edges, ds);\n  await drawEdges(edgesElem, cy);\n  await drawGroups(groupElem, cy);\n  positionNodes(db2, cy);\n  (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_6__.setupGraphViewbox)(void 0, svg, getConfigField(\"padding\"), getConfigField(\"useMaxWidth\"));\n}, \"draw\");\nvar renderer = { draw };\n\n// src/diagrams/architecture/architectureDiagram.ts\nvar diagram = {\n  parser,\n  db,\n  renderer,\n  styles: architectureStyles_default\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVybWFpZC9kaXN0L2NodW5rcy9tZXJtYWlkLmNvcmUvYXJjaGl0ZWN0dXJlRGlhZ3JhbS1VWU42TUJQRC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBSThCO0FBR0E7QUFHQTtBQUdBO0FBQ0E7QUFHQTtBQWNBOztBQUU5QjtBQUMyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyREFBTSxlQUFlLE1BQU0sR0FBRyxXQUFXLElBQUksT0FBTztBQUN6RSxxQkFBcUIsMkRBQU0saUJBQWlCLFdBQVcsRUFBRSxNQUFNLEtBQUssTUFBTSxHQUFHLE1BQU07QUFDbkYscUJBQXFCLDJEQUFNLG1CQUFtQixNQUFNLEtBQUssVUFBVSxHQUFHLE1BQU07QUFDNUUscUJBQXFCLDJEQUFNLGVBQWUsVUFBVSxLQUFLLE1BQU0sR0FBRyxPQUFPLElBQUksTUFBTTtBQUNuRjtBQUNBO0FBQ0EscUJBQXFCLDJEQUFNO0FBQzNCLHFCQUFxQiwyREFBTTtBQUMzQixxQkFBcUIsMkRBQU07QUFDM0IscUJBQXFCLDJEQUFNO0FBQzNCO0FBQ0EsdURBQXVELDJEQUFNO0FBQzdEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBOEMsMkRBQU07QUFDcEQ7QUFDQTtBQUNBLENBQUM7QUFDRCwrQ0FBK0MsMkRBQU07QUFDckQ7QUFDQTtBQUNBLENBQUM7QUFDRCwrQ0FBK0MsMkRBQU07QUFDckQ7QUFDQTtBQUNBLENBQUM7QUFDRCxnREFBZ0QsMkRBQU07QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDJDQUEyQywyREFBTTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHVEQUF1RCwyREFBTTtBQUM3RDtBQUNBLENBQUM7QUFDRCxtREFBbUQsMkRBQU07QUFDekQsa0JBQWtCLFVBQVUsRUFBRSxVQUFVO0FBQ3hDO0FBQ0EsQ0FBQztBQUNELCtEQUErRCwyREFBTTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsd0RBQXdELDJEQUFNO0FBQzlEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLENBQUM7QUFDRCw0Q0FBNEMsMkRBQU07QUFDbEQ7QUFDQTtBQUNBLENBQUM7QUFDRCw2Q0FBNkMsMkRBQU07QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRCwrQkFBK0IsMkRBQU07QUFDckM7QUFDQSxDQUFDO0FBQ0QsK0JBQStCLDJEQUFNO0FBQ3JDO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGtDQUFrQyxzRUFBcUI7QUFDdkQsZ0JBQWdCLGdFQUFlO0FBQy9CLFdBQVc7QUFDWCxZQUFZO0FBQ1o7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDZCQUE2QiwyREFBTTtBQUNuQztBQUNBLEVBQUUsMERBQUs7QUFDUCxDQUFDO0FBQ0QsaUNBQWlDLDJEQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLHlCQUF5QixHQUFHLGlDQUFpQyxnQ0FBZ0M7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsR0FBRztBQUN6QztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsR0FBRztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsR0FBRztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0NBQWtDLDJEQUFNO0FBQ3hDLGtDQUFrQywyREFBTSxZQUFZLGdCQUFnQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQ0FBbUMsMkRBQU07QUFDekMsK0JBQStCLDJEQUFNO0FBQ3JDLDhCQUE4QiwyREFBTTtBQUNwQywrQkFBK0IsMkRBQU0sWUFBWSw2QkFBNkI7QUFDOUU7QUFDQTtBQUNBLHVCQUF1QixHQUFHLGlDQUFpQyxnQ0FBZ0M7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsR0FBRztBQUN2QztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsR0FBRztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsR0FBRztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsZ0NBQWdDLDJEQUFNO0FBQ3RDO0FBQ0EsQ0FBQztBQUNELDhCQUE4QiwyREFBTTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLDREQUE0RCxNQUFNLElBQUksTUFBTSwyQkFBMkIsT0FBTztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxNQUFNLElBQUksTUFBTSwyQkFBMkIsT0FBTztBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixNQUFNO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE1BQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsK0JBQStCLDJEQUFNO0FBQ3JDLHdDQUF3QywyREFBTTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sSUFBSTtBQUNYO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSw4Q0FBOEMsa0JBQWtCO0FBQ2hFO0FBQ0E7QUFDQSxnQ0FBZ0MsMkRBQU07QUFDdEMsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxzQ0FBc0MsMkRBQU07QUFDNUM7QUFDQSxDQUFDO0FBQ0QscUNBQXFDLDJEQUFNO0FBQzNDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixhQUFhO0FBQ2IsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtEQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBTTs7QUFFTjtBQUNBLGlDQUFpQywyREFBTTtBQUN2QyxFQUFFLHFFQUFnQjtBQUNsQjtBQUNBLGlEQUFpRCw2QkFBNkI7QUFDOUUsbURBQW1ELDhCQUE4QjtBQUNqRjtBQUNBLENBQUM7QUFDRDtBQUNBLHlCQUF5QiwyREFBTTtBQUMvQixzQkFBc0IseURBQUs7QUFDM0IsSUFBSSxvREFBRztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsZ0NBQWdDLDJEQUFNO0FBQ3RDO0FBQ0Esb0JBQW9CO0FBQ3BCLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Qsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNrQztBQUNFO0FBQ1I7O0FBRTVCO0FBQ0EsK0JBQStCLDJEQUFNO0FBQ3JDLGdFQUFnRSxrQkFBa0IsS0FBSyxLQUFLO0FBQzVGLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZHQUE2RyxjQUFjLHVCQUF1QixrQkFBa0IsdUdBQXVHLGNBQWMsdUJBQXVCLGtCQUFrQix1R0FBdUcsY0FBYyx1QkFBdUIsa0JBQWtCLHlGQUF5RixjQUFjLHVCQUF1QixrQkFBa0Isa0VBQWtFLGNBQWMsdUJBQXVCLGtCQUFrQixrRUFBa0UsY0FBYyx1QkFBdUIsa0JBQWtCO0FBQ2wyQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EseUZBQXlGLGNBQWMsdUJBQXVCLGtCQUFrQixvRUFBb0UsY0FBYyx1QkFBdUIsa0JBQWtCLG9FQUFvRSxjQUFjLHVCQUF1QixrQkFBa0IseUhBQXlILGtCQUFrQixzSEFBc0gsY0FBYyxzQkFBc0IsNkhBQTZILGtCQUFrQixzSEFBc0gsY0FBYyxzQkFBc0IsNkhBQTZILGtCQUFrQixzSEFBc0gsY0FBYyxzQkFBc0IsK0RBQStELGNBQWMsc0JBQXNCLHdEQUF3RCxjQUFjLHNCQUFzQix3REFBd0QsY0FBYyxzQkFBc0IsK0RBQStELGNBQWMsc0JBQXNCLHdEQUF3RCxjQUFjLHNCQUFzQix3REFBd0QsY0FBYyxzQkFBc0IsK0RBQStELGNBQWMsc0JBQXNCLHdEQUF3RCxjQUFjLHNCQUFzQix3REFBd0QsY0FBYyxzQkFBc0I7QUFDOWtFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxRkFBcUYsY0FBYyx1QkFBdUIsa0JBQWtCLG1FQUFtRSxjQUFjLHVCQUF1QixrQkFBa0IsbUVBQW1FLGNBQWMsdUJBQXVCLGtCQUFrQixtRUFBbUUsY0FBYyx1QkFBdUIsa0JBQWtCLG1FQUFtRSxjQUFjLHVCQUF1QixrQkFBa0IscUVBQXFFLGNBQWMsdUJBQXVCLGtCQUFrQixtRUFBbUUsY0FBYyx1QkFBdUIsa0JBQWtCLDhKQUE4SixrQkFBa0I7QUFDMWhDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2REFBNkQsY0FBYyx1QkFBdUIsa0JBQWtCLGdFQUFnRSxjQUFjLHVCQUF1QixrQkFBa0IsZ0VBQWdFLGNBQWMsdUJBQXVCLGtCQUFrQiw2RUFBNkUsY0FBYyx1QkFBdUIsa0JBQWtCLDRFQUE0RSxjQUFjLHVCQUF1QixrQkFBa0Isc0VBQXNFLGNBQWMsdUJBQXVCLGtCQUFrQixzRUFBc0UsY0FBYyx1QkFBdUIsa0JBQWtCO0FBQ24yQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EseVZBQXlWLGNBQWMsdUJBQXVCLGtCQUFrQjtBQUNoWjtBQUNBLEtBQUs7QUFDTCxhQUFhLDREQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsMkRBQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixZQUFZLHVCQUF1QjtBQUNuQyxjQUFjLG1CQUFtQjtBQUNqQyxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU8sR0FBRyxRQUFRLElBQUksS0FBSyxHQUFHLE1BQU0sR0FBRyxLQUFLLEdBQUcsTUFBTTtBQUM3RjtBQUNBO0FBQ0E7QUFDQSw4SEFBOEgsT0FBTyxHQUFHLE9BQU87QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4SEFBOEgsT0FBTyxHQUFHLE9BQU87QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrREFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWSwrREFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixnQkFBZ0I7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsS0FBSyxJQUFJLDJCQUEyQjtBQUNoRSw0QkFBNEIsc0JBQXNCLElBQUksdUJBQXVCO0FBQzdFLHlCQUF5QixnQkFBZ0IsT0FBTyxvQkFBb0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNELGlDQUFpQywyREFBTTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixNQUFNLCtEQUFVLGNBQWMsdUZBQXVGLEVBQUU7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0RBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVksK0RBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRCxtQ0FBbUMsMkRBQU07QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVEsK0RBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU0sK0RBQVUsaUJBQWlCLDZFQUE2RSxFQUFFO0FBQzlIO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsY0FBYyxNQUFNLCtEQUFVLFlBQVksNkVBQTZFLEVBQUU7QUFDekg7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLFNBQVMsR0FBRztBQUM1RztBQUNBO0FBQ0E7QUFDQSxtREFBbUQsdUNBQXVDO0FBQzFGLE1BQU07QUFDTjtBQUNBO0FBQ0EsY0FBYyxVQUFVLEdBQUcsV0FBVyxjQUFjLFVBQVUsWUFBWSxVQUFVO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsb0NBQW9DLDJEQUFNO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0Esc0VBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBUyxLQUFLLDRDQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSwyREFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLDJEQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSwyREFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLDJEQUFNO0FBQ047QUFDQTtBQUNBLFlBQVksNEVBQTRFO0FBQ3hGO0FBQ0E7QUFDQSxhQUFhLE1BQU0sR0FBRyxNQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLDJEQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSw4QkFBOEIsYUFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUFNO0FBQ047QUFDQTtBQUNBLG1DQUFtQywyREFBTSxhQUFhLE9BQU8sR0FBRyxPQUFPO0FBQ3ZFLG1DQUFtQywyREFBTTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJEQUFNO0FBQ04sa0VBQWtFLGFBQWE7QUFDL0U7QUFDQSxxQkFBcUIsMkNBQU07QUFDM0IsZUFBZSxxREFBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQyxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEMsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0IsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sMkRBQU07QUFDWjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQyxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU0sb0RBQUc7QUFDVDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSwyREFBTTtBQUNOLDJCQUEyQiwyREFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHFFQUFnQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLHNFQUFpQjtBQUNuQixDQUFDO0FBQ0QsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViY2xpLWRlbW8vLi9ub2RlX21vZHVsZXMvbWVybWFpZC9kaXN0L2NodW5rcy9tZXJtYWlkLmNvcmUvYXJjaGl0ZWN0dXJlRGlhZ3JhbS1VWU42TUJQRC5tanM/MTEwZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBnZXRJY29uU1ZHLFxuICByZWdpc3Rlckljb25QYWNrcyxcbiAgdW5rbm93bkljb25cbn0gZnJvbSBcIi4vY2h1bmstT1BPNElVNDIubWpzXCI7XG5pbXBvcnQge1xuICBjcmVhdGVUZXh0XG59IGZyb20gXCIuL2NodW5rLTZKT1M3NERTLm1qc1wiO1xuaW1wb3J0IHtcbiAgcG9wdWxhdGVDb21tb25EYlxufSBmcm9tIFwiLi9jaHVuay1UTVVCRVdQRC5tanNcIjtcbmltcG9ydCB7XG4gIEltcGVyYXRpdmVTdGF0ZVxufSBmcm9tIFwiLi9jaHVuay1LRkJPQkpIQy5tanNcIjtcbmltcG9ydCBcIi4vY2h1bmstN0RLUlpLSEUubWpzXCI7XG5pbXBvcnQge1xuICBzZWxlY3RTdmdFbGVtZW50XG59IGZyb20gXCIuL2NodW5rLUVKNFpXWEdMLm1qc1wiO1xuaW1wb3J0IHtcbiAgX19uYW1lLFxuICBjbGVhcixcbiAgZGVmYXVsdENvbmZpZ19kZWZhdWx0LFxuICBnZXRBY2NEZXNjcmlwdGlvbixcbiAgZ2V0QWNjVGl0bGUsXG4gIGdldENvbmZpZzIgYXMgZ2V0Q29uZmlnLFxuICBnZXREaWFncmFtVGl0bGUsXG4gIGxvZyxcbiAgc2V0QWNjRGVzY3JpcHRpb24sXG4gIHNldEFjY1RpdGxlLFxuICBzZXREaWFncmFtVGl0bGUsXG4gIHNldHVwR3JhcGhWaWV3Ym94XG59IGZyb20gXCIuL2NodW5rLTZEQkZGSElQLm1qc1wiO1xuXG4vLyBzcmMvZGlhZ3JhbXMvYXJjaGl0ZWN0dXJlL2FyY2hpdGVjdHVyZVBhcnNlci50c1xuaW1wb3J0IHsgcGFyc2UgfSBmcm9tIFwiQG1lcm1haWQtanMvcGFyc2VyXCI7XG5cbi8vIHNyYy9kaWFncmFtcy9hcmNoaXRlY3R1cmUvYXJjaGl0ZWN0dXJlVHlwZXMudHNcbnZhciBBcmNoaXRlY3R1cmVEaXJlY3Rpb25OYW1lID0ge1xuICBMOiBcImxlZnRcIixcbiAgUjogXCJyaWdodFwiLFxuICBUOiBcInRvcFwiLFxuICBCOiBcImJvdHRvbVwiXG59O1xudmFyIEFyY2hpdGVjdHVyZURpcmVjdGlvbkFycm93ID0ge1xuICBMOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKChzY2FsZSkgPT4gYCR7c2NhbGV9LCR7c2NhbGUgLyAyfSAwLCR7c2NhbGV9IDAsMGAsIFwiTFwiKSxcbiAgUjogLyogQF9fUFVSRV9fICovIF9fbmFtZSgoc2NhbGUpID0+IGAwLCR7c2NhbGUgLyAyfSAke3NjYWxlfSwwICR7c2NhbGV9LCR7c2NhbGV9YCwgXCJSXCIpLFxuICBUOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKChzY2FsZSkgPT4gYDAsMCAke3NjYWxlfSwwICR7c2NhbGUgLyAyfSwke3NjYWxlfWAsIFwiVFwiKSxcbiAgQjogLyogQF9fUFVSRV9fICovIF9fbmFtZSgoc2NhbGUpID0+IGAke3NjYWxlIC8gMn0sMCAke3NjYWxlfSwke3NjYWxlfSAwLCR7c2NhbGV9YCwgXCJCXCIpXG59O1xudmFyIEFyY2hpdGVjdHVyZURpcmVjdGlvbkFycm93U2hpZnQgPSB7XG4gIEw6IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKG9yaWcsIGFycm93U2l6ZSkgPT4gb3JpZyAtIGFycm93U2l6ZSArIDIsIFwiTFwiKSxcbiAgUjogLyogQF9fUFVSRV9fICovIF9fbmFtZSgob3JpZywgX2Fycm93U2l6ZSkgPT4gb3JpZyAtIDIsIFwiUlwiKSxcbiAgVDogLyogQF9fUFVSRV9fICovIF9fbmFtZSgob3JpZywgYXJyb3dTaXplKSA9PiBvcmlnIC0gYXJyb3dTaXplICsgMiwgXCJUXCIpLFxuICBCOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKChvcmlnLCBfYXJyb3dTaXplKSA9PiBvcmlnIC0gMiwgXCJCXCIpXG59O1xudmFyIGdldE9wcG9zaXRlQXJjaGl0ZWN0dXJlRGlyZWN0aW9uID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbih4KSB7XG4gIGlmIChpc0FyY2hpdGVjdHVyZURpcmVjdGlvblgoeCkpIHtcbiAgICByZXR1cm4geCA9PT0gXCJMXCIgPyBcIlJcIiA6IFwiTFwiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB4ID09PSBcIlRcIiA/IFwiQlwiIDogXCJUXCI7XG4gIH1cbn0sIFwiZ2V0T3Bwb3NpdGVBcmNoaXRlY3R1cmVEaXJlY3Rpb25cIik7XG52YXIgaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb24gPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKHgpIHtcbiAgY29uc3QgdGVtcCA9IHg7XG4gIHJldHVybiB0ZW1wID09PSBcIkxcIiB8fCB0ZW1wID09PSBcIlJcIiB8fCB0ZW1wID09PSBcIlRcIiB8fCB0ZW1wID09PSBcIkJcIjtcbn0sIFwiaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb25cIik7XG52YXIgaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb25YID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbih4KSB7XG4gIGNvbnN0IHRlbXAgPSB4O1xuICByZXR1cm4gdGVtcCA9PT0gXCJMXCIgfHwgdGVtcCA9PT0gXCJSXCI7XG59LCBcImlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uWFwiKTtcbnZhciBpc0FyY2hpdGVjdHVyZURpcmVjdGlvblkgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKHgpIHtcbiAgY29uc3QgdGVtcCA9IHg7XG4gIHJldHVybiB0ZW1wID09PSBcIlRcIiB8fCB0ZW1wID09PSBcIkJcIjtcbn0sIFwiaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb25ZXCIpO1xudmFyIGlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uWFkgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKGEsIGIpIHtcbiAgY29uc3QgYVhfYlkgPSBpc0FyY2hpdGVjdHVyZURpcmVjdGlvblgoYSkgJiYgaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb25ZKGIpO1xuICBjb25zdCBhWV9iWCA9IGlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uWShhKSAmJiBpc0FyY2hpdGVjdHVyZURpcmVjdGlvblgoYik7XG4gIHJldHVybiBhWF9iWSB8fCBhWV9iWDtcbn0sIFwiaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb25YWVwiKTtcbnZhciBpc0FyY2hpdGVjdHVyZVBhaXJYWSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoZnVuY3Rpb24ocGFpcikge1xuICBjb25zdCBsaHMgPSBwYWlyWzBdO1xuICBjb25zdCByaHMgPSBwYWlyWzFdO1xuICBjb25zdCBhWF9iWSA9IGlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uWChsaHMpICYmIGlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uWShyaHMpO1xuICBjb25zdCBhWV9iWCA9IGlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uWShsaHMpICYmIGlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uWChyaHMpO1xuICByZXR1cm4gYVhfYlkgfHwgYVlfYlg7XG59LCBcImlzQXJjaGl0ZWN0dXJlUGFpclhZXCIpO1xudmFyIGlzVmFsaWRBcmNoaXRlY3R1cmVEaXJlY3Rpb25QYWlyID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbih4KSB7XG4gIHJldHVybiB4ICE9PSBcIkxMXCIgJiYgeCAhPT0gXCJSUlwiICYmIHggIT09IFwiVFRcIiAmJiB4ICE9PSBcIkJCXCI7XG59LCBcImlzVmFsaWRBcmNoaXRlY3R1cmVEaXJlY3Rpb25QYWlyXCIpO1xudmFyIGdldEFyY2hpdGVjdHVyZURpcmVjdGlvblBhaXIgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKHNvdXJjZURpciwgdGFyZ2V0RGlyKSB7XG4gIGNvbnN0IHBhaXIgPSBgJHtzb3VyY2VEaXJ9JHt0YXJnZXREaXJ9YDtcbiAgcmV0dXJuIGlzVmFsaWRBcmNoaXRlY3R1cmVEaXJlY3Rpb25QYWlyKHBhaXIpID8gcGFpciA6IHZvaWQgMDtcbn0sIFwiZ2V0QXJjaGl0ZWN0dXJlRGlyZWN0aW9uUGFpclwiKTtcbnZhciBzaGlmdFBvc2l0aW9uQnlBcmNoaXRlY3R1cmVEaXJlY3Rpb25QYWlyID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihbeCwgeV0sIHBhaXIpIHtcbiAgY29uc3QgbGhzID0gcGFpclswXTtcbiAgY29uc3QgcmhzID0gcGFpclsxXTtcbiAgaWYgKGlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uWChsaHMpKSB7XG4gICAgaWYgKGlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uWShyaHMpKSB7XG4gICAgICByZXR1cm4gW3ggKyAobGhzID09PSBcIkxcIiA/IC0xIDogMSksIHkgKyAocmhzID09PSBcIlRcIiA/IDEgOiAtMSldO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW3ggKyAobGhzID09PSBcIkxcIiA/IC0xIDogMSksIHldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb25YKHJocykpIHtcbiAgICAgIHJldHVybiBbeCArIChyaHMgPT09IFwiTFwiID8gMSA6IC0xKSwgeSArIChsaHMgPT09IFwiVFwiID8gMSA6IC0xKV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbeCwgeSArIChsaHMgPT09IFwiVFwiID8gMSA6IC0xKV07XG4gICAgfVxuICB9XG59LCBcInNoaWZ0UG9zaXRpb25CeUFyY2hpdGVjdHVyZURpcmVjdGlvblBhaXJcIik7XG52YXIgZ2V0QXJjaGl0ZWN0dXJlRGlyZWN0aW9uWFlGYWN0b3JzID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbihwYWlyKSB7XG4gIGlmIChwYWlyID09PSBcIkxUXCIgfHwgcGFpciA9PT0gXCJUTFwiKSB7XG4gICAgcmV0dXJuIFsxLCAxXTtcbiAgfSBlbHNlIGlmIChwYWlyID09PSBcIkJMXCIgfHwgcGFpciA9PT0gXCJMQlwiKSB7XG4gICAgcmV0dXJuIFsxLCAtMV07XG4gIH0gZWxzZSBpZiAocGFpciA9PT0gXCJCUlwiIHx8IHBhaXIgPT09IFwiUkJcIikge1xuICAgIHJldHVybiBbLTEsIC0xXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gWy0xLCAxXTtcbiAgfVxufSwgXCJnZXRBcmNoaXRlY3R1cmVEaXJlY3Rpb25YWUZhY3RvcnNcIik7XG52YXIgaXNBcmNoaXRlY3R1cmVTZXJ2aWNlID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbih4KSB7XG4gIGNvbnN0IHRlbXAgPSB4O1xuICByZXR1cm4gdGVtcC50eXBlID09PSBcInNlcnZpY2VcIjtcbn0sIFwiaXNBcmNoaXRlY3R1cmVTZXJ2aWNlXCIpO1xudmFyIGlzQXJjaGl0ZWN0dXJlSnVuY3Rpb24gPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKHgpIHtcbiAgY29uc3QgdGVtcCA9IHg7XG4gIHJldHVybiB0ZW1wLnR5cGUgPT09IFwianVuY3Rpb25cIjtcbn0sIFwiaXNBcmNoaXRlY3R1cmVKdW5jdGlvblwiKTtcbnZhciBlZGdlRGF0YSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGVkZ2UpID0+IHtcbiAgcmV0dXJuIGVkZ2UuZGF0YSgpO1xufSwgXCJlZGdlRGF0YVwiKTtcbnZhciBub2RlRGF0YSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKG5vZGUpID0+IHtcbiAgcmV0dXJuIG5vZGUuZGF0YSgpO1xufSwgXCJub2RlRGF0YVwiKTtcblxuLy8gc3JjL2RpYWdyYW1zL2FyY2hpdGVjdHVyZS9hcmNoaXRlY3R1cmVEYi50c1xudmFyIERFRkFVTFRfQVJDSElURUNUVVJFX0NPTkZJRyA9IGRlZmF1bHRDb25maWdfZGVmYXVsdC5hcmNoaXRlY3R1cmU7XG52YXIgc3RhdGUgPSBuZXcgSW1wZXJhdGl2ZVN0YXRlKCgpID0+ICh7XG4gIG5vZGVzOiB7fSxcbiAgZ3JvdXBzOiB7fSxcbiAgZWRnZXM6IFtdLFxuICByZWdpc3RlcmVkSWRzOiB7fSxcbiAgY29uZmlnOiBERUZBVUxUX0FSQ0hJVEVDVFVSRV9DT05GSUcsXG4gIGRhdGFTdHJ1Y3R1cmVzOiB2b2lkIDAsXG4gIGVsZW1lbnRzOiB7fVxufSkpO1xudmFyIGNsZWFyMiA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4ge1xuICBzdGF0ZS5yZXNldCgpO1xuICBjbGVhcigpO1xufSwgXCJjbGVhclwiKTtcbnZhciBhZGRTZXJ2aWNlID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbih7XG4gIGlkLFxuICBpY29uLFxuICBpbjogcGFyZW50LFxuICB0aXRsZSxcbiAgaWNvblRleHRcbn0pIHtcbiAgaWYgKHN0YXRlLnJlY29yZHMucmVnaXN0ZXJlZElkc1tpZF0gIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBUaGUgc2VydmljZSBpZCBbJHtpZH1dIGlzIGFscmVhZHkgaW4gdXNlIGJ5IGFub3RoZXIgJHtzdGF0ZS5yZWNvcmRzLnJlZ2lzdGVyZWRJZHNbaWRdfWBcbiAgICApO1xuICB9XG4gIGlmIChwYXJlbnQgIT09IHZvaWQgMCkge1xuICAgIGlmIChpZCA9PT0gcGFyZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzZXJ2aWNlIFske2lkfV0gY2Fubm90IGJlIHBsYWNlZCB3aXRoaW4gaXRzZWxmYCk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5yZWNvcmRzLnJlZ2lzdGVyZWRJZHNbcGFyZW50XSA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBUaGUgc2VydmljZSBbJHtpZH1dJ3MgcGFyZW50IGRvZXMgbm90IGV4aXN0LiBQbGVhc2UgbWFrZSBzdXJlIHRoZSBwYXJlbnQgaXMgY3JlYXRlZCBiZWZvcmUgdGhpcyBzZXJ2aWNlYFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLnJlY29yZHMucmVnaXN0ZXJlZElkc1twYXJlbnRdID09PSBcIm5vZGVcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgc2VydmljZSBbJHtpZH1dJ3MgcGFyZW50IGlzIG5vdCBhIGdyb3VwYCk7XG4gICAgfVxuICB9XG4gIHN0YXRlLnJlY29yZHMucmVnaXN0ZXJlZElkc1tpZF0gPSBcIm5vZGVcIjtcbiAgc3RhdGUucmVjb3Jkcy5ub2Rlc1tpZF0gPSB7XG4gICAgaWQsXG4gICAgdHlwZTogXCJzZXJ2aWNlXCIsXG4gICAgaWNvbixcbiAgICBpY29uVGV4dCxcbiAgICB0aXRsZSxcbiAgICBlZGdlczogW10sXG4gICAgaW46IHBhcmVudFxuICB9O1xufSwgXCJhZGRTZXJ2aWNlXCIpO1xudmFyIGdldFNlcnZpY2VzID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiBPYmplY3QudmFsdWVzKHN0YXRlLnJlY29yZHMubm9kZXMpLmZpbHRlcihpc0FyY2hpdGVjdHVyZVNlcnZpY2UpLCBcImdldFNlcnZpY2VzXCIpO1xudmFyIGFkZEp1bmN0aW9uID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbih7IGlkLCBpbjogcGFyZW50IH0pIHtcbiAgc3RhdGUucmVjb3Jkcy5yZWdpc3RlcmVkSWRzW2lkXSA9IFwibm9kZVwiO1xuICBzdGF0ZS5yZWNvcmRzLm5vZGVzW2lkXSA9IHtcbiAgICBpZCxcbiAgICB0eXBlOiBcImp1bmN0aW9uXCIsXG4gICAgZWRnZXM6IFtdLFxuICAgIGluOiBwYXJlbnRcbiAgfTtcbn0sIFwiYWRkSnVuY3Rpb25cIik7XG52YXIgZ2V0SnVuY3Rpb25zID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiBPYmplY3QudmFsdWVzKHN0YXRlLnJlY29yZHMubm9kZXMpLmZpbHRlcihpc0FyY2hpdGVjdHVyZUp1bmN0aW9uKSwgXCJnZXRKdW5jdGlvbnNcIik7XG52YXIgZ2V0Tm9kZXMgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IE9iamVjdC52YWx1ZXMoc3RhdGUucmVjb3Jkcy5ub2RlcyksIFwiZ2V0Tm9kZXNcIik7XG52YXIgZ2V0Tm9kZSA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGlkKSA9PiBzdGF0ZS5yZWNvcmRzLm5vZGVzW2lkXSwgXCJnZXROb2RlXCIpO1xudmFyIGFkZEdyb3VwID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShmdW5jdGlvbih7IGlkLCBpY29uLCBpbjogcGFyZW50LCB0aXRsZSB9KSB7XG4gIGlmIChzdGF0ZS5yZWNvcmRzLnJlZ2lzdGVyZWRJZHNbaWRdICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVGhlIGdyb3VwIGlkIFske2lkfV0gaXMgYWxyZWFkeSBpbiB1c2UgYnkgYW5vdGhlciAke3N0YXRlLnJlY29yZHMucmVnaXN0ZXJlZElkc1tpZF19YFxuICAgICk7XG4gIH1cbiAgaWYgKHBhcmVudCAhPT0gdm9pZCAwKSB7XG4gICAgaWYgKGlkID09PSBwYXJlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGdyb3VwIFske2lkfV0gY2Fubm90IGJlIHBsYWNlZCB3aXRoaW4gaXRzZWxmYCk7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5yZWNvcmRzLnJlZ2lzdGVyZWRJZHNbcGFyZW50XSA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBUaGUgZ3JvdXAgWyR7aWR9XSdzIHBhcmVudCBkb2VzIG5vdCBleGlzdC4gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgcGFyZW50IGlzIGNyZWF0ZWQgYmVmb3JlIHRoaXMgZ3JvdXBgXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoc3RhdGUucmVjb3Jkcy5yZWdpc3RlcmVkSWRzW3BhcmVudF0gPT09IFwibm9kZVwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBncm91cCBbJHtpZH1dJ3MgcGFyZW50IGlzIG5vdCBhIGdyb3VwYCk7XG4gICAgfVxuICB9XG4gIHN0YXRlLnJlY29yZHMucmVnaXN0ZXJlZElkc1tpZF0gPSBcImdyb3VwXCI7XG4gIHN0YXRlLnJlY29yZHMuZ3JvdXBzW2lkXSA9IHtcbiAgICBpZCxcbiAgICBpY29uLFxuICAgIHRpdGxlLFxuICAgIGluOiBwYXJlbnRcbiAgfTtcbn0sIFwiYWRkR3JvdXBcIik7XG52YXIgZ2V0R3JvdXBzID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiB7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKHN0YXRlLnJlY29yZHMuZ3JvdXBzKTtcbn0sIFwiZ2V0R3JvdXBzXCIpO1xudmFyIGFkZEVkZ2UgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKHtcbiAgbGhzSWQsXG4gIHJoc0lkLFxuICBsaHNEaXIsXG4gIHJoc0RpcixcbiAgbGhzSW50byxcbiAgcmhzSW50byxcbiAgbGhzR3JvdXAsXG4gIHJoc0dyb3VwLFxuICB0aXRsZVxufSkge1xuICBpZiAoIWlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uKGxoc0RpcikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgSW52YWxpZCBkaXJlY3Rpb24gZ2l2ZW4gZm9yIGxlZnQgaGFuZCBzaWRlIG9mIGVkZ2UgJHtsaHNJZH0tLSR7cmhzSWR9LiBFeHBlY3RlZCAoTCxSLFQsQikgZ290ICR7bGhzRGlyfWBcbiAgICApO1xuICB9XG4gIGlmICghaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb24ocmhzRGlyKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhbGlkIGRpcmVjdGlvbiBnaXZlbiBmb3IgcmlnaHQgaGFuZCBzaWRlIG9mIGVkZ2UgJHtsaHNJZH0tLSR7cmhzSWR9LiBFeHBlY3RlZCAoTCxSLFQsQikgZ290ICR7cmhzRGlyfWBcbiAgICApO1xuICB9XG4gIGlmIChzdGF0ZS5yZWNvcmRzLm5vZGVzW2xoc0lkXSA9PT0gdm9pZCAwICYmIHN0YXRlLnJlY29yZHMuZ3JvdXBzW2xoc0lkXSA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFRoZSBsZWZ0LWhhbmQgaWQgWyR7bGhzSWR9XSBkb2VzIG5vdCB5ZXQgZXhpc3QuIFBsZWFzZSBjcmVhdGUgdGhlIHNlcnZpY2UvZ3JvdXAgYmVmb3JlIGRlY2xhcmluZyBhbiBlZGdlIHRvIGl0LmBcbiAgICApO1xuICB9XG4gIGlmIChzdGF0ZS5yZWNvcmRzLm5vZGVzW3Joc0lkXSA9PT0gdm9pZCAwICYmIHN0YXRlLnJlY29yZHMuZ3JvdXBzW2xoc0lkXSA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFRoZSByaWdodC1oYW5kIGlkIFske3Joc0lkfV0gZG9lcyBub3QgeWV0IGV4aXN0LiBQbGVhc2UgY3JlYXRlIHRoZSBzZXJ2aWNlL2dyb3VwIGJlZm9yZSBkZWNsYXJpbmcgYW4gZWRnZSB0byBpdC5gXG4gICAgKTtcbiAgfVxuICBjb25zdCBsaHNHcm91cElkID0gc3RhdGUucmVjb3Jkcy5ub2Rlc1tsaHNJZF0uaW47XG4gIGNvbnN0IHJoc0dyb3VwSWQgPSBzdGF0ZS5yZWNvcmRzLm5vZGVzW3Joc0lkXS5pbjtcbiAgaWYgKGxoc0dyb3VwICYmIGxoc0dyb3VwSWQgJiYgcmhzR3JvdXBJZCAmJiBsaHNHcm91cElkID09IHJoc0dyb3VwSWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVGhlIGxlZnQtaGFuZCBpZCBbJHtsaHNJZH1dIGlzIG1vZGlmaWVkIHRvIHRyYXZlcnNlIHRoZSBncm91cCBib3VuZGFyeSwgYnV0IHRoZSBlZGdlIGRvZXMgbm90IHBhc3MgdGhyb3VnaCB0d28gZ3JvdXBzLmBcbiAgICApO1xuICB9XG4gIGlmIChyaHNHcm91cCAmJiBsaHNHcm91cElkICYmIHJoc0dyb3VwSWQgJiYgbGhzR3JvdXBJZCA9PSByaHNHcm91cElkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYFRoZSByaWdodC1oYW5kIGlkIFske3Joc0lkfV0gaXMgbW9kaWZpZWQgdG8gdHJhdmVyc2UgdGhlIGdyb3VwIGJvdW5kYXJ5LCBidXQgdGhlIGVkZ2UgZG9lcyBub3QgcGFzcyB0aHJvdWdoIHR3byBncm91cHMuYFxuICAgICk7XG4gIH1cbiAgY29uc3QgZWRnZSA9IHtcbiAgICBsaHNJZCxcbiAgICBsaHNEaXIsXG4gICAgbGhzSW50byxcbiAgICBsaHNHcm91cCxcbiAgICByaHNJZCxcbiAgICByaHNEaXIsXG4gICAgcmhzSW50byxcbiAgICByaHNHcm91cCxcbiAgICB0aXRsZVxuICB9O1xuICBzdGF0ZS5yZWNvcmRzLmVkZ2VzLnB1c2goZWRnZSk7XG4gIGlmIChzdGF0ZS5yZWNvcmRzLm5vZGVzW2xoc0lkXSAmJiBzdGF0ZS5yZWNvcmRzLm5vZGVzW3Joc0lkXSkge1xuICAgIHN0YXRlLnJlY29yZHMubm9kZXNbbGhzSWRdLmVkZ2VzLnB1c2goc3RhdGUucmVjb3Jkcy5lZGdlc1tzdGF0ZS5yZWNvcmRzLmVkZ2VzLmxlbmd0aCAtIDFdKTtcbiAgICBzdGF0ZS5yZWNvcmRzLm5vZGVzW3Joc0lkXS5lZGdlcy5wdXNoKHN0YXRlLnJlY29yZHMuZWRnZXNbc3RhdGUucmVjb3Jkcy5lZGdlcy5sZW5ndGggLSAxXSk7XG4gIH1cbn0sIFwiYWRkRWRnZVwiKTtcbnZhciBnZXRFZGdlcyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gc3RhdGUucmVjb3Jkcy5lZGdlcywgXCJnZXRFZGdlc1wiKTtcbnZhciBnZXREYXRhU3RydWN0dXJlcyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4ge1xuICBpZiAoc3RhdGUucmVjb3Jkcy5kYXRhU3RydWN0dXJlcyA9PT0gdm9pZCAwKSB7XG4gICAgY29uc3QgYWRqTGlzdCA9IE9iamVjdC5lbnRyaWVzKHN0YXRlLnJlY29yZHMubm9kZXMpLnJlZHVjZSgocHJldk91dGVyLCBbaWQsIHNlcnZpY2VdKSA9PiB7XG4gICAgICBwcmV2T3V0ZXJbaWRdID0gc2VydmljZS5lZGdlcy5yZWR1Y2UoKHByZXZJbm5lciwgZWRnZSkgPT4ge1xuICAgICAgICBpZiAoZWRnZS5saHNJZCA9PT0gaWQpIHtcbiAgICAgICAgICBjb25zdCBwYWlyID0gZ2V0QXJjaGl0ZWN0dXJlRGlyZWN0aW9uUGFpcihlZGdlLmxoc0RpciwgZWRnZS5yaHNEaXIpO1xuICAgICAgICAgIGlmIChwYWlyKSB7XG4gICAgICAgICAgICBwcmV2SW5uZXJbcGFpcl0gPSBlZGdlLnJoc0lkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBwYWlyID0gZ2V0QXJjaGl0ZWN0dXJlRGlyZWN0aW9uUGFpcihlZGdlLnJoc0RpciwgZWRnZS5saHNEaXIpO1xuICAgICAgICAgIGlmIChwYWlyKSB7XG4gICAgICAgICAgICBwcmV2SW5uZXJbcGFpcl0gPSBlZGdlLmxoc0lkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJldklubmVyO1xuICAgICAgfSwge30pO1xuICAgICAgcmV0dXJuIHByZXZPdXRlcjtcbiAgICB9LCB7fSk7XG4gICAgY29uc3QgZmlyc3RJZCA9IE9iamVjdC5rZXlzKGFkakxpc3QpWzBdO1xuICAgIGNvbnN0IHZpc2l0ZWQgPSB7IFtmaXJzdElkXTogMSB9O1xuICAgIGNvbnN0IG5vdFZpc2l0ZWQgPSBPYmplY3Qua2V5cyhhZGpMaXN0KS5yZWR1Y2UoXG4gICAgICAocHJldiwgaWQpID0+IGlkID09PSBmaXJzdElkID8gcHJldiA6IHsgLi4ucHJldiwgW2lkXTogMSB9LFxuICAgICAge31cbiAgICApO1xuICAgIGNvbnN0IEJGUyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHN0YXJ0aW5nSWQpID0+IHtcbiAgICAgIGNvbnN0IHNwYXRpYWxNYXAgPSB7IFtzdGFydGluZ0lkXTogWzAsIDBdIH07XG4gICAgICBjb25zdCBxdWV1ZSA9IFtzdGFydGluZ0lkXTtcbiAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGlkID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgdmlzaXRlZFtpZF0gPSAxO1xuICAgICAgICAgIGRlbGV0ZSBub3RWaXNpdGVkW2lkXTtcbiAgICAgICAgICBjb25zdCBhZGogPSBhZGpMaXN0W2lkXTtcbiAgICAgICAgICBjb25zdCBbcG9zWCwgcG9zWV0gPSBzcGF0aWFsTWFwW2lkXTtcbiAgICAgICAgICBPYmplY3QuZW50cmllcyhhZGopLmZvckVhY2goKFtkaXIsIHJoc0lkXSkgPT4ge1xuICAgICAgICAgICAgaWYgKCF2aXNpdGVkW3Joc0lkXSkge1xuICAgICAgICAgICAgICBzcGF0aWFsTWFwW3Joc0lkXSA9IHNoaWZ0UG9zaXRpb25CeUFyY2hpdGVjdHVyZURpcmVjdGlvblBhaXIoXG4gICAgICAgICAgICAgICAgW3Bvc1gsIHBvc1ldLFxuICAgICAgICAgICAgICAgIGRpclxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBxdWV1ZS5wdXNoKHJoc0lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNwYXRpYWxNYXA7XG4gICAgfSwgXCJCRlNcIik7XG4gICAgY29uc3Qgc3BhdGlhbE1hcHMgPSBbQkZTKGZpcnN0SWQpXTtcbiAgICB3aGlsZSAoT2JqZWN0LmtleXMobm90VmlzaXRlZCkubGVuZ3RoID4gMCkge1xuICAgICAgc3BhdGlhbE1hcHMucHVzaChCRlMoT2JqZWN0LmtleXMobm90VmlzaXRlZClbMF0pKTtcbiAgICB9XG4gICAgc3RhdGUucmVjb3Jkcy5kYXRhU3RydWN0dXJlcyA9IHtcbiAgICAgIGFkakxpc3QsXG4gICAgICBzcGF0aWFsTWFwc1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIHN0YXRlLnJlY29yZHMuZGF0YVN0cnVjdHVyZXM7XG59LCBcImdldERhdGFTdHJ1Y3R1cmVzXCIpO1xudmFyIHNldEVsZW1lbnRGb3JJZCA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGlkLCBlbGVtZW50KSA9PiB7XG4gIHN0YXRlLnJlY29yZHMuZWxlbWVudHNbaWRdID0gZWxlbWVudDtcbn0sIFwic2V0RWxlbWVudEZvcklkXCIpO1xudmFyIGdldEVsZW1lbnRCeUlkID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoaWQpID0+IHN0YXRlLnJlY29yZHMuZWxlbWVudHNbaWRdLCBcImdldEVsZW1lbnRCeUlkXCIpO1xudmFyIGRiID0ge1xuICBjbGVhcjogY2xlYXIyLFxuICBzZXREaWFncmFtVGl0bGUsXG4gIGdldERpYWdyYW1UaXRsZSxcbiAgc2V0QWNjVGl0bGUsXG4gIGdldEFjY1RpdGxlLFxuICBzZXRBY2NEZXNjcmlwdGlvbixcbiAgZ2V0QWNjRGVzY3JpcHRpb24sXG4gIGFkZFNlcnZpY2UsXG4gIGdldFNlcnZpY2VzLFxuICBhZGRKdW5jdGlvbixcbiAgZ2V0SnVuY3Rpb25zLFxuICBnZXROb2RlcyxcbiAgZ2V0Tm9kZSxcbiAgYWRkR3JvdXAsXG4gIGdldEdyb3VwcyxcbiAgYWRkRWRnZSxcbiAgZ2V0RWRnZXMsXG4gIHNldEVsZW1lbnRGb3JJZCxcbiAgZ2V0RWxlbWVudEJ5SWQsXG4gIGdldERhdGFTdHJ1Y3R1cmVzXG59O1xuZnVuY3Rpb24gZ2V0Q29uZmlnRmllbGQoZmllbGQpIHtcbiAgY29uc3QgYXJjaCA9IGdldENvbmZpZygpLmFyY2hpdGVjdHVyZTtcbiAgaWYgKGFyY2g/LltmaWVsZF0pIHtcbiAgICByZXR1cm4gYXJjaFtmaWVsZF07XG4gIH1cbiAgcmV0dXJuIERFRkFVTFRfQVJDSElURUNUVVJFX0NPTkZJR1tmaWVsZF07XG59XG5fX25hbWUoZ2V0Q29uZmlnRmllbGQsIFwiZ2V0Q29uZmlnRmllbGRcIik7XG5cbi8vIHNyYy9kaWFncmFtcy9hcmNoaXRlY3R1cmUvYXJjaGl0ZWN0dXJlUGFyc2VyLnRzXG52YXIgcG9wdWxhdGVEYiA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKGFzdCwgZGIyKSA9PiB7XG4gIHBvcHVsYXRlQ29tbW9uRGIoYXN0LCBkYjIpO1xuICBhc3QuZ3JvdXBzLm1hcChkYjIuYWRkR3JvdXApO1xuICBhc3Quc2VydmljZXMubWFwKChzZXJ2aWNlKSA9PiBkYjIuYWRkU2VydmljZSh7IC4uLnNlcnZpY2UsIHR5cGU6IFwic2VydmljZVwiIH0pKTtcbiAgYXN0Lmp1bmN0aW9ucy5tYXAoKHNlcnZpY2UpID0+IGRiMi5hZGRKdW5jdGlvbih7IC4uLnNlcnZpY2UsIHR5cGU6IFwianVuY3Rpb25cIiB9KSk7XG4gIGFzdC5lZGdlcy5tYXAoZGIyLmFkZEVkZ2UpO1xufSwgXCJwb3B1bGF0ZURiXCIpO1xudmFyIHBhcnNlciA9IHtcbiAgcGFyc2U6IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoYXN5bmMgKGlucHV0KSA9PiB7XG4gICAgY29uc3QgYXN0ID0gYXdhaXQgcGFyc2UoXCJhcmNoaXRlY3R1cmVcIiwgaW5wdXQpO1xuICAgIGxvZy5kZWJ1Zyhhc3QpO1xuICAgIHBvcHVsYXRlRGIoYXN0LCBkYik7XG4gIH0sIFwicGFyc2VcIilcbn07XG5cbi8vIHNyYy9kaWFncmFtcy9hcmNoaXRlY3R1cmUvYXJjaGl0ZWN0dXJlU3R5bGVzLnRzXG52YXIgZ2V0U3R5bGVzID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgob3B0aW9ucykgPT4gYFxuICAuZWRnZSB7XG4gICAgc3Ryb2tlLXdpZHRoOiAke29wdGlvbnMuYXJjaEVkZ2VXaWR0aH07XG4gICAgc3Ryb2tlOiAke29wdGlvbnMuYXJjaEVkZ2VDb2xvcn07XG4gICAgZmlsbDogbm9uZTtcbiAgfVxuXG4gIC5hcnJvdyB7XG4gICAgZmlsbDogJHtvcHRpb25zLmFyY2hFZGdlQXJyb3dDb2xvcn07XG4gIH1cblxuICAubm9kZS1ia2cge1xuICAgIGZpbGw6IG5vbmU7XG4gICAgc3Ryb2tlOiAke29wdGlvbnMuYXJjaEdyb3VwQm9yZGVyQ29sb3J9O1xuICAgIHN0cm9rZS13aWR0aDogJHtvcHRpb25zLmFyY2hHcm91cEJvcmRlcldpZHRofTtcbiAgICBzdHJva2UtZGFzaGFycmF5OiA4O1xuICB9XG4gIC5ub2RlLWljb24tdGV4dCB7XG4gICAgZGlzcGxheTogZmxleDsgXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgfVxuICBcbiAgLm5vZGUtaWNvbi10ZXh0ID4gZGl2IHtcbiAgICBjb2xvcjogI2ZmZjtcbiAgICBtYXJnaW46IDFweDtcbiAgICBoZWlnaHQ6IGZpdC1jb250ZW50O1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIGRpc3BsYXk6IC13ZWJraXQtYm94O1xuICAgIC13ZWJraXQtYm94LW9yaWVudDogdmVydGljYWw7XG4gIH1cbmAsIFwiZ2V0U3R5bGVzXCIpO1xudmFyIGFyY2hpdGVjdHVyZVN0eWxlc19kZWZhdWx0ID0gZ2V0U3R5bGVzO1xuXG4vLyBzcmMvZGlhZ3JhbXMvYXJjaGl0ZWN0dXJlL2FyY2hpdGVjdHVyZVJlbmRlcmVyLnRzXG5pbXBvcnQgY3l0b3NjYXBlIGZyb20gXCJjeXRvc2NhcGVcIjtcbmltcG9ydCBmY29zZSBmcm9tIFwiY3l0b3NjYXBlLWZjb3NlXCI7XG5pbXBvcnQgeyBzZWxlY3QgfSBmcm9tIFwiZDNcIjtcblxuLy8gc3JjL2RpYWdyYW1zL2FyY2hpdGVjdHVyZS9hcmNoaXRlY3R1cmVJY29ucy50c1xudmFyIHdyYXBJY29uID0gLyogQF9fUFVSRV9fICovIF9fbmFtZSgoaWNvbikgPT4ge1xuICByZXR1cm4gYDxnPjxyZWN0IHdpZHRoPVwiODBcIiBoZWlnaHQ9XCI4MFwiIHN0eWxlPVwiZmlsbDogIzA4N2ViZjsgc3Ryb2tlLXdpZHRoOiAwcHg7XCIvPiR7aWNvbn08L2c+YDtcbn0sIFwid3JhcEljb25cIik7XG52YXIgYXJjaGl0ZWN0dXJlSWNvbnMgPSB7XG4gIHByZWZpeDogXCJtZXJtYWlkLWFyY2hpdGVjdHVyZVwiLFxuICBoZWlnaHQ6IDgwLFxuICB3aWR0aDogODAsXG4gIGljb25zOiB7XG4gICAgZGF0YWJhc2U6IHtcbiAgICAgIGJvZHk6IHdyYXBJY29uKFxuICAgICAgICAnPHBhdGggaWQ9XCJiXCIgZGF0YS1uYW1lPVwiNFwiIGQ9XCJtMjAsNTcuODZjMCwzLjk0LDguOTUsNy4xNCwyMCw3LjE0czIwLTMuMiwyMC03LjE0XCIgc3R5bGU9XCJmaWxsOiBub25lOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDsgc3Ryb2tlLXdpZHRoOiAycHg7XCIvPjxwYXRoIGlkPVwiY1wiIGRhdGEtbmFtZT1cIjNcIiBkPVwibTIwLDQ1Ljk1YzAsMy45NCw4Ljk1LDcuMTQsMjAsNy4xNHMyMC0zLjIsMjAtNy4xNFwiIHN0eWxlPVwiZmlsbDogbm9uZTsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7IHN0cm9rZS13aWR0aDogMnB4O1wiLz48cGF0aCBpZD1cImRcIiBkYXRhLW5hbWU9XCIyXCIgZD1cIm0yMCwzNC4wNWMwLDMuOTQsOC45NSw3LjE0LDIwLDcuMTRzMjAtMy4yLDIwLTcuMTRcIiBzdHlsZT1cImZpbGw6IG5vbmU7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOyBzdHJva2Utd2lkdGg6IDJweDtcIi8+PGVsbGlwc2UgaWQ9XCJlXCIgZGF0YS1uYW1lPVwiMVwiIGN4PVwiNDBcIiBjeT1cIjIyLjE0XCIgcng9XCIyMFwiIHJ5PVwiNy4xNFwiIHN0eWxlPVwiZmlsbDogbm9uZTsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7IHN0cm9rZS13aWR0aDogMnB4O1wiLz48bGluZSB4MT1cIjIwXCIgeTE9XCI1Ny44NlwiIHgyPVwiMjBcIiB5Mj1cIjIyLjE0XCIgc3R5bGU9XCJmaWxsOiBub25lOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDsgc3Ryb2tlLXdpZHRoOiAycHg7XCIvPjxsaW5lIHgxPVwiNjBcIiB5MT1cIjU3Ljg2XCIgeDI9XCI2MFwiIHkyPVwiMjIuMTRcIiBzdHlsZT1cImZpbGw6IG5vbmU7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOyBzdHJva2Utd2lkdGg6IDJweDtcIi8+J1xuICAgICAgKVxuICAgIH0sXG4gICAgc2VydmVyOiB7XG4gICAgICBib2R5OiB3cmFwSWNvbihcbiAgICAgICAgJzxyZWN0IHg9XCIxNy41XCIgeT1cIjE3LjVcIiB3aWR0aD1cIjQ1XCIgaGVpZ2h0PVwiNDVcIiByeD1cIjJcIiByeT1cIjJcIiBzdHlsZT1cImZpbGw6IG5vbmU7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOyBzdHJva2Utd2lkdGg6IDJweDtcIi8+PGxpbmUgeDE9XCIxNy41XCIgeTE9XCIzMi41XCIgeDI9XCI2Mi41XCIgeTI9XCIzMi41XCIgc3R5bGU9XCJmaWxsOiBub25lOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDsgc3Ryb2tlLXdpZHRoOiAycHg7XCIvPjxsaW5lIHgxPVwiMTcuNVwiIHkxPVwiNDcuNVwiIHgyPVwiNjIuNVwiIHkyPVwiNDcuNVwiIHN0eWxlPVwiZmlsbDogbm9uZTsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7IHN0cm9rZS13aWR0aDogMnB4O1wiLz48Zz48cGF0aCBkPVwibTU2LjI1LDI1YzAsLjI3LS40NS41LTEsLjVoLTEwLjVjLS41NSwwLTEtLjIzLTEtLjVzLjQ1LS41LDEtLjVoMTAuNWMuNTUsMCwxLC4yMywxLC41WlwiIHN0eWxlPVwiZmlsbDogI2ZmZjsgc3Ryb2tlLXdpZHRoOiAwcHg7XCIvPjxwYXRoIGQ9XCJtNTYuMjUsMjVjMCwuMjctLjQ1LjUtMSwuNWgtMTAuNWMtLjU1LDAtMS0uMjMtMS0uNXMuNDUtLjUsMS0uNWgxMC41Yy41NSwwLDEsLjIzLDEsLjVaXCIgc3R5bGU9XCJmaWxsOiBub25lOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDtcIi8+PC9nPjxnPjxwYXRoIGQ9XCJtNTYuMjUsNDBjMCwuMjctLjQ1LjUtMSwuNWgtMTAuNWMtLjU1LDAtMS0uMjMtMS0uNXMuNDUtLjUsMS0uNWgxMC41Yy41NSwwLDEsLjIzLDEsLjVaXCIgc3R5bGU9XCJmaWxsOiAjZmZmOyBzdHJva2Utd2lkdGg6IDBweDtcIi8+PHBhdGggZD1cIm01Ni4yNSw0MGMwLC4yNy0uNDUuNS0xLC41aC0xMC41Yy0uNTUsMC0xLS4yMy0xLS41cy40NS0uNSwxLS41aDEwLjVjLjU1LDAsMSwuMjMsMSwuNVpcIiBzdHlsZT1cImZpbGw6IG5vbmU7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwO1wiLz48L2c+PGc+PHBhdGggZD1cIm01Ni4yNSw1NWMwLC4yNy0uNDUuNS0xLC41aC0xMC41Yy0uNTUsMC0xLS4yMy0xLS41cy40NS0uNSwxLS41aDEwLjVjLjU1LDAsMSwuMjMsMSwuNVpcIiBzdHlsZT1cImZpbGw6ICNmZmY7IHN0cm9rZS13aWR0aDogMHB4O1wiLz48cGF0aCBkPVwibTU2LjI1LDU1YzAsLjI3LS40NS41LTEsLjVoLTEwLjVjLS41NSwwLTEtLjIzLTEtLjVzLjQ1LS41LDEtLjVoMTAuNWMuNTUsMCwxLC4yMywxLC41WlwiIHN0eWxlPVwiZmlsbDogbm9uZTsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7XCIvPjwvZz48Zz48Y2lyY2xlIGN4PVwiMzIuNVwiIGN5PVwiMjVcIiByPVwiLjc1XCIgc3R5bGU9XCJmaWxsOiAjZmZmOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDtcIi8+PGNpcmNsZSBjeD1cIjI3LjVcIiBjeT1cIjI1XCIgcj1cIi43NVwiIHN0eWxlPVwiZmlsbDogI2ZmZjsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7XCIvPjxjaXJjbGUgY3g9XCIyMi41XCIgY3k9XCIyNVwiIHI9XCIuNzVcIiBzdHlsZT1cImZpbGw6ICNmZmY7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwO1wiLz48L2c+PGc+PGNpcmNsZSBjeD1cIjMyLjVcIiBjeT1cIjQwXCIgcj1cIi43NVwiIHN0eWxlPVwiZmlsbDogI2ZmZjsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7XCIvPjxjaXJjbGUgY3g9XCIyNy41XCIgY3k9XCI0MFwiIHI9XCIuNzVcIiBzdHlsZT1cImZpbGw6ICNmZmY7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwO1wiLz48Y2lyY2xlIGN4PVwiMjIuNVwiIGN5PVwiNDBcIiByPVwiLjc1XCIgc3R5bGU9XCJmaWxsOiAjZmZmOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDtcIi8+PC9nPjxnPjxjaXJjbGUgY3g9XCIzMi41XCIgY3k9XCI1NVwiIHI9XCIuNzVcIiBzdHlsZT1cImZpbGw6ICNmZmY7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwO1wiLz48Y2lyY2xlIGN4PVwiMjcuNVwiIGN5PVwiNTVcIiByPVwiLjc1XCIgc3R5bGU9XCJmaWxsOiAjZmZmOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDtcIi8+PGNpcmNsZSBjeD1cIjIyLjVcIiBjeT1cIjU1XCIgcj1cIi43NVwiIHN0eWxlPVwiZmlsbDogI2ZmZjsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7XCIvPjwvZz4nXG4gICAgICApXG4gICAgfSxcbiAgICBkaXNrOiB7XG4gICAgICBib2R5OiB3cmFwSWNvbihcbiAgICAgICAgJzxyZWN0IHg9XCIyMFwiIHk9XCIxNVwiIHdpZHRoPVwiNDBcIiBoZWlnaHQ9XCI1MFwiIHJ4PVwiMVwiIHJ5PVwiMVwiIHN0eWxlPVwiZmlsbDogbm9uZTsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7IHN0cm9rZS13aWR0aDogMnB4O1wiLz48ZWxsaXBzZSBjeD1cIjI0XCIgY3k9XCIxOS4xN1wiIHJ4PVwiLjhcIiByeT1cIi44M1wiIHN0eWxlPVwiZmlsbDogbm9uZTsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7IHN0cm9rZS13aWR0aDogMnB4O1wiLz48ZWxsaXBzZSBjeD1cIjU2XCIgY3k9XCIxOS4xN1wiIHJ4PVwiLjhcIiByeT1cIi44M1wiIHN0eWxlPVwiZmlsbDogbm9uZTsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7IHN0cm9rZS13aWR0aDogMnB4O1wiLz48ZWxsaXBzZSBjeD1cIjI0XCIgY3k9XCI2MC44M1wiIHJ4PVwiLjhcIiByeT1cIi44M1wiIHN0eWxlPVwiZmlsbDogbm9uZTsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7IHN0cm9rZS13aWR0aDogMnB4O1wiLz48ZWxsaXBzZSBjeD1cIjU2XCIgY3k9XCI2MC44M1wiIHJ4PVwiLjhcIiByeT1cIi44M1wiIHN0eWxlPVwiZmlsbDogbm9uZTsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7IHN0cm9rZS13aWR0aDogMnB4O1wiLz48ZWxsaXBzZSBjeD1cIjQwXCIgY3k9XCIzMy43NVwiIHJ4PVwiMTRcIiByeT1cIjE0LjU4XCIgc3R5bGU9XCJmaWxsOiBub25lOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDsgc3Ryb2tlLXdpZHRoOiAycHg7XCIvPjxlbGxpcHNlIGN4PVwiNDBcIiBjeT1cIjMzLjc1XCIgcng9XCI0XCIgcnk9XCI0LjE3XCIgc3R5bGU9XCJmaWxsOiAjZmZmOyBzdHJva2U6ICNmZmY7IHN0cm9rZS1taXRlcmxpbWl0OiAxMDsgc3Ryb2tlLXdpZHRoOiAycHg7XCIvPjxwYXRoIGQ9XCJtMzcuNTEsNDIuNTJsLTQuODMsMTMuMjJjLS4yNi43MS0xLjEsMS4wMi0xLjc2LjY0bC00LjE4LTIuNDJjLS42Ni0uMzgtLjgxLTEuMjYtLjMzLTEuODRsOS4wMS0xMC44Yy44OC0xLjA1LDIuNTYtLjA4LDIuMDksMS4yWlwiIHN0eWxlPVwiZmlsbDogI2ZmZjsgc3Ryb2tlLXdpZHRoOiAwcHg7XCIvPidcbiAgICAgIClcbiAgICB9LFxuICAgIGludGVybmV0OiB7XG4gICAgICBib2R5OiB3cmFwSWNvbihcbiAgICAgICAgJzxjaXJjbGUgY3g9XCI0MFwiIGN5PVwiNDBcIiByPVwiMjIuNVwiIHN0eWxlPVwiZmlsbDogbm9uZTsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7IHN0cm9rZS13aWR0aDogMnB4O1wiLz48bGluZSB4MT1cIjQwXCIgeTE9XCIxNy41XCIgeDI9XCI0MFwiIHkyPVwiNjIuNVwiIHN0eWxlPVwiZmlsbDogbm9uZTsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7IHN0cm9rZS13aWR0aDogMnB4O1wiLz48bGluZSB4MT1cIjE3LjVcIiB5MT1cIjQwXCIgeDI9XCI2Mi41XCIgeTI9XCI0MFwiIHN0eWxlPVwiZmlsbDogbm9uZTsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7IHN0cm9rZS13aWR0aDogMnB4O1wiLz48cGF0aCBkPVwibTM5Ljk5LDE3LjUxYy0xNS4yOCwxMS4xLTE1LjI4LDMzLjg4LDAsNDQuOThcIiBzdHlsZT1cImZpbGw6IG5vbmU7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOyBzdHJva2Utd2lkdGg6IDJweDtcIi8+PHBhdGggZD1cIm00MC4wMSwxNy41MWMxNS4yOCwxMS4xLDE1LjI4LDMzLjg4LDAsNDQuOThcIiBzdHlsZT1cImZpbGw6IG5vbmU7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOyBzdHJva2Utd2lkdGg6IDJweDtcIi8+PGxpbmUgeDE9XCIxOS43NVwiIHkxPVwiMzAuMVwiIHgyPVwiNjAuMjVcIiB5Mj1cIjMwLjFcIiBzdHlsZT1cImZpbGw6IG5vbmU7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOyBzdHJva2Utd2lkdGg6IDJweDtcIi8+PGxpbmUgeDE9XCIxOS43NVwiIHkxPVwiNDkuOVwiIHgyPVwiNjAuMjVcIiB5Mj1cIjQ5LjlcIiBzdHlsZT1cImZpbGw6IG5vbmU7IHN0cm9rZTogI2ZmZjsgc3Ryb2tlLW1pdGVybGltaXQ6IDEwOyBzdHJva2Utd2lkdGg6IDJweDtcIi8+J1xuICAgICAgKVxuICAgIH0sXG4gICAgY2xvdWQ6IHtcbiAgICAgIGJvZHk6IHdyYXBJY29uKFxuICAgICAgICAnPHBhdGggZD1cIm02NSw0Ny41YzAsMi43Ni0yLjI0LDUtNSw1SDIwYy0yLjc2LDAtNS0yLjI0LTUtNSwwLTEuODcsMS4wMy0zLjUxLDIuNTYtNC4zNi0uMDQtLjIxLS4wNi0uNDItLjA2LS42NCwwLTIuNiwyLjQ4LTQuNzQsNS42NS00Ljk3LDEuNjUtNC41MSw2LjM0LTcuNzYsMTEuODUtNy43Ni44NiwwLDEuNjkuMDgsMi41LjIzLDIuMDktMS41Nyw0LjY5LTIuNSw3LjUtMi41LDYuMSwwLDExLjE5LDQuMzgsMTIuMjgsMTAuMTcsMi4xNC41NiwzLjcyLDIuNTEsMy43Miw0LjgzLDAsLjAzLDAsLjA3LS4wMS4xLDIuMjkuNDYsNC4wMSwyLjQ4LDQuMDEsNC45WlwiIHN0eWxlPVwiZmlsbDogbm9uZTsgc3Ryb2tlOiAjZmZmOyBzdHJva2UtbWl0ZXJsaW1pdDogMTA7IHN0cm9rZS13aWR0aDogMnB4O1wiLz4nXG4gICAgICApXG4gICAgfSxcbiAgICB1bmtub3duOiB1bmtub3duSWNvbixcbiAgICBibGFuazoge1xuICAgICAgYm9keTogd3JhcEljb24oXCJcIilcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9kaWFncmFtcy9hcmNoaXRlY3R1cmUvc3ZnRHJhdy50c1xudmFyIGRyYXdFZGdlcyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoYXN5bmMgZnVuY3Rpb24oZWRnZXNFbCwgY3kpIHtcbiAgY29uc3QgcGFkZGluZyA9IGdldENvbmZpZ0ZpZWxkKFwicGFkZGluZ1wiKTtcbiAgY29uc3QgaWNvblNpemUgPSBnZXRDb25maWdGaWVsZChcImljb25TaXplXCIpO1xuICBjb25zdCBoYWxmSWNvblNpemUgPSBpY29uU2l6ZSAvIDI7XG4gIGNvbnN0IGFycm93U2l6ZSA9IGljb25TaXplIC8gNjtcbiAgY29uc3QgaGFsZkFycm93U2l6ZSA9IGFycm93U2l6ZSAvIDI7XG4gIGF3YWl0IFByb21pc2UuYWxsKFxuICAgIGN5LmVkZ2VzKCkubWFwKGFzeW5jIChlZGdlKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgc291cmNlRGlyLFxuICAgICAgICBzb3VyY2VBcnJvdyxcbiAgICAgICAgc291cmNlR3JvdXAsXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgdGFyZ2V0RGlyLFxuICAgICAgICB0YXJnZXRBcnJvdyxcbiAgICAgICAgdGFyZ2V0R3JvdXAsXG4gICAgICAgIGxhYmVsXG4gICAgICB9ID0gZWRnZURhdGEoZWRnZSk7XG4gICAgICBsZXQgeyB4OiBzdGFydFgsIHk6IHN0YXJ0WSB9ID0gZWRnZVswXS5zb3VyY2VFbmRwb2ludCgpO1xuICAgICAgY29uc3QgeyB4OiBtaWRYLCB5OiBtaWRZIH0gPSBlZGdlWzBdLm1pZHBvaW50KCk7XG4gICAgICBsZXQgeyB4OiBlbmRYLCB5OiBlbmRZIH0gPSBlZGdlWzBdLnRhcmdldEVuZHBvaW50KCk7XG4gICAgICBjb25zdCBncm91cEVkZ2VTaGlmdCA9IHBhZGRpbmcgKyA0O1xuICAgICAgaWYgKHNvdXJjZUdyb3VwKSB7XG4gICAgICAgIGlmIChpc0FyY2hpdGVjdHVyZURpcmVjdGlvblgoc291cmNlRGlyKSkge1xuICAgICAgICAgIHN0YXJ0WCArPSBzb3VyY2VEaXIgPT09IFwiTFwiID8gLWdyb3VwRWRnZVNoaWZ0IDogZ3JvdXBFZGdlU2hpZnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhcnRZICs9IHNvdXJjZURpciA9PT0gXCJUXCIgPyAtZ3JvdXBFZGdlU2hpZnQgOiBncm91cEVkZ2VTaGlmdCArIDE4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGFyZ2V0R3JvdXApIHtcbiAgICAgICAgaWYgKGlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uWCh0YXJnZXREaXIpKSB7XG4gICAgICAgICAgZW5kWCArPSB0YXJnZXREaXIgPT09IFwiTFwiID8gLWdyb3VwRWRnZVNoaWZ0IDogZ3JvdXBFZGdlU2hpZnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kWSArPSB0YXJnZXREaXIgPT09IFwiVFwiID8gLWdyb3VwRWRnZVNoaWZ0IDogZ3JvdXBFZGdlU2hpZnQgKyAxODtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFzb3VyY2VHcm91cCAmJiBkYi5nZXROb2RlKHNvdXJjZSk/LnR5cGUgPT09IFwianVuY3Rpb25cIikge1xuICAgICAgICBpZiAoaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb25YKHNvdXJjZURpcikpIHtcbiAgICAgICAgICBzdGFydFggKz0gc291cmNlRGlyID09PSBcIkxcIiA/IGhhbGZJY29uU2l6ZSA6IC1oYWxmSWNvblNpemU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhcnRZICs9IHNvdXJjZURpciA9PT0gXCJUXCIgPyBoYWxmSWNvblNpemUgOiAtaGFsZkljb25TaXplO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXRhcmdldEdyb3VwICYmIGRiLmdldE5vZGUodGFyZ2V0KT8udHlwZSA9PT0gXCJqdW5jdGlvblwiKSB7XG4gICAgICAgIGlmIChpc0FyY2hpdGVjdHVyZURpcmVjdGlvblgodGFyZ2V0RGlyKSkge1xuICAgICAgICAgIGVuZFggKz0gdGFyZ2V0RGlyID09PSBcIkxcIiA/IGhhbGZJY29uU2l6ZSA6IC1oYWxmSWNvblNpemU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kWSArPSB0YXJnZXREaXIgPT09IFwiVFwiID8gaGFsZkljb25TaXplIDogLWhhbGZJY29uU2l6ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVkZ2VbMF0uX3ByaXZhdGUucnNjcmF0Y2gpIHtcbiAgICAgICAgY29uc3QgZyA9IGVkZ2VzRWwuaW5zZXJ0KFwiZ1wiKTtcbiAgICAgICAgZy5pbnNlcnQoXCJwYXRoXCIpLmF0dHIoXCJkXCIsIGBNICR7c3RhcnRYfSwke3N0YXJ0WX0gTCAke21pZFh9LCR7bWlkWX0gTCR7ZW5kWH0sJHtlbmRZfSBgKS5hdHRyKFwiY2xhc3NcIiwgXCJlZGdlXCIpO1xuICAgICAgICBpZiAoc291cmNlQXJyb3cpIHtcbiAgICAgICAgICBjb25zdCB4U2hpZnQgPSBpc0FyY2hpdGVjdHVyZURpcmVjdGlvblgoc291cmNlRGlyKSA/IEFyY2hpdGVjdHVyZURpcmVjdGlvbkFycm93U2hpZnRbc291cmNlRGlyXShzdGFydFgsIGFycm93U2l6ZSkgOiBzdGFydFggLSBoYWxmQXJyb3dTaXplO1xuICAgICAgICAgIGNvbnN0IHlTaGlmdCA9IGlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uWShzb3VyY2VEaXIpID8gQXJjaGl0ZWN0dXJlRGlyZWN0aW9uQXJyb3dTaGlmdFtzb3VyY2VEaXJdKHN0YXJ0WSwgYXJyb3dTaXplKSA6IHN0YXJ0WSAtIGhhbGZBcnJvd1NpemU7XG4gICAgICAgICAgZy5pbnNlcnQoXCJwb2x5Z29uXCIpLmF0dHIoXCJwb2ludHNcIiwgQXJjaGl0ZWN0dXJlRGlyZWN0aW9uQXJyb3dbc291cmNlRGlyXShhcnJvd1NpemUpKS5hdHRyKFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoJHt4U2hpZnR9LCR7eVNoaWZ0fSlgKS5hdHRyKFwiY2xhc3NcIiwgXCJhcnJvd1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0QXJyb3cpIHtcbiAgICAgICAgICBjb25zdCB4U2hpZnQgPSBpc0FyY2hpdGVjdHVyZURpcmVjdGlvblgodGFyZ2V0RGlyKSA/IEFyY2hpdGVjdHVyZURpcmVjdGlvbkFycm93U2hpZnRbdGFyZ2V0RGlyXShlbmRYLCBhcnJvd1NpemUpIDogZW5kWCAtIGhhbGZBcnJvd1NpemU7XG4gICAgICAgICAgY29uc3QgeVNoaWZ0ID0gaXNBcmNoaXRlY3R1cmVEaXJlY3Rpb25ZKHRhcmdldERpcikgPyBBcmNoaXRlY3R1cmVEaXJlY3Rpb25BcnJvd1NoaWZ0W3RhcmdldERpcl0oZW5kWSwgYXJyb3dTaXplKSA6IGVuZFkgLSBoYWxmQXJyb3dTaXplO1xuICAgICAgICAgIGcuaW5zZXJ0KFwicG9seWdvblwiKS5hdHRyKFwicG9pbnRzXCIsIEFyY2hpdGVjdHVyZURpcmVjdGlvbkFycm93W3RhcmdldERpcl0oYXJyb3dTaXplKSkuYXR0cihcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKCR7eFNoaWZ0fSwke3lTaGlmdH0pYCkuYXR0cihcImNsYXNzXCIsIFwiYXJyb3dcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgY29uc3QgYXhpcyA9ICFpc0FyY2hpdGVjdHVyZURpcmVjdGlvblhZKHNvdXJjZURpciwgdGFyZ2V0RGlyKSA/IGlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uWChzb3VyY2VEaXIpID8gXCJYXCIgOiBcIllcIiA6IFwiWFlcIjtcbiAgICAgICAgICBsZXQgd2lkdGggPSAwO1xuICAgICAgICAgIGlmIChheGlzID09PSBcIlhcIikge1xuICAgICAgICAgICAgd2lkdGggPSBNYXRoLmFicyhzdGFydFggLSBlbmRYKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGF4aXMgPT09IFwiWVwiKSB7XG4gICAgICAgICAgICB3aWR0aCA9IE1hdGguYWJzKHN0YXJ0WSAtIGVuZFkpIC8gMS41O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3aWR0aCA9IE1hdGguYWJzKHN0YXJ0WCAtIGVuZFgpIC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdGV4dEVsZW0gPSBnLmFwcGVuZChcImdcIik7XG4gICAgICAgICAgYXdhaXQgY3JlYXRlVGV4dChcbiAgICAgICAgICAgIHRleHRFbGVtLFxuICAgICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHVzZUh0bWxMYWJlbHM6IGZhbHNlLFxuICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgY2xhc3NlczogXCJhcmNoaXRlY3R1cmUtc2VydmljZS1sYWJlbFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Q29uZmlnKClcbiAgICAgICAgICApO1xuICAgICAgICAgIHRleHRFbGVtLmF0dHIoXCJkeVwiLCBcIjFlbVwiKS5hdHRyKFwiYWxpZ25tZW50LWJhc2VsaW5lXCIsIFwibWlkZGxlXCIpLmF0dHIoXCJkb21pbmFudC1iYXNlbGluZVwiLCBcIm1pZGRsZVwiKS5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIik7XG4gICAgICAgICAgaWYgKGF4aXMgPT09IFwiWFwiKSB7XG4gICAgICAgICAgICB0ZXh0RWxlbS5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgbWlkWCArIFwiLCBcIiArIG1pZFkgKyBcIilcIik7XG4gICAgICAgICAgfSBlbHNlIGlmIChheGlzID09PSBcIllcIikge1xuICAgICAgICAgICAgdGV4dEVsZW0uYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIG1pZFggKyBcIiwgXCIgKyBtaWRZICsgXCIpIHJvdGF0ZSgtOTApXCIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gXCJYWVwiKSB7XG4gICAgICAgICAgICBjb25zdCBwYWlyID0gZ2V0QXJjaGl0ZWN0dXJlRGlyZWN0aW9uUGFpcihzb3VyY2VEaXIsIHRhcmdldERpcik7XG4gICAgICAgICAgICBpZiAocGFpciAmJiBpc0FyY2hpdGVjdHVyZVBhaXJYWShwYWlyKSkge1xuICAgICAgICAgICAgICBjb25zdCBiYm94T3JpZyA9IHRleHRFbGVtLm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgY29uc3QgW3gsIHldID0gZ2V0QXJjaGl0ZWN0dXJlRGlyZWN0aW9uWFlGYWN0b3JzKHBhaXIpO1xuICAgICAgICAgICAgICB0ZXh0RWxlbS5hdHRyKFwiZG9taW5hbnQtYmFzZWxpbmVcIiwgXCJhdXRvXCIpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYHJvdGF0ZSgkey0xICogeCAqIHkgKiA0NX0pYCk7XG4gICAgICAgICAgICAgIGNvbnN0IGJib3hOZXcgPSB0ZXh0RWxlbS5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgIHRleHRFbGVtLmF0dHIoXG4gICAgICAgICAgICAgICAgXCJ0cmFuc2Zvcm1cIixcbiAgICAgICAgICAgICAgICBgXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlKCR7bWlkWH0sICR7bWlkWSAtIGJib3hPcmlnLmhlaWdodCAvIDJ9KVxuICAgICAgICAgICAgICAgIHRyYW5zbGF0ZSgke3ggKiBiYm94TmV3LndpZHRoIC8gMn0sICR7eSAqIGJib3hOZXcuaGVpZ2h0IC8gMn0pXG4gICAgICAgICAgICAgICAgcm90YXRlKCR7LTEgKiB4ICogeSAqIDQ1fSwgMCwgJHtiYm94T3JpZy5oZWlnaHQgLyAyfSlcbiAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gICk7XG59LCBcImRyYXdFZGdlc1wiKTtcbnZhciBkcmF3R3JvdXBzID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShhc3luYyBmdW5jdGlvbihncm91cHNFbCwgY3kpIHtcbiAgY29uc3QgcGFkZGluZyA9IGdldENvbmZpZ0ZpZWxkKFwicGFkZGluZ1wiKTtcbiAgY29uc3QgZ3JvdXBJY29uU2l6ZSA9IHBhZGRpbmcgKiAwLjc1O1xuICBjb25zdCBmb250U2l6ZSA9IGdldENvbmZpZ0ZpZWxkKFwiZm9udFNpemVcIik7XG4gIGNvbnN0IGljb25TaXplID0gZ2V0Q29uZmlnRmllbGQoXCJpY29uU2l6ZVwiKTtcbiAgY29uc3QgaGFsZkljb25TaXplID0gaWNvblNpemUgLyAyO1xuICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICBjeS5ub2RlcygpLm1hcChhc3luYyAobm9kZSkgPT4ge1xuICAgICAgY29uc3QgZGF0YSA9IG5vZGVEYXRhKG5vZGUpO1xuICAgICAgaWYgKGRhdGEudHlwZSA9PT0gXCJncm91cFwiKSB7XG4gICAgICAgIGNvbnN0IHsgaCwgdywgeDEsIHkxIH0gPSBub2RlLmJvdW5kaW5nQm94KCk7XG4gICAgICAgIGdyb3Vwc0VsLmFwcGVuZChcInJlY3RcIikuYXR0cihcInhcIiwgeDEgKyBoYWxmSWNvblNpemUpLmF0dHIoXCJ5XCIsIHkxICsgaGFsZkljb25TaXplKS5hdHRyKFwid2lkdGhcIiwgdykuYXR0cihcImhlaWdodFwiLCBoKS5hdHRyKFwiY2xhc3NcIiwgXCJub2RlLWJrZ1wiKTtcbiAgICAgICAgY29uc3QgZ3JvdXBMYWJlbENvbnRhaW5lciA9IGdyb3Vwc0VsLmFwcGVuZChcImdcIik7XG4gICAgICAgIGxldCBzaGlmdGVkWDEgPSB4MTtcbiAgICAgICAgbGV0IHNoaWZ0ZWRZMSA9IHkxO1xuICAgICAgICBpZiAoZGF0YS5pY29uKSB7XG4gICAgICAgICAgY29uc3QgYmtnRWxlbSA9IGdyb3VwTGFiZWxDb250YWluZXIuYXBwZW5kKFwiZ1wiKTtcbiAgICAgICAgICBia2dFbGVtLmh0bWwoXG4gICAgICAgICAgICBgPGc+JHthd2FpdCBnZXRJY29uU1ZHKGRhdGEuaWNvbiwgeyBoZWlnaHQ6IGdyb3VwSWNvblNpemUsIHdpZHRoOiBncm91cEljb25TaXplLCBmYWxsYmFja1ByZWZpeDogYXJjaGl0ZWN0dXJlSWNvbnMucHJlZml4IH0pfTwvZz5gXG4gICAgICAgICAgKTtcbiAgICAgICAgICBia2dFbGVtLmF0dHIoXG4gICAgICAgICAgICBcInRyYW5zZm9ybVwiLFxuICAgICAgICAgICAgXCJ0cmFuc2xhdGUoXCIgKyAoc2hpZnRlZFgxICsgaGFsZkljb25TaXplICsgMSkgKyBcIiwgXCIgKyAoc2hpZnRlZFkxICsgaGFsZkljb25TaXplICsgMSkgKyBcIilcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgc2hpZnRlZFgxICs9IGdyb3VwSWNvblNpemU7XG4gICAgICAgICAgc2hpZnRlZFkxICs9IGZvbnRTaXplIC8gMiAtIDEgLSAyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmxhYmVsKSB7XG4gICAgICAgICAgY29uc3QgdGV4dEVsZW0gPSBncm91cExhYmVsQ29udGFpbmVyLmFwcGVuZChcImdcIik7XG4gICAgICAgICAgYXdhaXQgY3JlYXRlVGV4dChcbiAgICAgICAgICAgIHRleHRFbGVtLFxuICAgICAgICAgICAgZGF0YS5sYWJlbCxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdXNlSHRtbExhYmVsczogZmFsc2UsXG4gICAgICAgICAgICAgIHdpZHRoOiB3LFxuICAgICAgICAgICAgICBjbGFzc2VzOiBcImFyY2hpdGVjdHVyZS1zZXJ2aWNlLWxhYmVsXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRDb25maWcoKVxuICAgICAgICAgICk7XG4gICAgICAgICAgdGV4dEVsZW0uYXR0cihcImR5XCIsIFwiMWVtXCIpLmF0dHIoXCJhbGlnbm1lbnQtYmFzZWxpbmVcIiwgXCJtaWRkbGVcIikuYXR0cihcImRvbWluYW50LWJhc2VsaW5lXCIsIFwic3RhcnRcIikuYXR0cihcInRleHQtYW5jaG9yXCIsIFwic3RhcnRcIik7XG4gICAgICAgICAgdGV4dEVsZW0uYXR0cihcbiAgICAgICAgICAgIFwidHJhbnNmb3JtXCIsXG4gICAgICAgICAgICBcInRyYW5zbGF0ZShcIiArIChzaGlmdGVkWDEgKyBoYWxmSWNvblNpemUgKyA0KSArIFwiLCBcIiArIChzaGlmdGVkWTEgKyBoYWxmSWNvblNpemUgKyAyKSArIFwiKVwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gICk7XG59LCBcImRyYXdHcm91cHNcIik7XG52YXIgZHJhd1NlcnZpY2VzID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShhc3luYyBmdW5jdGlvbihkYjIsIGVsZW0sIHNlcnZpY2VzKSB7XG4gIGZvciAoY29uc3Qgc2VydmljZSBvZiBzZXJ2aWNlcykge1xuICAgIGNvbnN0IHNlcnZpY2VFbGVtID0gZWxlbS5hcHBlbmQoXCJnXCIpO1xuICAgIGNvbnN0IGljb25TaXplID0gZ2V0Q29uZmlnRmllbGQoXCJpY29uU2l6ZVwiKTtcbiAgICBpZiAoc2VydmljZS50aXRsZSkge1xuICAgICAgY29uc3QgdGV4dEVsZW0gPSBzZXJ2aWNlRWxlbS5hcHBlbmQoXCJnXCIpO1xuICAgICAgYXdhaXQgY3JlYXRlVGV4dChcbiAgICAgICAgdGV4dEVsZW0sXG4gICAgICAgIHNlcnZpY2UudGl0bGUsXG4gICAgICAgIHtcbiAgICAgICAgICB1c2VIdG1sTGFiZWxzOiBmYWxzZSxcbiAgICAgICAgICB3aWR0aDogaWNvblNpemUgKiAxLjUsXG4gICAgICAgICAgY2xhc3NlczogXCJhcmNoaXRlY3R1cmUtc2VydmljZS1sYWJlbFwiXG4gICAgICAgIH0sXG4gICAgICAgIGdldENvbmZpZygpXG4gICAgICApO1xuICAgICAgdGV4dEVsZW0uYXR0cihcImR5XCIsIFwiMWVtXCIpLmF0dHIoXCJhbGlnbm1lbnQtYmFzZWxpbmVcIiwgXCJtaWRkbGVcIikuYXR0cihcImRvbWluYW50LWJhc2VsaW5lXCIsIFwibWlkZGxlXCIpLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKTtcbiAgICAgIHRleHRFbGVtLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBpY29uU2l6ZSAvIDIgKyBcIiwgXCIgKyBpY29uU2l6ZSArIFwiKVwiKTtcbiAgICB9XG4gICAgY29uc3QgYmtnRWxlbSA9IHNlcnZpY2VFbGVtLmFwcGVuZChcImdcIik7XG4gICAgaWYgKHNlcnZpY2UuaWNvbikge1xuICAgICAgYmtnRWxlbS5odG1sKFxuICAgICAgICBgPGc+JHthd2FpdCBnZXRJY29uU1ZHKHNlcnZpY2UuaWNvbiwgeyBoZWlnaHQ6IGljb25TaXplLCB3aWR0aDogaWNvblNpemUsIGZhbGxiYWNrUHJlZml4OiBhcmNoaXRlY3R1cmVJY29ucy5wcmVmaXggfSl9PC9nPmBcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChzZXJ2aWNlLmljb25UZXh0KSB7XG4gICAgICBia2dFbGVtLmh0bWwoXG4gICAgICAgIGA8Zz4ke2F3YWl0IGdldEljb25TVkcoXCJibGFua1wiLCB7IGhlaWdodDogaWNvblNpemUsIHdpZHRoOiBpY29uU2l6ZSwgZmFsbGJhY2tQcmVmaXg6IGFyY2hpdGVjdHVyZUljb25zLnByZWZpeCB9KX08L2c+YFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHRleHRFbGVtQ29udGFpbmVyID0gYmtnRWxlbS5hcHBlbmQoXCJnXCIpO1xuICAgICAgY29uc3QgZm8gPSB0ZXh0RWxlbUNvbnRhaW5lci5hcHBlbmQoXCJmb3JlaWduT2JqZWN0XCIpLmF0dHIoXCJ3aWR0aFwiLCBpY29uU2l6ZSkuYXR0cihcImhlaWdodFwiLCBpY29uU2l6ZSk7XG4gICAgICBjb25zdCBkaXZFbGVtID0gZm8uYXBwZW5kKFwiZGl2XCIpLmF0dHIoXCJjbGFzc1wiLCBcIm5vZGUtaWNvbi10ZXh0XCIpLmF0dHIoXCJzdHlsZVwiLCBgaGVpZ2h0OiAke2ljb25TaXplfXB4O2ApLmFwcGVuZChcImRpdlwiKS5odG1sKHNlcnZpY2UuaWNvblRleHQpO1xuICAgICAgY29uc3QgZm9udFNpemUgPSBwYXJzZUludChcbiAgICAgICAgd2luZG93LmdldENvbXB1dGVkU3R5bGUoZGl2RWxlbS5ub2RlKCksIG51bGwpLmdldFByb3BlcnR5VmFsdWUoXCJmb250LXNpemVcIikucmVwbGFjZSgvXFxEL2csIFwiXCIpXG4gICAgICApID8/IDE2O1xuICAgICAgZGl2RWxlbS5hdHRyKFwic3R5bGVcIiwgYC13ZWJraXQtbGluZS1jbGFtcDogJHtNYXRoLmZsb29yKChpY29uU2l6ZSAtIDIpIC8gZm9udFNpemUpfTtgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmtnRWxlbS5hcHBlbmQoXCJwYXRoXCIpLmF0dHIoXCJjbGFzc1wiLCBcIm5vZGUtYmtnXCIpLmF0dHIoXCJpZFwiLCBcIm5vZGUtXCIgKyBzZXJ2aWNlLmlkKS5hdHRyKFxuICAgICAgICBcImRcIixcbiAgICAgICAgYE0wICR7aWNvblNpemV9IHYkey1pY29uU2l6ZX0gcTAsLTUgNSwtNSBoJHtpY29uU2l6ZX0gcTUsMCA1LDUgdiR7aWNvblNpemV9IEgwIFpgXG4gICAgICApO1xuICAgIH1cbiAgICBzZXJ2aWNlRWxlbS5hdHRyKFwiY2xhc3NcIiwgXCJhcmNoaXRlY3R1cmUtc2VydmljZVwiKTtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHNlcnZpY2VFbGVtLl9ncm91cHNbMF1bMF0uZ2V0QkJveCgpO1xuICAgIHNlcnZpY2Uud2lkdGggPSB3aWR0aDtcbiAgICBzZXJ2aWNlLmhlaWdodCA9IGhlaWdodDtcbiAgICBkYjIuc2V0RWxlbWVudEZvcklkKHNlcnZpY2UuaWQsIHNlcnZpY2VFbGVtKTtcbiAgfVxuICByZXR1cm4gMDtcbn0sIFwiZHJhd1NlcnZpY2VzXCIpO1xudmFyIGRyYXdKdW5jdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKGZ1bmN0aW9uKGRiMiwgZWxlbSwganVuY3Rpb25zKSB7XG4gIGp1bmN0aW9ucy5mb3JFYWNoKChqdW5jdGlvbikgPT4ge1xuICAgIGNvbnN0IGp1bmN0aW9uRWxlbSA9IGVsZW0uYXBwZW5kKFwiZ1wiKTtcbiAgICBjb25zdCBpY29uU2l6ZSA9IGdldENvbmZpZ0ZpZWxkKFwiaWNvblNpemVcIik7XG4gICAgY29uc3QgYmtnRWxlbSA9IGp1bmN0aW9uRWxlbS5hcHBlbmQoXCJnXCIpO1xuICAgIGJrZ0VsZW0uYXBwZW5kKFwicmVjdFwiKS5hdHRyKFwiaWRcIiwgXCJub2RlLVwiICsganVuY3Rpb24uaWQpLmF0dHIoXCJmaWxsLW9wYWNpdHlcIiwgXCIwXCIpLmF0dHIoXCJ3aWR0aFwiLCBpY29uU2l6ZSkuYXR0cihcImhlaWdodFwiLCBpY29uU2l6ZSk7XG4gICAganVuY3Rpb25FbGVtLmF0dHIoXCJjbGFzc1wiLCBcImFyY2hpdGVjdHVyZS1qdW5jdGlvblwiKTtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGp1bmN0aW9uRWxlbS5fZ3JvdXBzWzBdWzBdLmdldEJCb3goKTtcbiAgICBqdW5jdGlvbkVsZW0ud2lkdGggPSB3aWR0aDtcbiAgICBqdW5jdGlvbkVsZW0uaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGRiMi5zZXRFbGVtZW50Rm9ySWQoanVuY3Rpb24uaWQsIGp1bmN0aW9uRWxlbSk7XG4gIH0pO1xufSwgXCJkcmF3SnVuY3Rpb25zXCIpO1xuXG4vLyBzcmMvZGlhZ3JhbXMvYXJjaGl0ZWN0dXJlL2FyY2hpdGVjdHVyZVJlbmRlcmVyLnRzXG5yZWdpc3Rlckljb25QYWNrcyhbXG4gIHtcbiAgICBuYW1lOiBhcmNoaXRlY3R1cmVJY29ucy5wcmVmaXgsXG4gICAgaWNvbnM6IGFyY2hpdGVjdHVyZUljb25zXG4gIH1cbl0pO1xuY3l0b3NjYXBlLnVzZShmY29zZSk7XG5mdW5jdGlvbiBhZGRTZXJ2aWNlcyhzZXJ2aWNlcywgY3kpIHtcbiAgc2VydmljZXMuZm9yRWFjaCgoc2VydmljZSkgPT4ge1xuICAgIGN5LmFkZCh7XG4gICAgICBncm91cDogXCJub2Rlc1wiLFxuICAgICAgZGF0YToge1xuICAgICAgICB0eXBlOiBcInNlcnZpY2VcIixcbiAgICAgICAgaWQ6IHNlcnZpY2UuaWQsXG4gICAgICAgIGljb246IHNlcnZpY2UuaWNvbixcbiAgICAgICAgbGFiZWw6IHNlcnZpY2UudGl0bGUsXG4gICAgICAgIHBhcmVudDogc2VydmljZS5pbixcbiAgICAgICAgd2lkdGg6IGdldENvbmZpZ0ZpZWxkKFwiaWNvblNpemVcIiksXG4gICAgICAgIGhlaWdodDogZ2V0Q29uZmlnRmllbGQoXCJpY29uU2l6ZVwiKVxuICAgICAgfSxcbiAgICAgIGNsYXNzZXM6IFwibm9kZS1zZXJ2aWNlXCJcbiAgICB9KTtcbiAgfSk7XG59XG5fX25hbWUoYWRkU2VydmljZXMsIFwiYWRkU2VydmljZXNcIik7XG5mdW5jdGlvbiBhZGRKdW5jdGlvbnMoanVuY3Rpb25zLCBjeSkge1xuICBqdW5jdGlvbnMuZm9yRWFjaCgoanVuY3Rpb24pID0+IHtcbiAgICBjeS5hZGQoe1xuICAgICAgZ3JvdXA6IFwibm9kZXNcIixcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdHlwZTogXCJqdW5jdGlvblwiLFxuICAgICAgICBpZDoganVuY3Rpb24uaWQsXG4gICAgICAgIHBhcmVudDoganVuY3Rpb24uaW4sXG4gICAgICAgIHdpZHRoOiBnZXRDb25maWdGaWVsZChcImljb25TaXplXCIpLFxuICAgICAgICBoZWlnaHQ6IGdldENvbmZpZ0ZpZWxkKFwiaWNvblNpemVcIilcbiAgICAgIH0sXG4gICAgICBjbGFzc2VzOiBcIm5vZGUtanVuY3Rpb25cIlxuICAgIH0pO1xuICB9KTtcbn1cbl9fbmFtZShhZGRKdW5jdGlvbnMsIFwiYWRkSnVuY3Rpb25zXCIpO1xuZnVuY3Rpb24gcG9zaXRpb25Ob2RlcyhkYjIsIGN5KSB7XG4gIGN5Lm5vZGVzKCkubWFwKChub2RlKSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IG5vZGVEYXRhKG5vZGUpO1xuICAgIGlmIChkYXRhLnR5cGUgPT09IFwiZ3JvdXBcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkYXRhLnggPSBub2RlLnBvc2l0aW9uKCkueDtcbiAgICBkYXRhLnkgPSBub2RlLnBvc2l0aW9uKCkueTtcbiAgICBjb25zdCBub2RlRWxlbSA9IGRiMi5nZXRFbGVtZW50QnlJZChkYXRhLmlkKTtcbiAgICBub2RlRWxlbS5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgKGRhdGEueCB8fCAwKSArIFwiLFwiICsgKGRhdGEueSB8fCAwKSArIFwiKVwiKTtcbiAgfSk7XG59XG5fX25hbWUocG9zaXRpb25Ob2RlcywgXCJwb3NpdGlvbk5vZGVzXCIpO1xuZnVuY3Rpb24gYWRkR3JvdXBzKGdyb3VwcywgY3kpIHtcbiAgZ3JvdXBzLmZvckVhY2goKGdyb3VwKSA9PiB7XG4gICAgY3kuYWRkKHtcbiAgICAgIGdyb3VwOiBcIm5vZGVzXCIsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHR5cGU6IFwiZ3JvdXBcIixcbiAgICAgICAgaWQ6IGdyb3VwLmlkLFxuICAgICAgICBpY29uOiBncm91cC5pY29uLFxuICAgICAgICBsYWJlbDogZ3JvdXAudGl0bGUsXG4gICAgICAgIHBhcmVudDogZ3JvdXAuaW5cbiAgICAgIH0sXG4gICAgICBjbGFzc2VzOiBcIm5vZGUtZ3JvdXBcIlxuICAgIH0pO1xuICB9KTtcbn1cbl9fbmFtZShhZGRHcm91cHMsIFwiYWRkR3JvdXBzXCIpO1xuZnVuY3Rpb24gYWRkRWRnZXMoZWRnZXMsIGN5KSB7XG4gIGVkZ2VzLmZvckVhY2goKHBhcnNlZEVkZ2UpID0+IHtcbiAgICBjb25zdCB7IGxoc0lkLCByaHNJZCwgbGhzSW50bywgbGhzR3JvdXAsIHJoc0ludG8sIGxoc0RpciwgcmhzRGlyLCByaHNHcm91cCwgdGl0bGUgfSA9IHBhcnNlZEVkZ2U7XG4gICAgY29uc3QgZWRnZVR5cGUgPSBpc0FyY2hpdGVjdHVyZURpcmVjdGlvblhZKHBhcnNlZEVkZ2UubGhzRGlyLCBwYXJzZWRFZGdlLnJoc0RpcikgPyBcInNlZ21lbnRzXCIgOiBcInN0cmFpZ2h0XCI7XG4gICAgY29uc3QgZWRnZSA9IHtcbiAgICAgIGlkOiBgJHtsaHNJZH0tJHtyaHNJZH1gLFxuICAgICAgbGFiZWw6IHRpdGxlLFxuICAgICAgc291cmNlOiBsaHNJZCxcbiAgICAgIHNvdXJjZURpcjogbGhzRGlyLFxuICAgICAgc291cmNlQXJyb3c6IGxoc0ludG8sXG4gICAgICBzb3VyY2VHcm91cDogbGhzR3JvdXAsXG4gICAgICBzb3VyY2VFbmRwb2ludDogbGhzRGlyID09PSBcIkxcIiA/IFwiMCA1MCVcIiA6IGxoc0RpciA9PT0gXCJSXCIgPyBcIjEwMCUgNTAlXCIgOiBsaHNEaXIgPT09IFwiVFwiID8gXCI1MCUgMFwiIDogXCI1MCUgMTAwJVwiLFxuICAgICAgdGFyZ2V0OiByaHNJZCxcbiAgICAgIHRhcmdldERpcjogcmhzRGlyLFxuICAgICAgdGFyZ2V0QXJyb3c6IHJoc0ludG8sXG4gICAgICB0YXJnZXRHcm91cDogcmhzR3JvdXAsXG4gICAgICB0YXJnZXRFbmRwb2ludDogcmhzRGlyID09PSBcIkxcIiA/IFwiMCA1MCVcIiA6IHJoc0RpciA9PT0gXCJSXCIgPyBcIjEwMCUgNTAlXCIgOiByaHNEaXIgPT09IFwiVFwiID8gXCI1MCUgMFwiIDogXCI1MCUgMTAwJVwiXG4gICAgfTtcbiAgICBjeS5hZGQoe1xuICAgICAgZ3JvdXA6IFwiZWRnZXNcIixcbiAgICAgIGRhdGE6IGVkZ2UsXG4gICAgICBjbGFzc2VzOiBlZGdlVHlwZVxuICAgIH0pO1xuICB9KTtcbn1cbl9fbmFtZShhZGRFZGdlcywgXCJhZGRFZGdlc1wiKTtcbmZ1bmN0aW9uIGdldEFsaWdubWVudHMoc3BhdGlhbE1hcHMpIHtcbiAgY29uc3QgYWxpZ25tZW50cyA9IHNwYXRpYWxNYXBzLm1hcCgoc3BhdGlhbE1hcCkgPT4ge1xuICAgIGNvbnN0IGhvcml6b250YWxBbGlnbm1lbnRzID0ge307XG4gICAgY29uc3QgdmVydGljYWxBbGlnbm1lbnRzID0ge307XG4gICAgT2JqZWN0LmVudHJpZXMoc3BhdGlhbE1hcCkuZm9yRWFjaCgoW2lkLCBbeCwgeV1dKSA9PiB7XG4gICAgICBpZiAoIWhvcml6b250YWxBbGlnbm1lbnRzW3ldKSB7XG4gICAgICAgIGhvcml6b250YWxBbGlnbm1lbnRzW3ldID0gW107XG4gICAgICB9XG4gICAgICBpZiAoIXZlcnRpY2FsQWxpZ25tZW50c1t4XSkge1xuICAgICAgICB2ZXJ0aWNhbEFsaWdubWVudHNbeF0gPSBbXTtcbiAgICAgIH1cbiAgICAgIGhvcml6b250YWxBbGlnbm1lbnRzW3ldLnB1c2goaWQpO1xuICAgICAgdmVydGljYWxBbGlnbm1lbnRzW3hdLnB1c2goaWQpO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBob3JpejogT2JqZWN0LnZhbHVlcyhob3Jpem9udGFsQWxpZ25tZW50cykuZmlsdGVyKChhcnIpID0+IGFyci5sZW5ndGggPiAxKSxcbiAgICAgIHZlcnQ6IE9iamVjdC52YWx1ZXModmVydGljYWxBbGlnbm1lbnRzKS5maWx0ZXIoKGFycikgPT4gYXJyLmxlbmd0aCA+IDEpXG4gICAgfTtcbiAgfSk7XG4gIGNvbnN0IFtob3Jpem9udGFsLCB2ZXJ0aWNhbF0gPSBhbGlnbm1lbnRzLnJlZHVjZShcbiAgICAoW3ByZXZIb3JpeiwgcHJldlZlcnRdLCB7IGhvcml6LCB2ZXJ0IH0pID0+IHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIFsuLi5wcmV2SG9yaXosIC4uLmhvcml6XSxcbiAgICAgICAgWy4uLnByZXZWZXJ0LCAuLi52ZXJ0XVxuICAgICAgXTtcbiAgICB9LFxuICAgIFtbXSwgW11dXG4gICk7XG4gIHJldHVybiB7XG4gICAgaG9yaXpvbnRhbCxcbiAgICB2ZXJ0aWNhbFxuICB9O1xufVxuX19uYW1lKGdldEFsaWdubWVudHMsIFwiZ2V0QWxpZ25tZW50c1wiKTtcbmZ1bmN0aW9uIGdldFJlbGF0aXZlQ29uc3RyYWludHMoc3BhdGlhbE1hcHMpIHtcbiAgY29uc3QgcmVsYXRpdmVDb25zdHJhaW50cyA9IFtdO1xuICBjb25zdCBwb3NUb1N0ciA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHBvcykgPT4gYCR7cG9zWzBdfSwke3Bvc1sxXX1gLCBcInBvc1RvU3RyXCIpO1xuICBjb25zdCBzdHJUb1BvcyA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKHBvcykgPT4gcG9zLnNwbGl0KFwiLFwiKS5tYXAoKHApID0+IHBhcnNlSW50KHApKSwgXCJzdHJUb1Bvc1wiKTtcbiAgc3BhdGlhbE1hcHMuZm9yRWFjaCgoc3BhdGlhbE1hcCkgPT4ge1xuICAgIGNvbnN0IGludlNwYXRpYWxNYXAgPSBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBPYmplY3QuZW50cmllcyhzcGF0aWFsTWFwKS5tYXAoKFtpZCwgcG9zXSkgPT4gW3Bvc1RvU3RyKHBvcyksIGlkXSlcbiAgICApO1xuICAgIGNvbnN0IHF1ZXVlID0gW3Bvc1RvU3RyKFswLCAwXSldO1xuICAgIGNvbnN0IHZpc2l0ZWQgPSB7fTtcbiAgICBjb25zdCBkaXJlY3Rpb25zID0ge1xuICAgICAgTDogWy0xLCAwXSxcbiAgICAgIFI6IFsxLCAwXSxcbiAgICAgIFQ6IFswLCAxXSxcbiAgICAgIEI6IFswLCAtMV1cbiAgICB9O1xuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBjdXJyID0gcXVldWUuc2hpZnQoKTtcbiAgICAgIGlmIChjdXJyKSB7XG4gICAgICAgIHZpc2l0ZWRbY3Vycl0gPSAxO1xuICAgICAgICBjb25zdCBjdXJySWQgPSBpbnZTcGF0aWFsTWFwW2N1cnJdO1xuICAgICAgICBpZiAoY3VycklkKSB7XG4gICAgICAgICAgY29uc3QgY3VyclBvcyA9IHN0clRvUG9zKGN1cnIpO1xuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGRpcmVjdGlvbnMpLmZvckVhY2goKFtkaXIsIHNoaWZ0XSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3UG9zID0gcG9zVG9TdHIoW2N1cnJQb3NbMF0gKyBzaGlmdFswXSwgY3VyclBvc1sxXSArIHNoaWZ0WzFdXSk7XG4gICAgICAgICAgICBjb25zdCBuZXdJZCA9IGludlNwYXRpYWxNYXBbbmV3UG9zXTtcbiAgICAgICAgICAgIGlmIChuZXdJZCAmJiAhdmlzaXRlZFtuZXdQb3NdKSB7XG4gICAgICAgICAgICAgIHF1ZXVlLnB1c2gobmV3UG9zKTtcbiAgICAgICAgICAgICAgcmVsYXRpdmVDb25zdHJhaW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBbQXJjaGl0ZWN0dXJlRGlyZWN0aW9uTmFtZVtkaXJdXTogbmV3SWQsXG4gICAgICAgICAgICAgICAgW0FyY2hpdGVjdHVyZURpcmVjdGlvbk5hbWVbZ2V0T3Bwb3NpdGVBcmNoaXRlY3R1cmVEaXJlY3Rpb24oZGlyKV1dOiBjdXJySWQsXG4gICAgICAgICAgICAgICAgZ2FwOiAxLjUgKiBnZXRDb25maWdGaWVsZChcImljb25TaXplXCIpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlbGF0aXZlQ29uc3RyYWludHM7XG59XG5fX25hbWUoZ2V0UmVsYXRpdmVDb25zdHJhaW50cywgXCJnZXRSZWxhdGl2ZUNvbnN0cmFpbnRzXCIpO1xuZnVuY3Rpb24gbGF5b3V0QXJjaGl0ZWN0dXJlKHNlcnZpY2VzLCBqdW5jdGlvbnMsIGdyb3VwcywgZWRnZXMsIHsgc3BhdGlhbE1hcHMgfSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBjb25zdCByZW5kZXJFbCA9IHNlbGVjdChcImJvZHlcIikuYXBwZW5kKFwiZGl2XCIpLmF0dHIoXCJpZFwiLCBcImN5XCIpLmF0dHIoXCJzdHlsZVwiLCBcImRpc3BsYXk6bm9uZVwiKTtcbiAgICBjb25zdCBjeSA9IGN5dG9zY2FwZSh7XG4gICAgICBjb250YWluZXI6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY3lcIiksXG4gICAgICBzdHlsZTogW1xuICAgICAgICB7XG4gICAgICAgICAgc2VsZWN0b3I6IFwiZWRnZVwiLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBcImN1cnZlLXN0eWxlXCI6IFwic3RyYWlnaHRcIixcbiAgICAgICAgICAgIGxhYmVsOiBcImRhdGEobGFiZWwpXCIsXG4gICAgICAgICAgICBcInNvdXJjZS1lbmRwb2ludFwiOiBcImRhdGEoc291cmNlRW5kcG9pbnQpXCIsXG4gICAgICAgICAgICBcInRhcmdldC1lbmRwb2ludFwiOiBcImRhdGEodGFyZ2V0RW5kcG9pbnQpXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBzZWxlY3RvcjogXCJlZGdlLnNlZ21lbnRzXCIsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIFwiY3VydmUtc3R5bGVcIjogXCJzZWdtZW50c1wiLFxuICAgICAgICAgICAgXCJzZWdtZW50LXdlaWdodHNcIjogXCIwXCIsXG4gICAgICAgICAgICBcInNlZ21lbnQtZGlzdGFuY2VzXCI6IFswLjVdLFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBJbmNvcnJlY3QgbGlicmFyeSB0eXBlc1xuICAgICAgICAgICAgXCJlZGdlLWRpc3RhbmNlc1wiOiBcImVuZHBvaW50c1wiLFxuICAgICAgICAgICAgXCJzb3VyY2UtZW5kcG9pbnRcIjogXCJkYXRhKHNvdXJjZUVuZHBvaW50KVwiLFxuICAgICAgICAgICAgXCJ0YXJnZXQtZW5kcG9pbnRcIjogXCJkYXRhKHRhcmdldEVuZHBvaW50KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgc2VsZWN0b3I6IFwibm9kZVwiLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIEluY29ycmVjdCBsaWJyYXJ5IHR5cGVzXG4gICAgICAgICAgICBcImNvbXBvdW5kLXNpemluZy13cnQtbGFiZWxzXCI6IFwiaW5jbHVkZVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgc2VsZWN0b3I6IFwibm9kZVtsYWJlbF1cIixcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgXCJ0ZXh0LXZhbGlnblwiOiBcImJvdHRvbVwiLFxuICAgICAgICAgICAgXCJ0ZXh0LWhhbGlnblwiOiBcImNlbnRlclwiLFxuICAgICAgICAgICAgXCJmb250LXNpemVcIjogYCR7Z2V0Q29uZmlnRmllbGQoXCJmb250U2l6ZVwiKX1weGBcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBzZWxlY3RvcjogXCIubm9kZS1zZXJ2aWNlXCIsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGxhYmVsOiBcImRhdGEobGFiZWwpXCIsXG4gICAgICAgICAgICB3aWR0aDogXCJkYXRhKHdpZHRoKVwiLFxuICAgICAgICAgICAgaGVpZ2h0OiBcImRhdGEoaGVpZ2h0KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgc2VsZWN0b3I6IFwiLm5vZGUtanVuY3Rpb25cIixcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgd2lkdGg6IFwiZGF0YSh3aWR0aClcIixcbiAgICAgICAgICAgIGhlaWdodDogXCJkYXRhKGhlaWdodClcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHNlbGVjdG9yOiBcIi5ub2RlLWdyb3VwXCIsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgSW5jb3JyZWN0IGxpYnJhcnkgdHlwZXNcbiAgICAgICAgICAgIHBhZGRpbmc6IGAke2dldENvbmZpZ0ZpZWxkKFwicGFkZGluZ1wiKX1weGBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9KTtcbiAgICByZW5kZXJFbC5yZW1vdmUoKTtcbiAgICBhZGRHcm91cHMoZ3JvdXBzLCBjeSk7XG4gICAgYWRkU2VydmljZXMoc2VydmljZXMsIGN5KTtcbiAgICBhZGRKdW5jdGlvbnMoanVuY3Rpb25zLCBjeSk7XG4gICAgYWRkRWRnZXMoZWRnZXMsIGN5KTtcbiAgICBjb25zdCBhbGlnbm1lbnRDb25zdHJhaW50ID0gZ2V0QWxpZ25tZW50cyhzcGF0aWFsTWFwcyk7XG4gICAgY29uc3QgcmVsYXRpdmVQbGFjZW1lbnRDb25zdHJhaW50ID0gZ2V0UmVsYXRpdmVDb25zdHJhaW50cyhzcGF0aWFsTWFwcyk7XG4gICAgY29uc3QgbGF5b3V0ID0gY3kubGF5b3V0KHtcbiAgICAgIG5hbWU6IFwiZmNvc2VcIixcbiAgICAgIHF1YWxpdHk6IFwicHJvb2ZcIixcbiAgICAgIHN0eWxlRW5hYmxlZDogZmFsc2UsXG4gICAgICBhbmltYXRlOiBmYWxzZSxcbiAgICAgIG5vZGVEaW1lbnNpb25zSW5jbHVkZUxhYmVsczogZmFsc2UsXG4gICAgICAvLyBBZGp1c3QgdGhlIGVkZ2UgcGFyYW1ldGVycyBpZiBpdCBwYXNzZXMgdGhyb3VnaCB0aGUgYm9yZGVyIG9mIGEgZ3JvdXBcbiAgICAgIC8vIEhhY2t5IGZpeCBmb3I6IGh0dHBzOi8vZ2l0aHViLmNvbS9pVmlzLWF0LUJpbGtlbnQvY3l0b3NjYXBlLmpzLWZjb3NlL2lzc3Vlcy82N1xuICAgICAgaWRlYWxFZGdlTGVuZ3RoKGVkZ2UpIHtcbiAgICAgICAgY29uc3QgW25vZGVBLCBub2RlQl0gPSBlZGdlLmNvbm5lY3RlZE5vZGVzKCk7XG4gICAgICAgIGNvbnN0IHsgcGFyZW50OiBwYXJlbnRBIH0gPSBub2RlRGF0YShub2RlQSk7XG4gICAgICAgIGNvbnN0IHsgcGFyZW50OiBwYXJlbnRCIH0gPSBub2RlRGF0YShub2RlQik7XG4gICAgICAgIGNvbnN0IGVsYXN0aWNpdHkgPSBwYXJlbnRBID09PSBwYXJlbnRCID8gMS41ICogZ2V0Q29uZmlnRmllbGQoXCJpY29uU2l6ZVwiKSA6IDAuNSAqIGdldENvbmZpZ0ZpZWxkKFwiaWNvblNpemVcIik7XG4gICAgICAgIHJldHVybiBlbGFzdGljaXR5O1xuICAgICAgfSxcbiAgICAgIGVkZ2VFbGFzdGljaXR5KGVkZ2UpIHtcbiAgICAgICAgY29uc3QgW25vZGVBLCBub2RlQl0gPSBlZGdlLmNvbm5lY3RlZE5vZGVzKCk7XG4gICAgICAgIGNvbnN0IHsgcGFyZW50OiBwYXJlbnRBIH0gPSBub2RlRGF0YShub2RlQSk7XG4gICAgICAgIGNvbnN0IHsgcGFyZW50OiBwYXJlbnRCIH0gPSBub2RlRGF0YShub2RlQik7XG4gICAgICAgIGNvbnN0IGVsYXN0aWNpdHkgPSBwYXJlbnRBID09PSBwYXJlbnRCID8gMC40NSA6IDFlLTM7XG4gICAgICAgIHJldHVybiBlbGFzdGljaXR5O1xuICAgICAgfSxcbiAgICAgIGFsaWdubWVudENvbnN0cmFpbnQsXG4gICAgICByZWxhdGl2ZVBsYWNlbWVudENvbnN0cmFpbnRcbiAgICB9KTtcbiAgICBsYXlvdXQub25lKFwibGF5b3V0c3RvcFwiLCAoKSA9PiB7XG4gICAgICBmdW5jdGlvbiBnZXRTZWdtZW50V2VpZ2h0cyhzb3VyY2UsIHRhcmdldCwgcG9pbnRYLCBwb2ludFkpIHtcbiAgICAgICAgbGV0IFcsIEQ7XG4gICAgICAgIGNvbnN0IHsgeDogc1gsIHk6IHNZIH0gPSBzb3VyY2U7XG4gICAgICAgIGNvbnN0IHsgeDogdFgsIHk6IHRZIH0gPSB0YXJnZXQ7XG4gICAgICAgIEQgPSAocG9pbnRZIC0gc1kgKyAoc1ggLSBwb2ludFgpICogKHNZIC0gdFkpIC8gKHNYIC0gdFgpKSAvIE1hdGguc3FydCgxICsgTWF0aC5wb3coKHNZIC0gdFkpIC8gKHNYIC0gdFgpLCAyKSk7XG4gICAgICAgIFcgPSBNYXRoLnNxcnQoTWF0aC5wb3cocG9pbnRZIC0gc1ksIDIpICsgTWF0aC5wb3cocG9pbnRYIC0gc1gsIDIpIC0gTWF0aC5wb3coRCwgMikpO1xuICAgICAgICBjb25zdCBkaXN0QUIgPSBNYXRoLnNxcnQoTWF0aC5wb3codFggLSBzWCwgMikgKyBNYXRoLnBvdyh0WSAtIHNZLCAyKSk7XG4gICAgICAgIFcgPSBXIC8gZGlzdEFCO1xuICAgICAgICBsZXQgZGVsdGExID0gKHRYIC0gc1gpICogKHBvaW50WSAtIHNZKSAtICh0WSAtIHNZKSAqIChwb2ludFggLSBzWCk7XG4gICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgIGNhc2UgZGVsdGExID49IDA6XG4gICAgICAgICAgICBkZWx0YTEgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBkZWx0YTEgPCAwOlxuICAgICAgICAgICAgZGVsdGExID0gLTE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVsdGEyID0gKHRYIC0gc1gpICogKHBvaW50WCAtIHNYKSArICh0WSAtIHNZKSAqIChwb2ludFkgLSBzWSk7XG4gICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgIGNhc2UgZGVsdGEyID49IDA6XG4gICAgICAgICAgICBkZWx0YTIgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBkZWx0YTIgPCAwOlxuICAgICAgICAgICAgZGVsdGEyID0gLTE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBEID0gTWF0aC5hYnMoRCkgKiBkZWx0YTE7XG4gICAgICAgIFcgPSBXICogZGVsdGEyO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpc3RhbmNlczogRCxcbiAgICAgICAgICB3ZWlnaHRzOiBXXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBfX25hbWUoZ2V0U2VnbWVudFdlaWdodHMsIFwiZ2V0U2VnbWVudFdlaWdodHNcIik7XG4gICAgICBjeS5zdGFydEJhdGNoKCk7XG4gICAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgT2JqZWN0LnZhbHVlcyhjeS5lZGdlcygpKSkge1xuICAgICAgICBpZiAoZWRnZS5kYXRhPy4oKSkge1xuICAgICAgICAgIGNvbnN0IHsgeDogc1gsIHk6IHNZIH0gPSBlZGdlLnNvdXJjZSgpLnBvc2l0aW9uKCk7XG4gICAgICAgICAgY29uc3QgeyB4OiB0WCwgeTogdFkgfSA9IGVkZ2UudGFyZ2V0KCkucG9zaXRpb24oKTtcbiAgICAgICAgICBpZiAoc1ggIT09IHRYICYmIHNZICE9PSB0WSkge1xuICAgICAgICAgICAgY29uc3Qgc0VQID0gZWRnZS5zb3VyY2VFbmRwb2ludCgpO1xuICAgICAgICAgICAgY29uc3QgdEVQID0gZWRnZS50YXJnZXRFbmRwb2ludCgpO1xuICAgICAgICAgICAgY29uc3QgeyBzb3VyY2VEaXIgfSA9IGVkZ2VEYXRhKGVkZ2UpO1xuICAgICAgICAgICAgY29uc3QgW3BvaW50WCwgcG9pbnRZXSA9IGlzQXJjaGl0ZWN0dXJlRGlyZWN0aW9uWShzb3VyY2VEaXIpID8gW3NFUC54LCB0RVAueV0gOiBbdEVQLngsIHNFUC55XTtcbiAgICAgICAgICAgIGNvbnN0IHsgd2VpZ2h0cywgZGlzdGFuY2VzIH0gPSBnZXRTZWdtZW50V2VpZ2h0cyhzRVAsIHRFUCwgcG9pbnRYLCBwb2ludFkpO1xuICAgICAgICAgICAgZWRnZS5zdHlsZShcInNlZ21lbnQtZGlzdGFuY2VzXCIsIGRpc3RhbmNlcyk7XG4gICAgICAgICAgICBlZGdlLnN0eWxlKFwic2VnbWVudC13ZWlnaHRzXCIsIHdlaWdodHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3kuZW5kQmF0Y2goKTtcbiAgICAgIGxheW91dC5ydW4oKTtcbiAgICB9KTtcbiAgICBsYXlvdXQucnVuKCk7XG4gICAgY3kucmVhZHkoKGUpID0+IHtcbiAgICAgIGxvZy5pbmZvKFwiUmVhZHlcIiwgZSk7XG4gICAgICByZXNvbHZlKGN5KTtcbiAgICB9KTtcbiAgfSk7XG59XG5fX25hbWUobGF5b3V0QXJjaGl0ZWN0dXJlLCBcImxheW91dEFyY2hpdGVjdHVyZVwiKTtcbnZhciBkcmF3ID0gLyogQF9fUFVSRV9fICovIF9fbmFtZShhc3luYyAodGV4dCwgaWQsIF92ZXJzaW9uLCBkaWFnT2JqKSA9PiB7XG4gIGNvbnN0IGRiMiA9IGRpYWdPYmouZGI7XG4gIGNvbnN0IHNlcnZpY2VzID0gZGIyLmdldFNlcnZpY2VzKCk7XG4gIGNvbnN0IGp1bmN0aW9ucyA9IGRiMi5nZXRKdW5jdGlvbnMoKTtcbiAgY29uc3QgZ3JvdXBzID0gZGIyLmdldEdyb3VwcygpO1xuICBjb25zdCBlZGdlcyA9IGRiMi5nZXRFZGdlcygpO1xuICBjb25zdCBkcyA9IGRiMi5nZXREYXRhU3RydWN0dXJlcygpO1xuICBjb25zdCBzdmcgPSBzZWxlY3RTdmdFbGVtZW50KGlkKTtcbiAgY29uc3QgZWRnZXNFbGVtID0gc3ZnLmFwcGVuZChcImdcIik7XG4gIGVkZ2VzRWxlbS5hdHRyKFwiY2xhc3NcIiwgXCJhcmNoaXRlY3R1cmUtZWRnZXNcIik7XG4gIGNvbnN0IHNlcnZpY2VzRWxlbSA9IHN2Zy5hcHBlbmQoXCJnXCIpO1xuICBzZXJ2aWNlc0VsZW0uYXR0cihcImNsYXNzXCIsIFwiYXJjaGl0ZWN0dXJlLXNlcnZpY2VzXCIpO1xuICBjb25zdCBncm91cEVsZW0gPSBzdmcuYXBwZW5kKFwiZ1wiKTtcbiAgZ3JvdXBFbGVtLmF0dHIoXCJjbGFzc1wiLCBcImFyY2hpdGVjdHVyZS1ncm91cHNcIik7XG4gIGF3YWl0IGRyYXdTZXJ2aWNlcyhkYjIsIHNlcnZpY2VzRWxlbSwgc2VydmljZXMpO1xuICBkcmF3SnVuY3Rpb25zKGRiMiwgc2VydmljZXNFbGVtLCBqdW5jdGlvbnMpO1xuICBjb25zdCBjeSA9IGF3YWl0IGxheW91dEFyY2hpdGVjdHVyZShzZXJ2aWNlcywganVuY3Rpb25zLCBncm91cHMsIGVkZ2VzLCBkcyk7XG4gIGF3YWl0IGRyYXdFZGdlcyhlZGdlc0VsZW0sIGN5KTtcbiAgYXdhaXQgZHJhd0dyb3Vwcyhncm91cEVsZW0sIGN5KTtcbiAgcG9zaXRpb25Ob2RlcyhkYjIsIGN5KTtcbiAgc2V0dXBHcmFwaFZpZXdib3godm9pZCAwLCBzdmcsIGdldENvbmZpZ0ZpZWxkKFwicGFkZGluZ1wiKSwgZ2V0Q29uZmlnRmllbGQoXCJ1c2VNYXhXaWR0aFwiKSk7XG59LCBcImRyYXdcIik7XG52YXIgcmVuZGVyZXIgPSB7IGRyYXcgfTtcblxuLy8gc3JjL2RpYWdyYW1zL2FyY2hpdGVjdHVyZS9hcmNoaXRlY3R1cmVEaWFncmFtLnRzXG52YXIgZGlhZ3JhbSA9IHtcbiAgcGFyc2VyLFxuICBkYixcbiAgcmVuZGVyZXIsXG4gIHN0eWxlczogYXJjaGl0ZWN0dXJlU3R5bGVzX2RlZmF1bHRcbn07XG5leHBvcnQge1xuICBkaWFncmFtXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/mermaid/dist/chunks/mermaid.core/architectureDiagram-UYN6MBPD.mjs\n");

/***/ }),

/***/ "./node_modules/mermaid/dist/chunks/mermaid.core/chunk-KFBOBJHC.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/mermaid/dist/chunks/mermaid.core/chunk-KFBOBJHC.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ImperativeState: () => (/* binding */ ImperativeState)\n/* harmony export */ });\n/* harmony import */ var _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-6DBFFHIP.mjs */ \"./node_modules/mermaid/dist/chunks/mermaid.core/chunk-6DBFFHIP.mjs\");\n\n\n// src/utils/imperativeState.ts\nvar ImperativeState = class {\n  /**\n   * @param init - Function that creates the default state.\n   */\n  constructor(init) {\n    this.init = init;\n    this.records = this.init();\n  }\n  static {\n    (0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_0__.__name)(this, \"ImperativeState\");\n  }\n  reset() {\n    this.records = this.init();\n  }\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVybWFpZC9kaXN0L2NodW5rcy9tZXJtYWlkLmNvcmUvY2h1bmstS0ZCT0JKSEMubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBRThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksMkRBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUlFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViY2xpLWRlbW8vLi9ub2RlX21vZHVsZXMvbWVybWFpZC9kaXN0L2NodW5rcy9tZXJtYWlkLmNvcmUvY2h1bmstS0ZCT0JKSEMubWpzP2MxZDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgX19uYW1lXG59IGZyb20gXCIuL2NodW5rLTZEQkZGSElQLm1qc1wiO1xuXG4vLyBzcmMvdXRpbHMvaW1wZXJhdGl2ZVN0YXRlLnRzXG52YXIgSW1wZXJhdGl2ZVN0YXRlID0gY2xhc3Mge1xuICAvKipcbiAgICogQHBhcmFtIGluaXQgLSBGdW5jdGlvbiB0aGF0IGNyZWF0ZXMgdGhlIGRlZmF1bHQgc3RhdGUuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihpbml0KSB7XG4gICAgdGhpcy5pbml0ID0gaW5pdDtcbiAgICB0aGlzLnJlY29yZHMgPSB0aGlzLmluaXQoKTtcbiAgfVxuICBzdGF0aWMge1xuICAgIF9fbmFtZSh0aGlzLCBcIkltcGVyYXRpdmVTdGF0ZVwiKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLnJlY29yZHMgPSB0aGlzLmluaXQoKTtcbiAgfVxufTtcblxuZXhwb3J0IHtcbiAgSW1wZXJhdGl2ZVN0YXRlXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/mermaid/dist/chunks/mermaid.core/chunk-KFBOBJHC.mjs\n");

/***/ }),

/***/ "./node_modules/mermaid/dist/chunks/mermaid.core/chunk-TMUBEWPD.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/mermaid/dist/chunks/mermaid.core/chunk-TMUBEWPD.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   populateCommonDb: () => (/* binding */ populateCommonDb)\n/* harmony export */ });\n/* harmony import */ var _chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-6DBFFHIP.mjs */ \"./node_modules/mermaid/dist/chunks/mermaid.core/chunk-6DBFFHIP.mjs\");\n\n\n// src/diagrams/common/populateCommonDb.ts\nfunction populateCommonDb(ast, db) {\n  if (ast.accDescr) {\n    db.setAccDescription?.(ast.accDescr);\n  }\n  if (ast.accTitle) {\n    db.setAccTitle?.(ast.accTitle);\n  }\n  if (ast.title) {\n    db.setDiagramTitle?.(ast.title);\n  }\n}\n(0,_chunk_6DBFFHIP_mjs__WEBPACK_IMPORTED_MODULE_0__.__name)(populateCommonDb, \"populateCommonDb\");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVybWFpZC9kaXN0L2NodW5rcy9tZXJtYWlkLmNvcmUvY2h1bmstVE1VQkVXUEQubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBRThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBTTs7QUFJSiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYmNsaS1kZW1vLy4vbm9kZV9tb2R1bGVzL21lcm1haWQvZGlzdC9jaHVua3MvbWVybWFpZC5jb3JlL2NodW5rLVRNVUJFV1BELm1qcz8xYzQ4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIF9fbmFtZVxufSBmcm9tIFwiLi9jaHVuay02REJGRkhJUC5tanNcIjtcblxuLy8gc3JjL2RpYWdyYW1zL2NvbW1vbi9wb3B1bGF0ZUNvbW1vbkRiLnRzXG5mdW5jdGlvbiBwb3B1bGF0ZUNvbW1vbkRiKGFzdCwgZGIpIHtcbiAgaWYgKGFzdC5hY2NEZXNjcikge1xuICAgIGRiLnNldEFjY0Rlc2NyaXB0aW9uPy4oYXN0LmFjY0Rlc2NyKTtcbiAgfVxuICBpZiAoYXN0LmFjY1RpdGxlKSB7XG4gICAgZGIuc2V0QWNjVGl0bGU/Lihhc3QuYWNjVGl0bGUpO1xuICB9XG4gIGlmIChhc3QudGl0bGUpIHtcbiAgICBkYi5zZXREaWFncmFtVGl0bGU/Lihhc3QudGl0bGUpO1xuICB9XG59XG5fX25hbWUocG9wdWxhdGVDb21tb25EYiwgXCJwb3B1bGF0ZUNvbW1vbkRiXCIpO1xuXG5leHBvcnQge1xuICBwb3B1bGF0ZUNvbW1vbkRiXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/mermaid/dist/chunks/mermaid.core/chunk-TMUBEWPD.mjs\n");

/***/ })

}]);